<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p>Martin Escardo. Notes originally written for the module “Advanced
Functional Programming” at the School of Computer Science of the
University of Birmingham, UK.</p>
<!--
<pre class="Agda"><a id="178" class="Symbol">{-#</a> <a id="182" class="Keyword">OPTIONS</a> <a id="190" class="Pragma">--without-K</a> <a id="202" class="Pragma">--safe</a> <a id="209" class="Symbol">#-}</a>

<a id="214" class="Keyword">module</a> <a id="221" href="sums.html" class="Module">sums</a> <a id="226" class="Keyword">where</a>

<a id="233" class="Keyword">open</a> <a id="238" class="Keyword">import</a> <a id="245" href="general-notation.html" class="Module">general-notation</a>
</pre>-->
<h1 id="the-sum-type-former-σ">The sum type former <code>Σ</code></h1>
<p>Very often in computation we work with the type of pairs
<code>(x , y)</code> with <code>x : A</code> and <code>y : B</code>
where <code>A</code> and <code>B</code> are types. We will write
<code>A × B</code> for the type of such pairs, and call it the <a
href="https://en.wikipedia.org/wiki/Cartesian_product"><em>cartesian
product</em></a>. We will define this type as a particular case of a
more general type, whose elements are again of the form
<code>(x , y)</code> but with the difference that <code>x : A</code> and
<code>y : B x</code> where <code>A : Type</code> and
<code>B : A → Type</code>. The difference amounts to the fact that the
type of the second component <code>y</code> depends on the first element
<code>x</code>. The default notation for this type will be
<code>Σ {A} B</code>, or simply <code>Σ B</code> when <code>A</code> can
be inferred from the context, but we will also introduce the more common
sum notation <code>Σ x ꞉ A , B x</code>. This type is also called the <a
href="https://en.wikipedia.org/wiki/Disjoint_union">disjoint union</a>
of the type family <code>B : A → Type</code>.</p>
<h2 id="examples">Examples</h2>
<p>A simple example is the type
<code>Σ xs ꞉ List X , Vector X (length xs)</code> with
<code>X : Type</code>. An element of this type is a pair
<code>(xs , ys)</code> where <code>xs</code> is a list and
<code>ys</code> is a vector of the same length as <code>xs</code>.</p>
<p>Another example, which iterates the <code>Σ</code> type construction,
is <code>Σ x : ℕ , Σ y : ℕ , Σ z : ℕ , x ≡ y * z</code>. An element of
this type is now a quadruple <code>(x , (y , (z , p)))</code> where
<code>x y z : ℕ</code> and <code>p : x ≡ y * z</code>. That is, the
fourth component ensures that <code>x y z : ℕ</code> are allowed in the
tuple if, and only if, <code>x ≡ y * z</code>. We will see more
interesting examples shortly.</p>
<h2 id="definition">Definition</h2>
The <code>Σ</code> type can be defined in Agda using a <code>data</code>
declaration as follows: <!--
<pre class="Agda"><a id="1871" class="Keyword">module</a> <a id="1878" href="sums.html#1878" class="Module">_</a> <a id="1880" class="Keyword">where</a>
 <a id="1887" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="1913" class="Keyword">data</a> <a id="1918" href="sums.html#1918" class="Datatype">Σ</a> <a id="1920" class="Symbol">{</a><a id="1921" href="sums.html#1921" class="Bound">A</a> <a id="1923" class="Symbol">:</a> <a id="1925" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="1930" class="Symbol">}</a> <a id="1932" class="Symbol">(</a><a id="1933" href="sums.html#1933" class="Bound">B</a> <a id="1935" class="Symbol">:</a> <a id="1937" href="sums.html#1921" class="Bound">A</a> <a id="1939" class="Symbol">→</a> <a id="1941" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="1945" class="Symbol">)</a> <a id="1947" class="Symbol">:</a> <a id="1949" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>  <a id="1955" class="Keyword">where</a>
   <a id="1964" href="sums.html#1964" class="InductiveConstructor Operator">_,_</a> <a id="1968" class="Symbol">:</a> <a id="1970" class="Symbol">(</a><a id="1971" href="sums.html#1971" class="Bound">x</a> <a id="1973" class="Symbol">:</a> <a id="1975" href="sums.html#1921" class="Bound">A</a><a id="1976" class="Symbol">)</a> <a id="1978" class="Symbol">(</a><a id="1979" href="sums.html#1979" class="Bound">y</a> <a id="1981" class="Symbol">:</a> <a id="1983" href="sums.html#1933" class="Bound">B</a> <a id="1985" href="sums.html#1971" class="Bound">x</a><a id="1986" class="Symbol">)</a> <a id="1988" class="Symbol">→</a> <a id="1990" href="sums.html#1918" class="Datatype">Σ</a> <a id="1992" class="Symbol">{</a><a id="1993" href="sums.html#1921" class="Bound">A</a><a id="1994" class="Symbol">}</a> <a id="1996" href="sums.html#1933" class="Bound">B</a>

  <a id="2001" href="sums.html#2001" class="Function">fst</a> <a id="2005" class="Symbol">:</a> <a id="2007" class="Symbol">{</a><a id="2008" href="sums.html#2008" class="Bound">A</a> <a id="2010" class="Symbol">:</a> <a id="2012" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2016" class="Symbol">}</a> <a id="2018" class="Symbol">{</a><a id="2019" href="sums.html#2019" class="Bound">B</a> <a id="2021" class="Symbol">:</a> <a id="2023" href="sums.html#2008" class="Bound">A</a> <a id="2025" class="Symbol">→</a> <a id="2027" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2031" class="Symbol">}</a> <a id="2033" class="Symbol">→</a> <a id="2035" href="sums.html#1918" class="Datatype">Σ</a> <a id="2037" href="sums.html#2019" class="Bound">B</a> <a id="2039" class="Symbol">→</a> <a id="2041" href="sums.html#2008" class="Bound">A</a>
  <a id="2045" href="sums.html#2001" class="Function">fst</a> <a id="2049" class="Symbol">(</a><a id="2050" href="sums.html#2050" class="Bound">x</a> <a id="2052" href="sums.html#1964" class="InductiveConstructor Operator">,</a> <a id="2054" href="sums.html#2054" class="Bound">y</a><a id="2055" class="Symbol">)</a> <a id="2057" class="Symbol">=</a> <a id="2059" href="sums.html#2050" class="Bound">x</a>

  <a id="2064" href="sums.html#2064" class="Function">snd</a> <a id="2068" class="Symbol">:</a> <a id="2070" class="Symbol">{</a><a id="2071" href="sums.html#2071" class="Bound">A</a> <a id="2073" class="Symbol">:</a> <a id="2075" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2079" class="Symbol">}</a> <a id="2081" class="Symbol">{</a><a id="2082" href="sums.html#2082" class="Bound">B</a> <a id="2084" class="Symbol">:</a> <a id="2086" href="sums.html#2071" class="Bound">A</a> <a id="2088" class="Symbol">→</a> <a id="2090" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2094" class="Symbol">}</a> <a id="2096" class="Symbol">→</a> <a id="2098" class="Symbol">(</a><a id="2099" href="sums.html#2099" class="Bound">z</a> <a id="2101" class="Symbol">:</a> <a id="2103" href="sums.html#1918" class="Datatype">Σ</a> <a id="2105" href="sums.html#2082" class="Bound">B</a><a id="2106" class="Symbol">)</a> <a id="2108" class="Symbol">→</a> <a id="2110" href="sums.html#2082" class="Bound">B</a> <a id="2112" class="Symbol">(</a><a id="2113" href="sums.html#2001" class="Function">fst</a> <a id="2117" href="sums.html#2099" class="Bound">z</a><a id="2118" class="Symbol">)</a>
  <a id="2122" href="sums.html#2064" class="Function">snd</a> <a id="2126" class="Symbol">(</a><a id="2127" href="sums.html#2127" class="Bound">x</a> <a id="2129" href="sums.html#1964" class="InductiveConstructor Operator">,</a> <a id="2131" href="sums.html#2131" class="Bound">y</a><a id="2132" class="Symbol">)</a> <a id="2134" class="Symbol">=</a> <a id="2136" href="sums.html#2131" class="Bound">y</a>
</pre>
<p>Notice that the type of <code>snd</code> is dependent and uses
<code>fst</code> to express the dependency.</p>
<p>However, for a number of reasons to be explained later, we prefer to
define it using a <a
href="https://agda.readthedocs.io/en/latest/language/record-types.html">record</a>
definition:</p>
<pre class="Agda"><a id="2413" class="Keyword">record</a> <a id="Σ"></a><a id="2420" href="sums.html#2420" data-type="(B : A → Type) → Type" class="Record">Σ</a> <a id="2422" class="Symbol">{</a><a id="2423" href="sums.html#2423" class="Bound">A</a> <a id="2425" class="Symbol">:</a> <a id="2427" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="2432" class="Symbol">}</a> <a id="2434" class="Symbol">(</a><a id="2435" href="sums.html#2435" class="Bound">B</a> <a id="2437" class="Symbol">:</a> <a id="2439" href="sums.html#2423" class="Bound">A</a> <a id="2441" class="Symbol">→</a> <a id="2443" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2447" class="Symbol">)</a> <a id="2449" class="Symbol">:</a> <a id="2451" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>  <a id="2457" class="Keyword">where</a>
 <a id="2464" class="Keyword">constructor</a>
  <a id="_,_"></a><a id="2478" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">_,_</a>
 <a id="2483" class="Keyword">field</a>
  <a id="Σ.fst"></a><a id="2491" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a> <a id="2495" class="Symbol">:</a> <a id="2497" href="sums.html#2423" class="Bound">A</a>
  <a id="Σ.snd"></a><a id="2501" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="2505" class="Symbol">:</a> <a id="2507" href="sums.html#2435" class="Bound">B</a> <a id="2509" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a>
</pre>
<p>Here we automatically get the projections with the same types and
definitions as above and hence we don’t need to provide them. In order
for the projections <code>fst</code> and <code>snd</code> to be visible
outside the scope of the record, we <code>open</code> the record.
Moreover, we open it <code>public</code> so that when other files import
this one, these two projections will be visible in the other files. The
“constructor” allows to form an element of this type. Because “,” is not
a reserved symbol in Agda, we can use it as a binary operator to write
<code>x , y</code>. However, following mathematical tradition, we will
write brackets around that, to get <code>(x , y)</code>, even if this is
not necessary. We also declare a fixity and precedence for this
operator.</p>
<pre class="Agda"><a id="3243" class="Keyword">open</a> <a id="3248" href="sums.html#2420" data-type="(B : A → Type) → Type" class="Module">Σ</a> <a id="3250" class="Keyword">public</a>
<a id="3257" class="Keyword">infixr</a> <a id="3264" class="Number">0</a> <a id="3266" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">_,_</a>
</pre>
<p>Because we make <code>_,_</code> right associative, we can write
<code>(x , y , z , p)</code> rather than
<code>(x , (y , (z , p)))</code> as we did above.</p>
We also use a syntax declaration, <a href="products.html">as we did</a>
for dependent function types using Π, to get the more traditional
type-theoretical notation.
<pre class="Agda"><a id="Sigma"></a><a id="3564" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Sigma</a> <a id="3570" class="Symbol">:</a> <a id="3572" class="Symbol">(</a><a id="3573" href="sums.html#3573" class="Bound">A</a> <a id="3575" class="Symbol">:</a> <a id="3577" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3581" class="Symbol">)</a> <a id="3583" class="Symbol">(</a><a id="3584" href="sums.html#3584" class="Bound">B</a> <a id="3586" class="Symbol">:</a> <a id="3588" href="sums.html#3573" class="Bound">A</a> <a id="3590" class="Symbol">→</a> <a id="3592" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3596" class="Symbol">)</a> <a id="3598" class="Symbol">→</a> <a id="3600" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="3605" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Sigma</a> <a id="3611" href="sums.html#3611" class="Bound">A</a> <a id="3613" href="sums.html#3613" class="Bound">B</a> <a id="3615" class="Symbol">=</a> <a id="3617" href="sums.html#2420" data-type="(B : A → Type) → Type" class="Record">Σ</a> <a id="3619" class="Symbol">{</a><a id="3620" href="sums.html#3611" class="Bound">A</a><a id="3621" class="Symbol">}</a> <a id="3623" href="sums.html#3613" class="Bound">B</a>

<a id="3626" class="Keyword">syntax</a> <a id="3633" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Sigma</a> <a id="3639" class="Bound">A</a> <a id="3641" class="Symbol">(λ</a> <a id="3644" class="Bound">x</a> <a id="3646" class="Symbol">→</a> <a id="3648" class="Bound">b</a><a id="3649" class="Symbol">)</a> <a id="3651" class="Symbol">=</a> <a id="3653" class="Function">Σ</a> <a id="3655" class="Bound">x</a> <a id="3657" class="Function">꞉</a> <a id="3659" class="Bound">A</a> <a id="3661" class="Function">,</a> <a id="3663" class="Bound">b</a>

<a id="3666" class="Keyword">infix</a> <a id="3672" class="Number">-1</a> <a id="3675" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Sigma</a>
</pre>
<h2 id="elimination-principle">Elimination principle</h2>
We now define and discuss the elimination principle.
<pre class="Agda"><a id="Σ-elim"></a><a id="3773" href="sums.html#3773" data-type="((x : A) (y : B x) → C (x , y)) → (z : Sigma A B) → C z" class="Function">Σ-elim</a> <a id="3780" class="Symbol">:</a> <a id="3782" class="Symbol">{</a><a id="3783" href="sums.html#3783" class="Bound">A</a> <a id="3785" class="Symbol">:</a> <a id="3787" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="3792" class="Symbol">}</a> <a id="3794" class="Symbol">{</a><a id="3795" href="sums.html#3795" class="Bound">B</a> <a id="3797" class="Symbol">:</a> <a id="3799" href="sums.html#3783" class="Bound">A</a> <a id="3801" class="Symbol">→</a> <a id="3803" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3807" class="Symbol">}</a> <a id="3809" class="Symbol">{</a><a id="3810" href="sums.html#3810" class="Bound">C</a> <a id="3812" class="Symbol">:</a> <a id="3814" class="Symbol">(</a><a id="3815" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3817" href="sums.html#3817" class="Bound">x</a> <a id="3819" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3821" href="sums.html#3783" class="Bound">A</a> <a id="3823" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3825" href="sums.html#3795" class="Bound">B</a> <a id="3827" href="sums.html#3817" class="Bound">x</a><a id="3828" class="Symbol">)</a> <a id="3830" class="Symbol">→</a> <a id="3832" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3836" class="Symbol">}</a>
       <a id="3845" class="Symbol">→</a> <a id="3847" class="Symbol">((</a><a id="3849" href="sums.html#3849" class="Bound">x</a> <a id="3851" class="Symbol">:</a> <a id="3853" href="sums.html#3783" class="Bound">A</a><a id="3854" class="Symbol">)</a> <a id="3856" class="Symbol">(</a><a id="3857" href="sums.html#3857" class="Bound">y</a> <a id="3859" class="Symbol">:</a> <a id="3861" href="sums.html#3795" class="Bound">B</a> <a id="3863" href="sums.html#3849" class="Bound">x</a><a id="3864" class="Symbol">)</a> <a id="3866" class="Symbol">→</a> <a id="3868" href="sums.html#3810" class="Bound">C</a> <a id="3870" class="Symbol">(</a><a id="3871" href="sums.html#3849" class="Bound">x</a> <a id="3873" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3875" href="sums.html#3857" class="Bound">y</a><a id="3876" class="Symbol">))</a>
       <a id="3886" class="Symbol">→</a> <a id="3888" class="Symbol">(</a><a id="3889" href="sums.html#3889" class="Bound">z</a> <a id="3891" class="Symbol">:</a> <a id="3893" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3895" href="sums.html#3895" class="Bound">x</a> <a id="3897" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3899" href="sums.html#3783" class="Bound">A</a> <a id="3901" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3903" href="sums.html#3795" class="Bound">B</a> <a id="3905" href="sums.html#3895" class="Bound">x</a><a id="3906" class="Symbol">)</a> <a id="3908" class="Symbol">→</a> <a id="3910" href="sums.html#3810" class="Bound">C</a> <a id="3912" href="sums.html#3889" class="Bound">z</a>
<a id="3914" href="sums.html#3773" data-type="((x : A) (y : B x) → C (x , y)) → (z : Sigma A B) → C z" class="Function">Σ-elim</a> <a id="3921" href="sums.html#3921" class="Bound">f</a> <a id="3923" class="Symbol">(</a><a id="3924" href="sums.html#3924" class="Bound">x</a> <a id="3926" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3928" href="sums.html#3928" class="Bound">y</a><a id="3929" class="Symbol">)</a> <a id="3931" class="Symbol">=</a> <a id="3933" href="sums.html#3921" class="Bound">f</a> <a id="3935" href="sums.html#3924" class="Bound">x</a> <a id="3937" href="sums.html#3928" class="Bound">y</a>
</pre>
So the elimination principle for <code>Σ</code> is what was called
<code>curry</code> in functional programming. The logical interpretation
for this principle is that in order to show that “for all z : Σ x ꞉ A ,
B x) we have that C z holds”, it is enough to show that “for all x : A
and y : B x we have that C (x , y) holds”. This condition is not only
sufficient but also <a
href="https://en.wikipedia.org/wiki/Necessity_and_sufficiency">necessary</a>:
<pre class="Agda"><a id="Σ-uncurry"></a><a id="4372" href="sums.html#4372" data-type="((z : Sigma A B) → C z) → (x : A) (y : B x) → C (x , y)" class="Function">Σ-uncurry</a> <a id="4382" class="Symbol">:</a> <a id="4384" class="Symbol">{</a><a id="4385" href="sums.html#4385" class="Bound">A</a> <a id="4387" class="Symbol">:</a> <a id="4389" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="4394" class="Symbol">}</a> <a id="4396" class="Symbol">{</a><a id="4397" href="sums.html#4397" class="Bound">B</a> <a id="4399" class="Symbol">:</a> <a id="4401" href="sums.html#4385" class="Bound">A</a> <a id="4403" class="Symbol">→</a> <a id="4405" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="4409" class="Symbol">}</a> <a id="4411" class="Symbol">{</a><a id="4412" href="sums.html#4412" class="Bound">C</a> <a id="4414" class="Symbol">:</a> <a id="4416" class="Symbol">(</a><a id="4417" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4419" href="sums.html#4419" class="Bound">x</a> <a id="4421" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4423" href="sums.html#4385" class="Bound">A</a> <a id="4425" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4427" href="sums.html#4397" class="Bound">B</a> <a id="4429" href="sums.html#4419" class="Bound">x</a><a id="4430" class="Symbol">)</a> <a id="4432" class="Symbol">→</a> <a id="4434" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="4438" class="Symbol">}</a>
          <a id="4450" class="Symbol">→</a> <a id="4452" class="Symbol">((</a><a id="4454" href="sums.html#4454" class="Bound">z</a> <a id="4456" class="Symbol">:</a> <a id="4458" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4460" href="sums.html#4460" class="Bound">x</a> <a id="4462" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4464" href="sums.html#4385" class="Bound">A</a> <a id="4466" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4468" href="sums.html#4397" class="Bound">B</a> <a id="4470" href="sums.html#4460" class="Bound">x</a><a id="4471" class="Symbol">)</a> <a id="4473" class="Symbol">→</a> <a id="4475" href="sums.html#4412" class="Bound">C</a> <a id="4477" href="sums.html#4454" class="Bound">z</a><a id="4478" class="Symbol">)</a>
          <a id="4490" class="Symbol">→</a> <a id="4492" class="Symbol">(</a><a id="4493" href="sums.html#4493" class="Bound">x</a> <a id="4495" class="Symbol">:</a> <a id="4497" href="sums.html#4385" class="Bound">A</a><a id="4498" class="Symbol">)</a> <a id="4500" class="Symbol">(</a><a id="4501" href="sums.html#4501" class="Bound">y</a> <a id="4503" class="Symbol">:</a> <a id="4505" href="sums.html#4397" class="Bound">B</a> <a id="4507" href="sums.html#4493" class="Bound">x</a><a id="4508" class="Symbol">)</a> <a id="4510" class="Symbol">→</a> <a id="4512" href="sums.html#4412" class="Bound">C</a> <a id="4514" class="Symbol">(</a><a id="4515" href="sums.html#4493" class="Bound">x</a> <a id="4517" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4519" href="sums.html#4501" class="Bound">y</a><a id="4520" class="Symbol">)</a>
<a id="4522" href="sums.html#4372" data-type="((z : Sigma A B) → C z) → (x : A) (y : B x) → C (x , y)" class="Function">Σ-uncurry</a> <a id="4532" href="sums.html#4532" class="Bound">g</a> <a id="4534" href="sums.html#4534" class="Bound">x</a> <a id="4536" href="sums.html#4536" class="Bound">y</a> <a id="4538" class="Symbol">=</a> <a id="4540" href="sums.html#4532" class="Bound">g</a> <a id="4542" class="Symbol">(</a><a id="4543" href="sums.html#4534" class="Bound">x</a> <a id="4545" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4547" href="sums.html#4536" class="Bound">y</a><a id="4548" class="Symbol">)</a>
</pre>
<h2 id="existential-quantification">Existential quantification</h2>
<p>Regarding logic, the <code>Σ</code> type is used to interpret the
existential quantifier <code>∃</code>. The logical proposition
<code>∃ x : X, A x</code>, that is, “there exists x : X such that A x”,
is interpreted as the type <code>Σ x ꞉ X , A x</code>. The reason is
that to show that <code>∃ x : X, A x</code> we have to exhibit an
example <code>x : X</code> and show that <code>x</code> satisfies the
condition <code>A x</code> with some <code>y : A x</code>, in a pair
<code>(x , y)</code>.</p>
<p>For example, the type
<code>Σ x : ℕ , Σ y : ℕ , Σ z : ℕ , x ≡ y * z</code> can be interpreted
as saying that “there are natural numbers x, y, and z such that x = y *
z”, which is true as witnessed by the element
<code>(6,2,3,refl 6)</code> of that type. But there are many other
witnesses of this type, of course, such as
<code>(10,5,2,refl 10)</code>.</p>
<p>It is important to notice that it is possible to write types that
correspond to false logical statements, and hence are empty. For
example, consider <code>Σ x : ℕ , x ≡ x + 1</code>. There is no natural
number that is its own successor, of course, and so this type is empty.
While this type is empty, the type <code>¬ (Σ x : ℕ , x ≡ x + 1)</code>
has an element, as we will see, which witnesses the fact that “there
doesn’t exist a natural number <code>x</code> such that
<code>x = x + 1</code>”.</p>
<h2 id="existential-quantification-in-hottuf">Existential quantification
in HoTT/UF</h2>
<p>In HoTT/UF it useful to have an alternative existential quantifier
<code>∃ x : X , A x</code> defined to be <code>∥ Σ x : X , A x ∥</code>
where <code>∥_∥</code> is a certain <em>propositional truncation</em>
operation.</p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
