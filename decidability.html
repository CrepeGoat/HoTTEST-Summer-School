<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<a id=moddecidability></a>
<h2
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h2>
<p>When programming in conventional programming languages such as
Haskell, C, Java, Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h3 id="discussion-and-motivation">Discussion and motivation</h3>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h3 id="decidable-propositions">Decidable propositions</h3>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2606" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2619" class="Symbol">:</a> <a id="2621" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="2626" class="Symbol">→</a> <a id="2628" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="2633" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2646" href="decidability.html#2646" class="Bound">A</a> <a id="2648" class="Symbol">=</a> <a id="2650" href="decidability.html#2646" class="Bound">A</a> <a id="2652" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2654" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="2656" href="decidability.html#2646" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="2881" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2889" class="Symbol">:</a> <a id="2891" class="Symbol">{</a><a id="2892" href="decidability.html#2892" class="Bound">A</a> <a id="2894" class="Symbol">:</a> <a id="2896" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2900" class="Symbol">}</a> <a id="2902" class="Symbol">→</a> <a id="2904" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2917" href="decidability.html#2892" class="Bound">A</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2924" href="decidability.html#2892" class="Bound">A</a> <a id="2926" class="Symbol">→</a> <a id="2928" href="decidability.html#2892" class="Bound">A</a>
<a id="2930" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2938" class="Symbol">(</a><a id="2939" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2943" href="decidability.html#2943" class="Bound">x</a><a id="2944" class="Symbol">)</a> <a id="2946" href="decidability.html#2946" class="Bound">f</a> <a id="2948" class="Symbol">=</a> <a id="2950" href="decidability.html#2943" class="Bound">x</a>
<a id="2952" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2960" class="Symbol">(</a><a id="2961" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2965" href="decidability.html#2965" class="Bound">g</a><a id="2966" class="Symbol">)</a> <a id="2968" href="decidability.html#2968" class="Bound">f</a> <a id="2970" class="Symbol">=</a> <a id="2972" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="2979" class="Symbol">(</a><a id="2980" href="decidability.html#2968" class="Bound">f</a> <a id="2982" href="decidability.html#2965" class="Bound">g</a><a id="2983" class="Symbol">)</a>
</pre>
<h3 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h3>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3411" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3438" class="Symbol">:</a> <a id="3440" class="Symbol">(</a><a id="3441" href="decidability.html#3441" class="Bound">A</a> <a id="3443" class="Symbol">:</a> <a id="3445" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3449" class="Symbol">)</a> <a id="3451" class="Symbol">→</a> <a id="3453" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3466" href="decidability.html#3441" class="Bound">A</a> <a id="3468" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3470" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3472" href="decidability.html#3472" class="Bound">b</a> <a id="3474" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3476" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3481" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3483" class="Symbol">(</a><a id="3484" href="decidability.html#3441" class="Bound">A</a> <a id="3486" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3488" href="decidability.html#3472" class="Bound">b</a> <a id="3490" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3492" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3496" class="Symbol">)</a>
<a id="3498" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3525" href="decidability.html#3525" class="Bound">A</a> <a id="3527" class="Symbol">=</a> <a id="3529" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3531" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3533" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3536" class="Keyword">where</a>
  <a id="3544" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3546" class="Symbol">:</a> <a id="3548" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3561" href="decidability.html#3525" class="Bound">A</a> <a id="3563" class="Symbol">→</a> <a id="3565" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3567" href="decidability.html#3567" class="Bound">b</a> <a id="3569" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3571" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3576" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3578" class="Symbol">(</a><a id="3579" href="decidability.html#3525" class="Bound">A</a> <a id="3581" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3583" href="decidability.html#3567" class="Bound">b</a> <a id="3585" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3587" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3591" class="Symbol">)</a>
  <a id="3595" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3597" class="Symbol">(</a><a id="3598" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3602" href="decidability.html#3602" class="Bound">x</a><a id="3603" class="Symbol">)</a> <a id="3605" class="Symbol">=</a> <a id="3607" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3612" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3614" class="Symbol">(</a><a id="3615" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3617" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3619" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="3620" class="Symbol">)</a>
   <a id="3625" class="Keyword">where</a>
    <a id="3635" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="decidability.html#3525" class="Bound">A</a> <a id="3641" class="Symbol">→</a> <a id="3643" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3648" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3650" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3659" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3661" class="Symbol">_</a> <a id="3663" class="Symbol">=</a> <a id="3665" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3670" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="3680" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3682" class="Symbol">:</a> <a id="3684" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3689" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3691" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3696" class="Symbol">→</a> <a id="3698" href="decidability.html#3525" class="Bound">A</a>
    <a id="3704" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3706" class="Symbol">_</a> <a id="3708" class="Symbol">=</a> <a id="3710" href="decidability.html#3602" class="Bound">x</a>

  <a id="3715" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3717" class="Symbol">(</a><a id="3718" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3722" href="decidability.html#3722" class="Bound">ν</a><a id="3723" class="Symbol">)</a> <a id="3725" class="Symbol">=</a> <a id="3727" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3733" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3735" class="Symbol">(</a><a id="3736" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3738" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3740" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="3741" class="Symbol">)</a>
   <a id="3746" class="Keyword">where</a>
    <a id="3756" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="decidability.html#3525" class="Bound">A</a> <a id="3762" class="Symbol">→</a> <a id="3764" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3770" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3772" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3781" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3783" href="decidability.html#3783" class="Bound">x</a> <a id="3785" class="Symbol">=</a> <a id="3787" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3794" class="Symbol">(</a><a id="3795" href="decidability.html#3722" class="Bound">ν</a> <a id="3797" href="decidability.html#3783" class="Bound">x</a><a id="3798" class="Symbol">)</a>

    <a id="3805" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3807" class="Symbol">:</a> <a id="3809" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3815" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3817" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3822" class="Symbol">→</a> <a id="3824" href="decidability.html#3525" class="Bound">A</a>
    <a id="3830" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3832" class="Symbol">()</a>

  <a id="3838" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3840" class="Symbol">:</a> <a id="3842" class="Symbol">(</a><a id="3843" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3845" href="decidability.html#3845" class="Bound">b</a> <a id="3847" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3849" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3854" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3856" class="Symbol">(</a><a id="3857" href="decidability.html#3525" class="Bound">A</a> <a id="3859" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3861" href="decidability.html#3845" class="Bound">b</a> <a id="3863" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3865" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3869" class="Symbol">))</a> <a id="3872" class="Symbol">→</a> <a id="3874" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3887" href="decidability.html#3525" class="Bound">A</a>
  <a id="3891" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3893" class="Symbol">(</a><a id="3894" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3899" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="3902" href="decidability.html#3902" class="Bound">α</a> <a id="3904" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3906" href="decidability.html#3906" class="Bound">β</a><a id="3907" class="Symbol">)</a> <a id="3909" class="Symbol">=</a> <a id="3911" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3915" class="Symbol">(</a><a id="3916" href="decidability.html#3906" class="Bound">β</a> <a id="3918" class="Symbol">(</a><a id="3919" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3924" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3928" class="Symbol">))</a>
  <a id="3933" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3935" class="Symbol">(</a><a id="3936" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3942" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3944" href="decidability.html#3944" class="Bound">α</a> <a id="3946" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3948" href="decidability.html#3948" class="Bound">β</a><a id="3949" class="Symbol">)</a> <a id="3951" class="Symbol">=</a> <a id="3953" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3957" class="Symbol">(λ</a> <a id="3960" href="decidability.html#3960" class="Bound">x</a> <a id="3962" class="Symbol">→</a> <a id="3964" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3982" class="Symbol">(</a><a id="3983" href="decidability.html#3944" class="Bound">α</a> <a id="3985" href="decidability.html#3960" class="Bound">x</a><a id="3986" class="Symbol">))</a>
</pre>
<h3 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h3>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is odd. <!--
<pre class="Agda"><a id="4509" class="Keyword">module</a> <a id="4516" href="decidability.html#4516" class="Module">_</a> <a id="4518" class="Keyword">where</a>
 <a id="4525" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4551" href="decidability.html#4551" class="Function">is-even</a> <a id="4559" class="Symbol">:</a> <a id="4561" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4563" class="Symbol">→</a> <a id="4565" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
  <a id="4572" href="decidability.html#4551" class="Function">is-even</a> <a id="4580" href="decidability.html#4580" class="Bound">x</a> <a id="4582" class="Symbol">=</a> <a id="4584" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4586" href="decidability.html#4586" class="Bound">y</a> <a id="4588" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4590" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4592" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4594" href="decidability.html#4580" class="Bound">x</a> <a id="4596" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4598" class="Number">2</a> <a id="4600" href="natural-numbers-type.html#2889" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4602" href="decidability.html#4586" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="4804" href="decidability.html#4804" class="Function">check-even</a> <a id="4815" class="Symbol">:</a> <a id="4817" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4819" class="Symbol">→</a> <a id="4821" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
  <a id="4828" href="decidability.html#4804" class="Function">check-even</a> <a id="4839" class="Number">0</a>       <a id="4847" class="Symbol">=</a> <a id="4849" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4856" href="decidability.html#4804" class="Function">check-even</a> <a id="4867" class="Symbol">(</a><a id="4868" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="4872" href="decidability.html#4872" class="Bound">x</a><a id="4873" class="Symbol">)</a> <a id="4875" class="Symbol">=</a> <a id="4877" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4881" class="Symbol">(</a><a id="4882" href="decidability.html#4804" class="Function">check-even</a> <a id="4893" href="decidability.html#4872" class="Bound">x</a><a id="4894" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5304" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5327" class="Symbol">:</a> <a id="5329" class="Symbol">{</a><a id="5330" href="decidability.html#5330" class="Bound">X</a> <a id="5332" class="Symbol">:</a> <a id="5334" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5338" class="Symbol">}</a> <a id="5340" class="Symbol">→</a> <a id="5342" class="Symbol">(</a><a id="5343" href="decidability.html#5330" class="Bound">X</a> <a id="5345" class="Symbol">→</a> <a id="5347" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5351" class="Symbol">)</a> <a id="5353" class="Symbol">→</a> <a id="5355" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="5360" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5383" class="Symbol">{</a><a id="5384" href="decidability.html#5384" class="Bound">X</a><a id="5385" class="Symbol">}</a> <a id="5387" href="decidability.html#5387" class="Bound">A</a> <a id="5389" class="Symbol">=</a> <a id="5391" class="Symbol">(</a><a id="5392" href="decidability.html#5392" class="Bound">x</a> <a id="5394" class="Symbol">:</a> <a id="5396" href="decidability.html#5384" class="Bound">X</a><a id="5397" class="Symbol">)</a> <a id="5399" class="Symbol">→</a> <a id="5401" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="5414" class="Symbol">(</a><a id="5415" href="decidability.html#5387" class="Bound">A</a> <a id="5417" href="decidability.html#5392" class="Bound">x</a><a id="5418" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="5942" href="decidability.html#5942" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="5979" class="Symbol">:</a> <a id="5981" class="Symbol">{</a><a id="5982" href="decidability.html#5982" class="Bound">X</a> <a id="5984" class="Symbol">:</a> <a id="5986" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5990" class="Symbol">}</a> <a id="5992" class="Symbol">(</a><a id="5993" href="decidability.html#5993" class="Bound">A</a> <a id="5995" class="Symbol">:</a> <a id="5997" href="decidability.html#5982" class="Bound">X</a> <a id="5999" class="Symbol">→</a> <a id="6001" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="6005" class="Symbol">)</a>
                                     <a id="6044" class="Symbol">→</a> <a id="6046" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6069" href="decidability.html#5993" class="Bound">A</a>
                                     <a id="6108" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6110" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6112" href="decidability.html#6112" class="Bound">α</a> <a id="6114" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6116" class="Symbol">(</a><a id="6117" href="decidability.html#5982" class="Bound">X</a> <a id="6119" class="Symbol">→</a> <a id="6121" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6125" class="Symbol">)</a> <a id="6127" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6129" class="Symbol">((</a><a id="6131" href="decidability.html#6131" class="Bound">x</a> <a id="6133" class="Symbol">:</a> <a id="6135" href="decidability.html#5982" class="Bound">X</a><a id="6136" class="Symbol">)</a> <a id="6138" class="Symbol">→</a> <a id="6140" href="decidability.html#5993" class="Bound">A</a> <a id="6142" href="decidability.html#6131" class="Bound">x</a> <a id="6144" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6146" href="decidability.html#6112" class="Bound">α</a> <a id="6148" href="decidability.html#6131" class="Bound">x</a> <a id="6150" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6152" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6156" class="Symbol">)</a>
<a id="6158" href="decidability.html#5942" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6195" class="Symbol">{</a><a id="6196" href="decidability.html#6196" class="Bound">X</a><a id="6197" class="Symbol">}</a> <a id="6199" href="decidability.html#6199" class="Bound">A</a> <a id="6201" class="Symbol">=</a> <a id="6203" href="decidability.html#6218" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6205" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6207" href="decidability.html#6863" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6210" class="Keyword">where</a>
  <a id="6218" href="decidability.html#6218" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6220" class="Symbol">:</a> <a id="6222" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6245" href="decidability.html#6199" class="Bound">A</a> <a id="6247" class="Symbol">→</a> <a id="6249" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6251" href="decidability.html#6251" class="Bound">α</a> <a id="6253" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6255" class="Symbol">(</a><a id="6256" href="decidability.html#6196" class="Bound">X</a> <a id="6258" class="Symbol">→</a> <a id="6260" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6264" class="Symbol">)</a> <a id="6266" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6268" class="Symbol">((</a><a id="6270" href="decidability.html#6270" class="Bound">x</a> <a id="6272" class="Symbol">:</a> <a id="6274" href="decidability.html#6196" class="Bound">X</a><a id="6275" class="Symbol">)</a> <a id="6277" class="Symbol">→</a> <a id="6279" href="decidability.html#6199" class="Bound">A</a> <a id="6281" href="decidability.html#6270" class="Bound">x</a> <a id="6283" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6285" href="decidability.html#6251" class="Bound">α</a> <a id="6287" href="decidability.html#6270" class="Bound">x</a> <a id="6289" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6291" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6295" class="Symbol">)</a>
  <a id="6299" href="decidability.html#6218" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6301" href="decidability.html#6301" class="Bound">d</a> <a id="6303" class="Symbol">=</a> <a id="6305" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6307" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6309" href="decidability.html#6496" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6314" class="Keyword">where</a>
    <a id="6324" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6326" class="Symbol">:</a> <a id="6328" href="decidability.html#6196" class="Bound">X</a> <a id="6330" class="Symbol">→</a> <a id="6332" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
    <a id="6341" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6343" href="decidability.html#6343" class="Bound">x</a> <a id="6345" class="Symbol">=</a> <a id="6347" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a> <a id="6351" class="Symbol">(</a><a id="6352" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6367" href="decidability.html#6393" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6369" class="Symbol">(</a><a id="6370" href="decidability.html#6301" class="Bound">d</a> <a id="6372" href="decidability.html#6343" class="Bound">x</a><a id="6373" class="Symbol">))</a>
     <a id="6381" class="Keyword">where</a>
      <a id="6393" href="decidability.html#6393" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6395" class="Symbol">:</a> <a id="6397" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="6410" class="Symbol">(</a><a id="6411" href="decidability.html#6199" class="Bound">A</a> <a id="6413" href="decidability.html#6343" class="Bound">x</a><a id="6414" class="Symbol">)</a> <a id="6416" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6418" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6420" href="decidability.html#6420" class="Bound">b</a> <a id="6422" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6424" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6429" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6431" class="Symbol">(</a><a id="6432" href="decidability.html#6199" class="Bound">A</a> <a id="6434" href="decidability.html#6343" class="Bound">x</a> <a id="6436" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6438" href="decidability.html#6420" class="Bound">b</a> <a id="6440" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6442" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6446" class="Symbol">)</a>
      <a id="6454" href="decidability.html#6393" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6456" class="Symbol">=</a> <a id="6458" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6485" class="Symbol">(</a><a id="6486" href="decidability.html#6199" class="Bound">A</a> <a id="6488" href="decidability.html#6343" class="Bound">x</a><a id="6489" class="Symbol">)</a>

    <a id="6496" href="decidability.html#6496" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6498" class="Symbol">:</a> <a id="6500" class="Symbol">(</a><a id="6501" href="decidability.html#6501" class="Bound">x</a> <a id="6503" class="Symbol">:</a> <a id="6505" href="decidability.html#6196" class="Bound">X</a><a id="6506" class="Symbol">)</a> <a id="6508" class="Symbol">→</a> <a id="6510" href="decidability.html#6199" class="Bound">A</a> <a id="6512" href="decidability.html#6501" class="Bound">x</a> <a id="6514" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6516" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6518" href="decidability.html#6501" class="Bound">x</a> <a id="6520" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6522" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6531" href="decidability.html#6496" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6533" href="decidability.html#6533" class="Bound">x</a> <a id="6535" class="Symbol">=</a> <a id="6537" href="decidability.html#6743" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6539" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6541" href="decidability.html#6805" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6548" class="Keyword">where</a>
      <a id="6560" href="decidability.html#6560" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6562" class="Symbol">:</a> <a id="6564" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="6577" class="Symbol">(</a><a id="6578" href="decidability.html#6199" class="Bound">A</a> <a id="6580" href="decidability.html#6533" class="Bound">x</a><a id="6581" class="Symbol">)</a> <a id="6583" class="Symbol">→</a> <a id="6585" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6587" href="decidability.html#6587" class="Bound">b</a> <a id="6589" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6591" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6596" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6598" class="Symbol">(</a><a id="6599" href="decidability.html#6199" class="Bound">A</a> <a id="6601" href="decidability.html#6533" class="Bound">x</a> <a id="6603" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6605" href="decidability.html#6587" class="Bound">b</a> <a id="6607" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6609" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6613" class="Symbol">)</a>
      <a id="6621" href="decidability.html#6560" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6623" class="Symbol">=</a> <a id="6625" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6640" class="Symbol">(</a><a id="6641" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6668" class="Symbol">(</a><a id="6669" href="decidability.html#6199" class="Bound">A</a> <a id="6671" href="decidability.html#6533" class="Bound">x</a><a id="6672" class="Symbol">))</a>

      <a id="6682" href="decidability.html#6682" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6685" class="Symbol">:</a> <a id="6687" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6689" href="decidability.html#6689" class="Bound">b</a> <a id="6691" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6693" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6698" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6700" class="Symbol">(</a><a id="6701" href="decidability.html#6199" class="Bound">A</a> <a id="6703" href="decidability.html#6533" class="Bound">x</a> <a id="6705" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6707" href="decidability.html#6689" class="Bound">b</a> <a id="6709" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6711" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6715" class="Symbol">)</a>
      <a id="6723" href="decidability.html#6682" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6726" class="Symbol">=</a> <a id="6728" href="decidability.html#6560" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6730" class="Symbol">(</a><a id="6731" href="decidability.html#6301" class="Bound">d</a> <a id="6733" href="decidability.html#6533" class="Bound">x</a><a id="6734" class="Symbol">)</a>

      <a id="6743" href="decidability.html#6743" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6745" class="Symbol">:</a> <a id="6747" href="decidability.html#6199" class="Bound">A</a> <a id="6749" href="decidability.html#6533" class="Bound">x</a> <a id="6751" class="Symbol">→</a> <a id="6753" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6755" href="decidability.html#6533" class="Bound">x</a> <a id="6757" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6759" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="6770" href="decidability.html#6743" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6772" class="Symbol">=</a> <a id="6774" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6789" class="Symbol">(</a><a id="6790" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6794" href="decidability.html#6682" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6796" class="Symbol">)</a>

      <a id="6805" href="decidability.html#6805" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6807" class="Symbol">:</a> <a id="6809" href="decidability.html#6324" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6811" href="decidability.html#6533" class="Bound">x</a> <a id="6813" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6815" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="6820" class="Symbol">→</a> <a id="6822" href="decidability.html#6199" class="Bound">A</a> <a id="6824" href="decidability.html#6533" class="Bound">x</a>
      <a id="6832" href="decidability.html#6805" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6834" class="Symbol">=</a> <a id="6836" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="6851" class="Symbol">(</a><a id="6852" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6856" href="decidability.html#6682" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6858" class="Symbol">)</a>

  <a id="6863" href="decidability.html#6863" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6865" class="Symbol">:</a> <a id="6867" class="Symbol">(</a><a id="6868" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6870" href="decidability.html#6870" class="Bound">α</a> <a id="6872" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6874" class="Symbol">(</a><a id="6875" href="decidability.html#6196" class="Bound">X</a> <a id="6877" class="Symbol">→</a> <a id="6879" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6883" class="Symbol">)</a> <a id="6885" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6887" class="Symbol">((</a><a id="6889" href="decidability.html#6889" class="Bound">x</a> <a id="6891" class="Symbol">:</a> <a id="6893" href="decidability.html#6196" class="Bound">X</a><a id="6894" class="Symbol">)</a> <a id="6896" class="Symbol">→</a> <a id="6898" href="decidability.html#6199" class="Bound">A</a> <a id="6900" href="decidability.html#6889" class="Bound">x</a> <a id="6902" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6904" href="decidability.html#6870" class="Bound">α</a> <a id="6906" href="decidability.html#6889" class="Bound">x</a> <a id="6908" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6910" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6914" class="Symbol">))</a> <a id="6917" class="Symbol">→</a> <a id="6919" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6942" href="decidability.html#6199" class="Bound">A</a>
  <a id="6946" href="decidability.html#6863" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6948" class="Symbol">(</a><a id="6949" href="decidability.html#6949" class="Bound">α</a> <a id="6951" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6953" href="decidability.html#6953" class="Bound">ϕ</a><a id="6954" class="Symbol">)</a> <a id="6956" class="Symbol">=</a> <a id="6958" href="decidability.html#6973" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="6963" class="Keyword">where</a>
    <a id="6973" href="decidability.html#6973" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="6975" class="Symbol">:</a> <a id="6977" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7000" href="decidability.html#6199" class="Bound">A</a>
    <a id="7006" href="decidability.html#6973" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7008" href="decidability.html#7008" class="Bound">x</a> <a id="7010" class="Symbol">=</a> <a id="7012" href="decidability.html#7222" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7021" class="Keyword">where</a>
      <a id="7033" href="decidability.html#7033" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7035" class="Symbol">:</a> <a id="7037" class="Symbol">(</a><a id="7038" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7040" href="decidability.html#7040" class="Bound">b</a> <a id="7042" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7044" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7049" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7051" class="Symbol">(</a><a id="7052" href="decidability.html#6199" class="Bound">A</a> <a id="7054" href="decidability.html#7008" class="Bound">x</a> <a id="7056" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7058" href="decidability.html#7040" class="Bound">b</a> <a id="7060" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7062" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7066" class="Symbol">))</a> <a id="7069" class="Symbol">→</a> <a id="7071" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7084" class="Symbol">(</a><a id="7085" href="decidability.html#6199" class="Bound">A</a> <a id="7087" href="decidability.html#7008" class="Bound">x</a><a id="7088" class="Symbol">)</a>
      <a id="7096" href="decidability.html#7033" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7098" class="Symbol">=</a> <a id="7100" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7115" class="Symbol">(</a><a id="7116" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7143" class="Symbol">(</a><a id="7144" href="decidability.html#6199" class="Bound">A</a> <a id="7146" href="decidability.html#7008" class="Bound">x</a><a id="7147" class="Symbol">))</a>

      <a id="7157" href="decidability.html#7157" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7160" class="Symbol">:</a> <a id="7162" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7164" href="decidability.html#7164" class="Bound">b</a> <a id="7166" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7168" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7173" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7175" class="Symbol">(</a><a id="7176" href="decidability.html#6199" class="Bound">A</a> <a id="7178" href="decidability.html#7008" class="Bound">x</a> <a id="7180" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7182" href="decidability.html#7164" class="Bound">b</a> <a id="7184" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7186" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7190" class="Symbol">)</a>
      <a id="7198" href="decidability.html#7157" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7201" class="Symbol">=</a> <a id="7203" class="Symbol">(</a><a id="7204" href="decidability.html#6949" class="Bound">α</a> <a id="7206" href="decidability.html#7008" class="Bound">x</a> <a id="7208" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7210" href="decidability.html#6953" class="Bound">ϕ</a> <a id="7212" href="decidability.html#7008" class="Bound">x</a><a id="7213" class="Symbol">)</a>

      <a id="7222" href="decidability.html#7222" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7226" class="Symbol">:</a> <a id="7228" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7241" class="Symbol">(</a><a id="7242" href="decidability.html#6199" class="Bound">A</a> <a id="7244" href="decidability.html#7008" class="Bound">x</a><a id="7245" class="Symbol">)</a>
      <a id="7253" href="decidability.html#7222" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7257" class="Symbol">=</a> <a id="7259" href="decidability.html#7033" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7261" href="decidability.html#7157" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h3 id="preservation-of-decidability">Preservation of decidability</h3>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="7802" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7816" class="Symbol">:</a> <a id="7818" class="Symbol">{</a><a id="7819" href="decidability.html#7819" class="Bound">A</a> <a id="7821" href="decidability.html#7821" class="Bound">B</a> <a id="7823" class="Symbol">:</a> <a id="7825" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7829" class="Symbol">}</a> <a id="7831" class="Symbol">→</a> <a id="7833" class="Symbol">(</a><a id="7834" href="decidability.html#7819" class="Bound">A</a> <a id="7836" class="Symbol">→</a> <a id="7838" href="decidability.html#7821" class="Bound">B</a><a id="7839" class="Symbol">)</a> <a id="7841" class="Symbol">→</a> <a id="7843" class="Symbol">(</a><a id="7844" href="decidability.html#7821" class="Bound">B</a> <a id="7846" class="Symbol">→</a> <a id="7848" href="decidability.html#7819" class="Bound">A</a><a id="7849" class="Symbol">)</a> <a id="7851" class="Symbol">→</a> <a id="7853" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7866" href="decidability.html#7819" class="Bound">A</a> <a id="7868" class="Symbol">→</a> <a id="7870" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7883" href="decidability.html#7821" class="Bound">B</a>
<a id="7885" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7899" href="decidability.html#7899" class="Bound">f</a> <a id="7901" href="decidability.html#7901" class="Bound">g</a> <a id="7903" class="Symbol">(</a><a id="7904" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7908" href="decidability.html#7908" class="Bound">x</a><a id="7909" class="Symbol">)</a> <a id="7911" class="Symbol">=</a> <a id="7913" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7917" class="Symbol">(</a><a id="7918" href="decidability.html#7899" class="Bound">f</a> <a id="7920" href="decidability.html#7908" class="Bound">x</a><a id="7921" class="Symbol">)</a>
<a id="7923" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7937" href="decidability.html#7937" class="Bound">f</a> <a id="7939" href="decidability.html#7939" class="Bound">g</a> <a id="7941" class="Symbol">(</a><a id="7942" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7946" href="decidability.html#7946" class="Bound">h</a><a id="7947" class="Symbol">)</a> <a id="7949" class="Symbol">=</a> <a id="7951" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7955" class="Symbol">(λ</a> <a id="7958" href="decidability.html#7958" class="Bound">y</a> <a id="7960" class="Symbol">→</a> <a id="7962" href="decidability.html#7946" class="Bound">h</a> <a id="7964" class="Symbol">(</a><a id="7965" href="decidability.html#7939" class="Bound">g</a> <a id="7967" href="decidability.html#7958" class="Bound">y</a><a id="7968" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="7972" href="decidability.html#7972" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="7996" class="Symbol">:</a> <a id="7998" class="Symbol">{</a><a id="7999" href="decidability.html#7999" class="Bound">A</a> <a id="8001" href="decidability.html#8001" class="Bound">B</a> <a id="8003" class="Symbol">:</a> <a id="8005" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8009" class="Symbol">}</a> <a id="8011" class="Symbol">→</a> <a id="8013" class="Symbol">(</a><a id="8014" href="decidability.html#7999" class="Bound">A</a> <a id="8016" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8018" href="decidability.html#8001" class="Bound">B</a><a id="8019" class="Symbol">)</a> <a id="8021" class="Symbol">→</a> <a id="8023" class="Symbol">(</a><a id="8024" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8037" href="decidability.html#7999" class="Bound">A</a> <a id="8039" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8041" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8054" href="decidability.html#8001" class="Bound">B</a><a id="8055" class="Symbol">)</a>
<a id="8057" href="decidability.html#7972" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8081" class="Symbol">(</a><a id="8082" href="decidability.html#8082" class="Bound">f</a> <a id="8084" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8086" href="decidability.html#8086" class="Bound">g</a><a id="8087" class="Symbol">)</a> <a id="8089" class="Symbol">=</a> <a id="8091" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8105" href="decidability.html#8082" class="Bound">f</a> <a id="8107" href="decidability.html#8086" class="Bound">g</a> <a id="8109" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8111" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8125" href="decidability.html#8086" class="Bound">g</a> <a id="8127" href="decidability.html#8082" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8152" href="decidability.html#8152" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8167" class="Symbol">:</a> <a id="8169" class="Symbol">{</a><a id="8170" href="decidability.html#8170" class="Bound">A</a> <a id="8172" href="decidability.html#8172" class="Bound">B</a> <a id="8174" class="Symbol">:</a> <a id="8176" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8180" class="Symbol">}</a> <a id="8182" class="Symbol">→</a> <a id="8184" class="Symbol">(</a><a id="8185" href="decidability.html#8170" class="Bound">A</a> <a id="8187" class="Symbol">→</a> <a id="8189" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8191" href="decidability.html#8172" class="Bound">B</a><a id="8192" class="Symbol">)</a> <a id="8194" class="Symbol">→</a> <a id="8196" class="Symbol">(</a><a id="8197" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8199" href="decidability.html#8170" class="Bound">A</a> <a id="8201" class="Symbol">→</a> <a id="8203" href="decidability.html#8172" class="Bound">B</a><a id="8204" class="Symbol">)</a> <a id="8206" class="Symbol">→</a> <a id="8208" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8221" href="decidability.html#8170" class="Bound">A</a> <a id="8223" class="Symbol">→</a> <a id="8225" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8238" href="decidability.html#8172" class="Bound">B</a>
<a id="8240" href="decidability.html#8152" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8255" href="decidability.html#8255" class="Bound">f</a> <a id="8257" href="decidability.html#8257" class="Bound">g</a> <a id="8259" class="Symbol">(</a><a id="8260" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8264" href="decidability.html#8264" class="Bound">x</a><a id="8265" class="Symbol">)</a> <a id="8267" class="Symbol">=</a> <a id="8269" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8273" class="Symbol">(</a><a id="8274" href="decidability.html#8255" class="Bound">f</a> <a id="8276" href="decidability.html#8264" class="Bound">x</a><a id="8277" class="Symbol">)</a>
<a id="8279" href="decidability.html#8152" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8294" href="decidability.html#8294" class="Bound">f</a> <a id="8296" href="decidability.html#8296" class="Bound">g</a> <a id="8298" class="Symbol">(</a><a id="8299" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8303" href="decidability.html#8303" class="Bound">h</a><a id="8304" class="Symbol">)</a> <a id="8306" class="Symbol">=</a> <a id="8308" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8312" class="Symbol">(</a><a id="8313" href="decidability.html#8296" class="Bound">g</a> <a id="8315" href="decidability.html#8303" class="Bound">h</a><a id="8316" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8331" href="decidability.html#8331" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8359" class="Symbol">:</a> <a id="8361" class="Symbol">{</a><a id="8362" href="decidability.html#8362" class="Bound">A</a> <a id="8364" class="Symbol">:</a> <a id="8366" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8370" class="Symbol">}</a> <a id="8372" class="Symbol">→</a> <a id="8374" href="decidability.html#8362" class="Bound">A</a> <a id="8376" class="Symbol">→</a> <a id="8378" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8391" href="decidability.html#8362" class="Bound">A</a>
<a id="8393" href="decidability.html#8331" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8421" class="Symbol">=</a> <a id="8423" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8428" href="decidability.html#8428" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8454" class="Symbol">:</a> <a id="8456" class="Symbol">{</a><a id="8457" href="decidability.html#8457" class="Bound">A</a> <a id="8459" class="Symbol">:</a> <a id="8461" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8465" class="Symbol">}</a> <a id="8467" class="Symbol">→</a> <a id="8469" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8471" href="decidability.html#8457" class="Bound">A</a> <a id="8473" class="Symbol">→</a> <a id="8475" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8488" href="decidability.html#8457" class="Bound">A</a>
<a id="8490" href="decidability.html#8428" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8516" class="Symbol">=</a> <a id="8518" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8523" href="decidability.html#8523" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8538" class="Symbol">:</a> <a id="8540" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8553" href="unit-type.html#352" data-type="Type" class="Record">𝟙</a>
<a id="8555" href="decidability.html#8523" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8570" class="Symbol">=</a> <a id="8572" href="decidability.html#8331" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8600" href="unit-type.html#382" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8603" href="decidability.html#8603" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8618" class="Symbol">:</a> <a id="8620" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8633" href="empty-type.html#479" data-type="Set" class="Datatype">𝟘</a>
<a id="8635" href="decidability.html#8603" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8650" class="Symbol">=</a> <a id="8652" href="decidability.html#8428" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8678" href="empty-type.html#3580" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="8690" href="decidability.html#8690" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8715" class="Symbol">:</a> <a id="8717" class="Symbol">{</a><a id="8718" href="decidability.html#8718" class="Bound">A</a> <a id="8720" href="decidability.html#8720" class="Bound">B</a> <a id="8722" class="Symbol">:</a> <a id="8724" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8728" class="Symbol">}</a>
                         <a id="8755" class="Symbol">→</a> <a id="8757" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8770" href="decidability.html#8718" class="Bound">A</a>
                         <a id="8797" class="Symbol">→</a> <a id="8799" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8812" href="decidability.html#8720" class="Bound">B</a>
                         <a id="8839" class="Symbol">→</a> <a id="8841" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8854" class="Symbol">(</a><a id="8855" href="decidability.html#8718" class="Bound">A</a> <a id="8857" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="8859" href="decidability.html#8720" class="Bound">B</a><a id="8860" class="Symbol">)</a>
<a id="8862" href="decidability.html#8690" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8887" class="Symbol">(</a><a id="8888" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8892" href="decidability.html#8892" class="Bound">x</a><a id="8893" class="Symbol">)</a> <a id="8895" class="Symbol">_</a>       <a id="8903" class="Symbol">=</a> <a id="8905" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8909" class="Symbol">(</a><a id="8910" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8914" href="decidability.html#8892" class="Bound">x</a><a id="8915" class="Symbol">)</a>
<a id="8917" href="decidability.html#8690" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8942" class="Symbol">(</a><a id="8943" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8947" class="Symbol">_)</a> <a id="8950" class="Symbol">(</a><a id="8951" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8955" href="decidability.html#8955" class="Bound">y</a><a id="8956" class="Symbol">)</a> <a id="8958" class="Symbol">=</a> <a id="8960" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8964" class="Symbol">(</a><a id="8965" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8969" href="decidability.html#8955" class="Bound">y</a><a id="8970" class="Symbol">)</a>
<a id="8972" href="decidability.html#8690" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8997" class="Symbol">(</a><a id="8998" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9002" href="decidability.html#9002" class="Bound">h</a><a id="9003" class="Symbol">)</a> <a id="9005" class="Symbol">(</a><a id="9006" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9010" href="decidability.html#9010" class="Bound">k</a><a id="9011" class="Symbol">)</a> <a id="9013" class="Symbol">=</a> <a id="9015" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9019" class="Symbol">(</a><a id="9020" href="binary-sums.html#3551" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9034" href="decidability.html#9002" class="Bound">h</a> <a id="9036" href="decidability.html#9010" class="Bound">k</a><a id="9037" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9040" href="decidability.html#9040" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9065" class="Symbol">:</a> <a id="9067" class="Symbol">{</a><a id="9068" href="decidability.html#9068" class="Bound">A</a> <a id="9070" href="decidability.html#9070" class="Bound">B</a> <a id="9072" class="Symbol">:</a> <a id="9074" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9078" class="Symbol">}</a>
                         <a id="9105" class="Symbol">→</a> <a id="9107" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9120" href="decidability.html#9068" class="Bound">A</a>
                         <a id="9147" class="Symbol">→</a> <a id="9149" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9162" href="decidability.html#9070" class="Bound">B</a>
                         <a id="9189" class="Symbol">→</a> <a id="9191" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9204" class="Symbol">(</a><a id="9205" href="decidability.html#9068" class="Bound">A</a> <a id="9207" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9209" href="decidability.html#9070" class="Bound">B</a><a id="9210" class="Symbol">)</a>
<a id="9212" href="decidability.html#9040" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9237" class="Symbol">(</a><a id="9238" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9242" href="decidability.html#9242" class="Bound">x</a><a id="9243" class="Symbol">)</a> <a id="9245" class="Symbol">(</a><a id="9246" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9250" href="decidability.html#9250" class="Bound">y</a><a id="9251" class="Symbol">)</a> <a id="9253" class="Symbol">=</a> <a id="9255" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9259" class="Symbol">(</a><a id="9260" href="decidability.html#9242" class="Bound">x</a> <a id="9262" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9264" href="decidability.html#9250" class="Bound">y</a><a id="9265" class="Symbol">)</a>
<a id="9267" href="decidability.html#9040" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9292" class="Symbol">(</a><a id="9293" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9297" class="Symbol">_)</a> <a id="9300" class="Symbol">(</a><a id="9301" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9305" href="decidability.html#9305" class="Bound">k</a><a id="9306" class="Symbol">)</a> <a id="9308" class="Symbol">=</a> <a id="9310" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9314" class="Symbol">(λ</a> <a id="9317" class="Symbol">(</a><a id="9318" href="decidability.html#9318" class="Bound">x</a> <a id="9320" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9322" href="decidability.html#9322" class="Bound">y</a><a id="9323" class="Symbol">)</a> <a id="9325" class="Symbol">→</a> <a id="9327" href="decidability.html#9305" class="Bound">k</a> <a id="9329" href="decidability.html#9322" class="Bound">y</a><a id="9330" class="Symbol">)</a>
<a id="9332" href="decidability.html#9040" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9357" class="Symbol">(</a><a id="9358" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9362" href="decidability.html#9362" class="Bound">h</a><a id="9363" class="Symbol">)</a> <a id="9365" class="Symbol">_</a>       <a id="9373" class="Symbol">=</a> <a id="9375" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9379" class="Symbol">(λ</a> <a id="9382" class="Symbol">(</a><a id="9383" href="decidability.html#9383" class="Bound">x</a> <a id="9385" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9387" href="decidability.html#9387" class="Bound">y</a><a id="9388" class="Symbol">)</a> <a id="9390" class="Symbol">→</a> <a id="9392" href="decidability.html#9362" class="Bound">h</a> <a id="9394" href="decidability.html#9383" class="Bound">x</a><a id="9395" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9398" href="decidability.html#9398" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9423" class="Symbol">:</a> <a id="9425" class="Symbol">{</a><a id="9426" href="decidability.html#9426" class="Bound">A</a> <a id="9428" href="decidability.html#9428" class="Bound">B</a> <a id="9430" class="Symbol">:</a> <a id="9432" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9436" class="Symbol">}</a>
                         <a id="9463" class="Symbol">→</a> <a id="9465" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9478" href="decidability.html#9426" class="Bound">A</a>
                         <a id="9505" class="Symbol">→</a> <a id="9507" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9520" href="decidability.html#9428" class="Bound">B</a>
                         <a id="9547" class="Symbol">→</a> <a id="9549" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9562" class="Symbol">(</a><a id="9563" href="decidability.html#9426" class="Bound">A</a> <a id="9565" class="Symbol">→</a> <a id="9567" href="decidability.html#9428" class="Bound">B</a><a id="9568" class="Symbol">)</a>
<a id="9570" href="decidability.html#9398" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9595" class="Symbol">_</a>       <a id="9603" class="Symbol">(</a><a id="9604" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9608" href="decidability.html#9608" class="Bound">y</a><a id="9609" class="Symbol">)</a> <a id="9611" class="Symbol">=</a> <a id="9613" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9617" class="Symbol">(λ</a> <a id="9620" href="decidability.html#9620" class="Bound">_</a> <a id="9622" class="Symbol">→</a> <a id="9624" href="decidability.html#9608" class="Bound">y</a><a id="9625" class="Symbol">)</a>
<a id="9627" href="decidability.html#9398" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9652" class="Symbol">(</a><a id="9653" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9657" href="decidability.html#9657" class="Bound">x</a><a id="9658" class="Symbol">)</a> <a id="9660" class="Symbol">(</a><a id="9661" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9665" href="decidability.html#9665" class="Bound">k</a><a id="9666" class="Symbol">)</a> <a id="9668" class="Symbol">=</a> <a id="9670" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9674" class="Symbol">(λ</a> <a id="9677" href="decidability.html#9677" class="Bound">f</a> <a id="9679" class="Symbol">→</a> <a id="9681" href="decidability.html#9665" class="Bound">k</a> <a id="9683" class="Symbol">(</a><a id="9684" href="decidability.html#9677" class="Bound">f</a> <a id="9686" href="decidability.html#9657" class="Bound">x</a><a id="9687" class="Symbol">))</a>
<a id="9690" href="decidability.html#9398" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9715" class="Symbol">(</a><a id="9716" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9720" href="decidability.html#9720" class="Bound">h</a><a id="9721" class="Symbol">)</a> <a id="9723" class="Symbol">(</a><a id="9724" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9728" href="decidability.html#9728" class="Bound">k</a><a id="9729" class="Symbol">)</a> <a id="9731" class="Symbol">=</a> <a id="9733" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9737" class="Symbol">(λ</a> <a id="9740" href="decidability.html#9740" class="Bound">x</a> <a id="9742" class="Symbol">→</a> <a id="9744" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="9751" class="Symbol">(</a><a id="9752" href="decidability.html#9720" class="Bound">h</a> <a id="9754" href="decidability.html#9740" class="Bound">x</a><a id="9755" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="9759" href="decidability.html#9759" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9784" class="Symbol">:</a> <a id="9786" class="Symbol">{</a><a id="9787" href="decidability.html#9787" class="Bound">A</a> <a id="9789" class="Symbol">:</a> <a id="9791" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9795" class="Symbol">}</a>
                         <a id="9822" class="Symbol">→</a> <a id="9824" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9837" href="decidability.html#9787" class="Bound">A</a>
                         <a id="9864" class="Symbol">→</a> <a id="9866" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9879" class="Symbol">(</a><a id="9880" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="9882" href="decidability.html#9787" class="Bound">A</a><a id="9883" class="Symbol">)</a>
<a id="9885" href="decidability.html#9759" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9910" href="decidability.html#9910" class="Bound">d</a> <a id="9912" class="Symbol">=</a> <a id="9914" href="decidability.html#9398" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9939" href="decidability.html#9910" class="Bound">d</a> <a id="9941" href="decidability.html#8603" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h3 id="exhaustively-searchable-types">Exhaustively searchable
types</h3>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10468" href="decidability.html#10468" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10495" class="Symbol">:</a> <a id="10497" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="10502" class="Symbol">→</a> <a id="10504" href="general-notation.html#683" data-type="Set₂" class="Function">Type₁</a>
<a id="10510" href="decidability.html#10468" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10537" href="decidability.html#10537" class="Bound">X</a> <a id="10539" class="Symbol">=</a> <a id="10541" class="Symbol">(</a><a id="10542" href="decidability.html#10542" class="Bound">A</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="decidability.html#10537" class="Bound">X</a> <a id="10548" class="Symbol">→</a> <a id="10550" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="10554" class="Symbol">)</a>
                             <a id="10585" class="Symbol">→</a> <a id="10587" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10610" href="decidability.html#10542" class="Bound">A</a>
                             <a id="10641" class="Symbol">→</a> <a id="10643" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="10656" class="Symbol">(</a><a id="10657" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="10659" href="decidability.html#10659" class="Bound">x</a> <a id="10661" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="10663" href="decidability.html#10537" class="Bound">X</a> <a id="10665" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="10667" href="decidability.html#10542" class="Bound">A</a> <a id="10669" href="decidability.html#10659" class="Bound">x</a><a id="10670" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12089" href="decidability.html#12089" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12106" class="Symbol">:</a> <a id="12108" class="Symbol">(</a><a id="12109" href="decidability.html#12109" class="Bound">X</a> <a id="12111" class="Symbol">:</a> <a id="12113" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12117" class="Symbol">)</a>
                 <a id="12136" class="Symbol">→</a> <a id="12138" href="decidability.html#10468" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12165" href="decidability.html#12109" class="Bound">X</a>
                 <a id="12184" class="Symbol">→</a> <a id="12186" class="Symbol">(</a><a id="12187" href="decidability.html#12187" class="Bound">A</a> <a id="12189" class="Symbol">:</a> <a id="12191" href="decidability.html#12109" class="Bound">X</a> <a id="12193" class="Symbol">→</a> <a id="12195" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12199" class="Symbol">)</a>
                 <a id="12218" class="Symbol">→</a> <a id="12220" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12243" href="decidability.html#12187" class="Bound">A</a>
                 <a id="12262" class="Symbol">→</a> <a id="12264" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12277" class="Symbol">(</a><a id="12278" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12280" href="decidability.html#12280" class="Bound">x</a> <a id="12282" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12284" href="decidability.html#12109" class="Bound">X</a> <a id="12286" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12288" href="decidability.html#12187" class="Bound">A</a> <a id="12290" href="decidability.html#12280" class="Bound">x</a><a id="12291" class="Symbol">)</a>
<a id="12293" href="decidability.html#12089" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12310" href="decidability.html#12310" class="Bound">X</a> <a id="12312" href="decidability.html#12312" class="Bound">s</a> <a id="12314" href="decidability.html#12314" class="Bound">A</a> <a id="12316" href="decidability.html#12316" class="Bound">d</a> <a id="12318" class="Symbol">=</a> <a id="12320" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12324" class="Keyword">where</a>
  <a id="12332" href="decidability.html#12332" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12334" class="Symbol">:</a> <a id="12336" href="decidability.html#5304" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12359" class="Symbol">(λ</a> <a id="12362" href="decidability.html#12362" class="Bound">x</a> <a id="12364" class="Symbol">→</a> <a id="12366" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12368" class="Symbol">(</a><a id="12369" href="decidability.html#12314" class="Bound">A</a> <a id="12371" href="decidability.html#12362" class="Bound">x</a><a id="12372" class="Symbol">))</a>
  <a id="12377" href="decidability.html#12332" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12379" href="decidability.html#12379" class="Bound">x</a> <a id="12381" class="Symbol">=</a> <a id="12383" href="decidability.html#9759" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12408" class="Symbol">(</a><a id="12409" href="decidability.html#12316" class="Bound">d</a> <a id="12411" href="decidability.html#12379" class="Bound">x</a><a id="12412" class="Symbol">)</a>

  <a id="12417" href="decidability.html#12417" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12420" class="Symbol">:</a> <a id="12422" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12435" class="Symbol">(</a><a id="12436" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12438" href="decidability.html#12438" class="Bound">x</a> <a id="12440" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12442" href="decidability.html#12310" class="Bound">X</a> <a id="12444" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12446" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12448" class="Symbol">(</a><a id="12449" href="decidability.html#12314" class="Bound">A</a> <a id="12451" href="decidability.html#12438" class="Bound">x</a><a id="12452" class="Symbol">))</a>
  <a id="12457" href="decidability.html#12417" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12460" class="Symbol">=</a> <a id="12462" href="decidability.html#12312" class="Bound">s</a> <a id="12464" class="Symbol">(λ</a> <a id="12467" href="decidability.html#12467" class="Bound">x</a> <a id="12469" class="Symbol">→</a> <a id="12471" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12473" class="Symbol">(</a><a id="12474" href="decidability.html#12314" class="Bound">A</a> <a id="12476" href="decidability.html#12467" class="Bound">x</a><a id="12477" class="Symbol">))</a> <a id="12480" href="decidability.html#12332" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12485" href="decidability.html#12485" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12489" class="Symbol">:</a> <a id="12491" class="Symbol">(</a><a id="12492" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12494" href="decidability.html#12494" class="Bound">x</a> <a id="12496" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12498" href="decidability.html#12310" class="Bound">X</a> <a id="12500" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12502" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12504" class="Symbol">(</a><a id="12505" href="decidability.html#12314" class="Bound">A</a> <a id="12507" href="decidability.html#12494" class="Bound">x</a><a id="12508" class="Symbol">))</a> <a id="12511" class="Symbol">→</a> <a id="12513" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12515" class="Symbol">(</a><a id="12516" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12518" href="decidability.html#12518" class="Bound">x</a> <a id="12520" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12522" href="decidability.html#12310" class="Bound">X</a> <a id="12524" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12526" href="decidability.html#12314" class="Bound">A</a> <a id="12528" href="decidability.html#12518" class="Bound">x</a><a id="12529" class="Symbol">)</a>
  <a id="12533" href="decidability.html#12485" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12537" class="Symbol">(</a><a id="12538" href="decidability.html#12538" class="Bound">x</a> <a id="12540" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12542" href="decidability.html#12542" class="Bound">f</a><a id="12543" class="Symbol">)</a> <a id="12545" href="decidability.html#12545" class="Bound">g</a> <a id="12547" class="Symbol">=</a> <a id="12549" href="decidability.html#12542" class="Bound">f</a> <a id="12551" class="Symbol">(</a><a id="12552" href="decidability.html#12545" class="Bound">g</a> <a id="12554" href="decidability.html#12538" class="Bound">x</a><a id="12555" class="Symbol">)</a>

  <a id="12560" href="decidability.html#12560" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12563" class="Symbol">:</a> <a id="12565" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12567" class="Symbol">(</a><a id="12568" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12570" href="decidability.html#12570" class="Bound">x</a> <a id="12572" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12574" href="decidability.html#12310" class="Bound">X</a> <a id="12576" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12578" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12580" class="Symbol">(</a><a id="12581" href="decidability.html#12314" class="Bound">A</a> <a id="12583" href="decidability.html#12570" class="Bound">x</a><a id="12584" class="Symbol">))</a> <a id="12587" class="Symbol">→</a> <a id="12589" class="Symbol">(</a><a id="12590" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12592" href="decidability.html#12592" class="Bound">x</a> <a id="12594" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12596" href="decidability.html#12310" class="Bound">X</a> <a id="12598" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12600" href="decidability.html#12314" class="Bound">A</a> <a id="12602" href="decidability.html#12592" class="Bound">x</a><a id="12603" class="Symbol">)</a>
  <a id="12607" href="decidability.html#12560" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12610" href="decidability.html#12610" class="Bound">h</a> <a id="12612" href="decidability.html#12612" class="Bound">x</a> <a id="12614" class="Symbol">=</a> <a id="12616" href="decidability.html#12668" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="12622" class="Keyword">where</a>
    <a id="12632" href="decidability.html#12632" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12634" class="Symbol">:</a> <a id="12636" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="12639" href="decidability.html#12314" class="Bound">A</a> <a id="12641" href="decidability.html#12612" class="Bound">x</a>
    <a id="12647" href="decidability.html#12632" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12649" href="decidability.html#12649" class="Bound">f</a> <a id="12651" class="Symbol">=</a> <a id="12653" href="decidability.html#12610" class="Bound">h</a> <a id="12655" class="Symbol">(</a><a id="12656" href="decidability.html#12612" class="Bound">x</a> <a id="12658" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12660" href="decidability.html#12649" class="Bound">f</a><a id="12661" class="Symbol">)</a>

    <a id="12668" href="decidability.html#12668" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12671" class="Symbol">:</a> <a id="12673" href="decidability.html#12314" class="Bound">A</a> <a id="12675" href="decidability.html#12612" class="Bound">x</a>
    <a id="12681" href="decidability.html#12668" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12684" class="Symbol">=</a> <a id="12686" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="12694" class="Symbol">(</a><a id="12695" href="decidability.html#12316" class="Bound">d</a> <a id="12697" href="decidability.html#12612" class="Bound">x</a><a id="12698" class="Symbol">)</a> <a id="12700" href="decidability.html#12632" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="12705" href="decidability.html#12705" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12707" class="Symbol">:</a> <a id="12709" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12722" class="Symbol">(</a><a id="12723" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12725" href="decidability.html#12725" class="Bound">x</a> <a id="12727" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12729" href="decidability.html#12310" class="Bound">X</a> <a id="12731" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12733" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12735" class="Symbol">(</a><a id="12736" href="decidability.html#12314" class="Bound">A</a> <a id="12738" href="decidability.html#12725" class="Bound">x</a><a id="12739" class="Symbol">))</a> <a id="12742" class="Symbol">→</a> <a id="12744" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12757" class="Symbol">(</a><a id="12758" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12760" href="decidability.html#12760" class="Bound">x</a> <a id="12762" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12764" href="decidability.html#12310" class="Bound">X</a> <a id="12766" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12768" href="decidability.html#12314" class="Bound">A</a> <a id="12770" href="decidability.html#12760" class="Bound">x</a><a id="12771" class="Symbol">)</a>
  <a id="12775" href="decidability.html#12705" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12777" class="Symbol">=</a> <a id="12779" href="decidability.html#8152" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="12794" href="decidability.html#12485" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12798" href="decidability.html#12560" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="12804" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12807" class="Symbol">:</a> <a id="12809" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12822" class="Symbol">(</a><a id="12823" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12825" href="decidability.html#12825" class="Bound">x</a> <a id="12827" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12829" href="decidability.html#12310" class="Bound">X</a> <a id="12831" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12833" href="decidability.html#12314" class="Bound">A</a> <a id="12835" href="decidability.html#12825" class="Bound">x</a><a id="12836" class="Symbol">)</a>
  <a id="12840" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12843" class="Symbol">=</a> <a id="12845" href="decidability.html#12705" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12847" href="decidability.html#12417" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h3 id="decidable-equality">Decidable equality</h3>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13373" href="decidability.html#13373" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13396" class="Symbol">:</a> <a id="13398" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="13403" class="Symbol">→</a> <a id="13405" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="13410" href="decidability.html#13373" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13433" href="decidability.html#13433" class="Bound">X</a> <a id="13435" class="Symbol">=</a> <a id="13437" class="Symbol">(</a><a id="13438" href="decidability.html#13438" class="Bound">x</a> <a id="13440" href="decidability.html#13440" class="Bound">y</a> <a id="13442" class="Symbol">:</a> <a id="13444" href="decidability.html#13433" class="Bound">X</a><a id="13445" class="Symbol">)</a> <a id="13447" class="Symbol">→</a> <a id="13449" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="13462" class="Symbol">(</a><a id="13463" href="decidability.html#13438" class="Bound">x</a> <a id="13465" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13467" href="decidability.html#13440" class="Bound">y</a><a id="13468" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="13674" href="decidability.html#13674" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13702" class="Symbol">:</a> <a id="13704" href="decidability.html#13373" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13727" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="13732" href="decidability.html#13674" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13760" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13766" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13772" class="Symbol">=</a> <a id="13774" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13778" class="Symbol">(</a><a id="13779" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13784" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="13788" class="Symbol">)</a>
<a id="13790" href="decidability.html#13674" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13818" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13824" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13830" class="Symbol">=</a> <a id="13832" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13836" href="negation.html#3353" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="13854" href="decidability.html#13674" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13882" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13888" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13894" class="Symbol">=</a> <a id="13896" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13900" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="13918" href="decidability.html#13674" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13946" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13952" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13958" class="Symbol">=</a> <a id="13960" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13964" class="Symbol">(</a><a id="13965" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13970" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="13975" class="Symbol">)</a>

<a id="13978" class="Keyword">open</a> <a id="13983" class="Keyword">import</a> <a id="13990" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14017" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14042" class="Symbol">:</a> <a id="14044" href="decidability.html#13373" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14067" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>
<a id="14069" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14094" class="Number">0</a>       <a id="14102" class="Number">0</a>       <a id="14110" class="Symbol">=</a> <a id="14112" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14116" class="Symbol">(</a><a id="14117" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14122" href="introduction.html#551" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14126" class="Symbol">)</a>
<a id="14128" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14153" class="Number">0</a>       <a id="14161" class="Symbol">(</a><a id="14162" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14166" href="decidability.html#14166" class="Bound">y</a><a id="14167" class="Symbol">)</a> <a id="14169" class="Symbol">=</a> <a id="14171" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14175" href="natural-numbers-functions.html#501" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14191" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14216" class="Symbol">(</a><a id="14217" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14221" href="decidability.html#14221" class="Bound">x</a><a id="14222" class="Symbol">)</a> <a id="14224" class="Number">0</a>       <a id="14232" class="Symbol">=</a> <a id="14234" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14238" href="natural-numbers-functions.html#443" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14254" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14279" class="Symbol">(</a><a id="14280" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14284" href="decidability.html#14284" class="Bound">x</a><a id="14285" class="Symbol">)</a> <a id="14287" class="Symbol">(</a><a id="14288" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14292" href="decidability.html#14292" class="Bound">y</a><a id="14293" class="Symbol">)</a> <a id="14295" class="Symbol">=</a> <a id="14297" href="decidability.html#14471" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14302" class="Keyword">where</a>
  <a id="14310" href="decidability.html#14310" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14313" class="Symbol">:</a> <a id="14315" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="14328" class="Symbol">(</a><a id="14329" href="decidability.html#14284" class="Bound">x</a> <a id="14331" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14333" href="decidability.html#14292" class="Bound">y</a><a id="14334" class="Symbol">)</a>
  <a id="14338" href="decidability.html#14310" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14341" class="Symbol">=</a> <a id="14343" href="decidability.html#14017" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14368" href="decidability.html#14284" class="Bound">x</a> <a id="14370" href="decidability.html#14292" class="Bound">y</a>

  <a id="14375" href="decidability.html#14375" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14377" class="Symbol">:</a> <a id="14379" href="decidability.html#14284" class="Bound">x</a> <a id="14381" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14383" href="decidability.html#14292" class="Bound">y</a> <a id="14385" class="Symbol">→</a> <a id="14387" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14391" href="decidability.html#14284" class="Bound">x</a> <a id="14393" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14395" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14399" href="decidability.html#14292" class="Bound">y</a>
  <a id="14403" href="decidability.html#14375" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14405" class="Symbol">=</a> <a id="14407" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14410" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14417" href="decidability.html#14417" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14420" class="Symbol">:</a> <a id="14422" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14426" href="decidability.html#14284" class="Bound">x</a> <a id="14428" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14430" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14434" href="decidability.html#14292" class="Bound">y</a> <a id="14436" class="Symbol">→</a> <a id="14438" href="decidability.html#14284" class="Bound">x</a> <a id="14440" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14442" href="decidability.html#14292" class="Bound">y</a>
  <a id="14446" href="decidability.html#14417" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14449" class="Symbol">=</a> <a id="14451" href="natural-numbers-functions.html#607" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14471" href="decidability.html#14471" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14475" class="Symbol">:</a> <a id="14477" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="14490" class="Symbol">(</a><a id="14491" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14495" href="decidability.html#14284" class="Bound">x</a> <a id="14497" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14499" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14503" href="decidability.html#14292" class="Bound">y</a><a id="14504" class="Symbol">)</a>
  <a id="14508" href="decidability.html#14471" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14512" class="Symbol">=</a> <a id="14514" href="decidability.html#7802" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14528" href="decidability.html#14375" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14530" href="decidability.html#14417" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14533" href="decidability.html#14310" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h3 id="equality-of-functions">Equality of functions</h3>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="14821" class="Keyword">private</a>
 <a id="f"></a><a id="14830" href="decidability.html#14830" class="Function">f</a> <a id="g"></a><a id="14832" href="decidability.html#14832" class="Function">g</a> <a id="h"></a><a id="14834" href="decidability.html#14834" class="Function">h</a> <a id="14836" class="Symbol">:</a> <a id="14838" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="14840" class="Symbol">→</a> <a id="14842" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>

 <a id="14846" href="decidability.html#14830" class="Function">f</a> <a id="14848" href="decidability.html#14848" class="Bound">x</a> <a id="14850" class="Symbol">=</a> <a id="14852" href="decidability.html#14848" class="Bound">x</a>

 <a id="14856" href="decidability.html#14832" class="Function">g</a> <a id="14858" class="Number">0</a>       <a id="14866" class="Symbol">=</a> <a id="14868" class="Number">0</a>
 <a id="14871" href="decidability.html#14832" class="Function">g</a> <a id="14873" class="Symbol">(</a><a id="14874" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14878" href="decidability.html#14878" class="Bound">x</a><a id="14879" class="Symbol">)</a> <a id="14881" class="Symbol">=</a> <a id="14883" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14887" class="Symbol">(</a><a id="14888" href="decidability.html#14832" class="Function">g</a> <a id="14890" href="decidability.html#14878" class="Bound">x</a><a id="14891" class="Symbol">)</a>

 <a id="14895" href="decidability.html#14834" class="Function">h</a> <a id="14897" href="decidability.html#14897" class="Bound">x</a> <a id="14899" class="Symbol">=</a> <a id="14901" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14905" href="decidability.html#14897" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="14909" href="decidability.html#14909" class="Function">f-equals-g</a> <a id="14920" class="Symbol">:</a> <a id="14922" href="decidability.html#14830" class="Function">f</a> <a id="14924" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="14926" href="decidability.html#14832" class="Function">g</a>
 <a id="14929" href="decidability.html#14909" class="Function">f-equals-g</a> <a id="14940" class="Number">0</a>       <a id="14948" class="Symbol">=</a> <a id="14950" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14955" class="Symbol">(</a><a id="14956" href="decidability.html#14830" class="Function">f</a> <a id="14958" class="Number">0</a><a id="14959" class="Symbol">)</a>
 <a id="14962" href="decidability.html#14909" class="Function">f-equals-g</a> <a id="14973" class="Symbol">(</a><a id="14974" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14978" href="decidability.html#14978" class="Bound">x</a><a id="14979" class="Symbol">)</a> <a id="14981" class="Symbol">=</a> <a id="14983" href="decidability.html#15039" class="Function">goal</a>
  <a id="14990" class="Keyword">where</a>
   <a id="14999" href="decidability.html#14999" class="Function">IH</a> <a id="15002" class="Symbol">:</a> <a id="15004" href="decidability.html#14830" class="Function">f</a> <a id="15006" href="decidability.html#14978" class="Bound">x</a> <a id="15008" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15010" href="decidability.html#14832" class="Function">g</a> <a id="15012" href="decidability.html#14978" class="Bound">x</a>
   <a id="15017" href="decidability.html#14999" class="Function">IH</a> <a id="15020" class="Symbol">=</a> <a id="15022" href="decidability.html#14909" class="Function">f-equals-g</a> <a id="15033" href="decidability.html#14978" class="Bound">x</a>

   <a id="15039" href="decidability.html#15039" class="Function">goal</a> <a id="15044" class="Symbol">:</a> <a id="15046" href="decidability.html#14830" class="Function">f</a> <a id="15048" class="Symbol">(</a><a id="15049" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15053" href="decidability.html#14978" class="Bound">x</a><a id="15054" class="Symbol">)</a> <a id="15056" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15058" href="decidability.html#14832" class="Function">g</a> <a id="15060" class="Symbol">(</a><a id="15061" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15065" href="decidability.html#14978" class="Bound">x</a><a id="15066" class="Symbol">)</a>
   <a id="15071" href="decidability.html#15039" class="Function">goal</a> <a id="15076" class="Symbol">=</a> <a id="15078" href="decidability.html#14830" class="Function">f</a> <a id="15080" class="Symbol">(</a><a id="15081" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15085" href="decidability.html#14978" class="Bound">x</a><a id="15086" class="Symbol">)</a> <a id="15088" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15091" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15096" class="Symbol">_</a> <a id="15098" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15110" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15114" href="decidability.html#14978" class="Bound">x</a>     <a id="15120" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15123" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15128" class="Symbol">_</a> <a id="15130" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15142" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15146" class="Symbol">(</a><a id="15147" href="decidability.html#14830" class="Function">f</a> <a id="15149" href="decidability.html#14978" class="Bound">x</a><a id="15150" class="Symbol">)</a> <a id="15152" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15155" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15158" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15162" href="decidability.html#14999" class="Function">IH</a> <a id="15165" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15177" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15181" class="Symbol">(</a><a id="15182" href="decidability.html#14832" class="Function">g</a> <a id="15184" href="decidability.html#14978" class="Bound">x</a><a id="15185" class="Symbol">)</a> <a id="15187" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15190" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15195" class="Symbol">_</a> <a id="15197" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15209" href="decidability.html#14832" class="Function">g</a> <a id="15211" class="Symbol">(</a><a id="15212" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15216" href="decidability.html#14978" class="Bound">x</a><a id="15217" class="Symbol">)</a> <a id="15219" href="identity-type.html#4194" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15223" href="decidability.html#15223" class="Function">f-not-equals-h</a> <a id="15238" class="Symbol">:</a> <a id="15240" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15242" class="Symbol">(</a><a id="15243" href="decidability.html#14830" class="Function">f</a> <a id="15245" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15247" href="decidability.html#14834" class="Function">h</a><a id="15248" class="Symbol">)</a>
 <a id="15251" href="decidability.html#15223" class="Function">f-not-equals-h</a> <a id="15266" href="decidability.html#15266" class="Bound">e</a> <a id="15268" class="Symbol">=</a> <a id="15270" href="decidability.html#15322" class="Function">contradiction</a> <a id="15284" href="decidability.html#15297" class="Function">d</a>
  <a id="15288" class="Keyword">where</a>
   <a id="15297" href="decidability.html#15297" class="Function">d</a> <a id="15299" class="Symbol">:</a> <a id="15301" class="Number">0</a> <a id="15303" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15305" class="Number">1</a>
   <a id="15310" href="decidability.html#15297" class="Function">d</a> <a id="15312" class="Symbol">=</a> <a id="15314" href="decidability.html#15266" class="Bound">e</a> <a id="15316" class="Number">0</a>

   <a id="15322" href="decidability.html#15322" class="Function">contradiction</a> <a id="15336" class="Symbol">:</a> <a id="15338" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15340" class="Symbol">(</a><a id="15341" class="Number">0</a> <a id="15343" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15345" class="Number">1</a><a id="15346" class="Symbol">)</a>
   <a id="15351" href="decidability.html#15322" class="Function">contradiction</a> <a id="15365" class="Symbol">()</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}

</html>
