<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p>Martin Escardo. Notes originally written for the module “Advanced
Functional Programming” at the School of Computer Science of the
University of Birmingham, UK.</p>
<!--
<pre class="Agda"><a id="178" class="Symbol">{-#</a> <a id="182" class="Keyword">OPTIONS</a> <a id="190" class="Pragma">--without-K</a> <a id="202" class="Pragma">--safe</a> <a id="209" class="Symbol">#-}</a>

<a id="214" class="Keyword">module</a> <a id="221" href="decidability.html" class="Module">decidability</a> <a id="234" class="Keyword">where</a>

<a id="241" class="Keyword">open</a> <a id="246" class="Keyword">import</a> <a id="253" href="prelude.html" class="Module">prelude</a>
<a id="261" class="Keyword">open</a> <a id="266" class="Keyword">import</a> <a id="273" href="negation.html" class="Module">negation</a>
<a id="282" class="Keyword">open</a> <a id="287" class="Keyword">import</a> <a id="294" href="introduction.html" class="Module">introduction</a> <a id="307" class="Keyword">using</a> <a id="313" class="Symbol">(</a><a id="314" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="316" class="Symbol">;</a> <a id="318" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="322" class="Symbol">;</a> <a id="324" href="introduction.html#551" data-type="ℕ" class="InductiveConstructor">zero</a><a id="328" class="Symbol">)</a>
</pre>-->
<h1
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h1>
<p>When programming in conventional programming languages such as
Haskell, C, Java or Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h2 id="discussion-and-motivation">Discussion and motivation</h2>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h2 id="decidable-propositions">Decidable propositions</h2>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2608" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="2621" class="Symbol">:</a> <a id="2623" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="2628" class="Symbol">→</a> <a id="2630" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="2635" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="2648" href="decidability.html#2648" class="Bound">A</a> <a id="2650" class="Symbol">=</a> <a id="2652" href="decidability.html#2648" class="Bound">A</a> <a id="2654" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2656" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="2658" href="decidability.html#2648" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="2883" href="decidability.html#2883" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2891" class="Symbol">:</a> <a id="2893" class="Symbol">{</a><a id="2894" href="decidability.html#2894" class="Bound">A</a> <a id="2896" class="Symbol">:</a> <a id="2898" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2902" class="Symbol">}</a> <a id="2904" class="Symbol">→</a> <a id="2906" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="2919" href="decidability.html#2894" class="Bound">A</a> <a id="2921" class="Symbol">→</a> <a id="2923" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2926" href="decidability.html#2894" class="Bound">A</a> <a id="2928" class="Symbol">→</a> <a id="2930" href="decidability.html#2894" class="Bound">A</a>
<a id="2932" href="decidability.html#2883" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2940" class="Symbol">(</a><a id="2941" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2945" href="decidability.html#2945" class="Bound">x</a><a id="2946" class="Symbol">)</a> <a id="2948" href="decidability.html#2948" class="Bound">f</a> <a id="2950" class="Symbol">=</a> <a id="2952" href="decidability.html#2945" class="Bound">x</a>
<a id="2954" href="decidability.html#2883" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2962" class="Symbol">(</a><a id="2963" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2967" href="decidability.html#2967" class="Bound">g</a><a id="2968" class="Symbol">)</a> <a id="2970" href="decidability.html#2970" class="Bound">f</a> <a id="2972" class="Symbol">=</a> <a id="2974" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="2981" class="Symbol">(</a><a id="2982" href="decidability.html#2970" class="Bound">f</a> <a id="2984" href="decidability.html#2967" class="Bound">g</a><a id="2985" class="Symbol">)</a>
</pre>
<h2 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h2>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3413" href="decidability.html#3413" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3440" class="Symbol">:</a> <a id="3442" class="Symbol">(</a><a id="3443" href="decidability.html#3443" class="Bound">A</a> <a id="3445" class="Symbol">:</a> <a id="3447" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3451" class="Symbol">)</a> <a id="3453" class="Symbol">→</a> <a id="3455" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="3468" href="decidability.html#3443" class="Bound">A</a> <a id="3470" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3472" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3474" href="decidability.html#3474" class="Bound">b</a> <a id="3476" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3478" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3483" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3485" class="Symbol">(</a><a id="3486" href="decidability.html#3443" class="Bound">A</a> <a id="3488" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3490" href="decidability.html#3474" class="Bound">b</a> <a id="3492" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3494" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3498" class="Symbol">)</a>
<a id="3500" href="decidability.html#3413" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3527" href="decidability.html#3527" class="Bound">A</a> <a id="3529" class="Symbol">=</a> <a id="3531" href="decidability.html#3546" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3533" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3535" href="decidability.html#3840" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3538" class="Keyword">where</a>
  <a id="3546" href="decidability.html#3546" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3548" class="Symbol">:</a> <a id="3550" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="3563" href="decidability.html#3527" class="Bound">A</a> <a id="3565" class="Symbol">→</a> <a id="3567" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3569" href="decidability.html#3569" class="Bound">b</a> <a id="3571" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3573" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3578" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3580" class="Symbol">(</a><a id="3581" href="decidability.html#3527" class="Bound">A</a> <a id="3583" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3585" href="decidability.html#3569" class="Bound">b</a> <a id="3587" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3589" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3593" class="Symbol">)</a>
  <a id="3597" href="decidability.html#3546" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3599" class="Symbol">(</a><a id="3600" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3604" href="decidability.html#3604" class="Bound">x</a><a id="3605" class="Symbol">)</a> <a id="3607" class="Symbol">=</a> <a id="3609" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3614" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3616" class="Symbol">(</a><a id="3617" href="decidability.html#3637" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3619" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3621" href="decidability.html#3682" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="3622" class="Symbol">)</a>
   <a id="3627" class="Keyword">where</a>
    <a id="3637" href="decidability.html#3637" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3639" class="Symbol">:</a> <a id="3641" href="decidability.html#3527" class="Bound">A</a> <a id="3643" class="Symbol">→</a> <a id="3645" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3650" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3652" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3661" href="decidability.html#3637" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3663" class="Symbol">_</a> <a id="3665" class="Symbol">=</a> <a id="3667" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3672" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="3682" href="decidability.html#3682" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3684" class="Symbol">:</a> <a id="3686" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3691" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3693" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3698" class="Symbol">→</a> <a id="3700" href="decidability.html#3527" class="Bound">A</a>
    <a id="3706" href="decidability.html#3682" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3708" class="Symbol">_</a> <a id="3710" class="Symbol">=</a> <a id="3712" href="decidability.html#3604" class="Bound">x</a>

  <a id="3717" href="decidability.html#3546" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3719" class="Symbol">(</a><a id="3720" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3724" href="decidability.html#3724" class="Bound">ν</a><a id="3725" class="Symbol">)</a> <a id="3727" class="Symbol">=</a> <a id="3729" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3735" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3737" class="Symbol">(</a><a id="3738" href="decidability.html#3758" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3740" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3742" href="decidability.html#3807" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="3743" class="Symbol">)</a>
   <a id="3748" class="Keyword">where</a>
    <a id="3758" href="decidability.html#3758" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3760" class="Symbol">:</a> <a id="3762" href="decidability.html#3527" class="Bound">A</a> <a id="3764" class="Symbol">→</a> <a id="3766" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3772" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3774" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3783" href="decidability.html#3758" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3785" href="decidability.html#3785" class="Bound">x</a> <a id="3787" class="Symbol">=</a> <a id="3789" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3796" class="Symbol">(</a><a id="3797" href="decidability.html#3724" class="Bound">ν</a> <a id="3799" href="decidability.html#3785" class="Bound">x</a><a id="3800" class="Symbol">)</a>

    <a id="3807" href="decidability.html#3807" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3809" class="Symbol">:</a> <a id="3811" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3817" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3819" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3824" class="Symbol">→</a> <a id="3826" href="decidability.html#3527" class="Bound">A</a>
    <a id="3832" href="decidability.html#3807" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3834" class="Symbol">()</a>

  <a id="3840" href="decidability.html#3840" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3842" class="Symbol">:</a> <a id="3844" class="Symbol">(</a><a id="3845" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3847" href="decidability.html#3847" class="Bound">b</a> <a id="3849" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3851" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3856" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3858" class="Symbol">(</a><a id="3859" href="decidability.html#3527" class="Bound">A</a> <a id="3861" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3863" href="decidability.html#3847" class="Bound">b</a> <a id="3865" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3867" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3871" class="Symbol">))</a> <a id="3874" class="Symbol">→</a> <a id="3876" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="3889" href="decidability.html#3527" class="Bound">A</a>
  <a id="3893" href="decidability.html#3840" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3895" class="Symbol">(</a><a id="3896" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3901" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="3904" href="decidability.html#3904" class="Bound">α</a> <a id="3906" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3908" href="decidability.html#3908" class="Bound">β</a><a id="3909" class="Symbol">)</a> <a id="3911" class="Symbol">=</a> <a id="3913" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3917" class="Symbol">(</a><a id="3918" href="decidability.html#3908" class="Bound">β</a> <a id="3920" class="Symbol">(</a><a id="3921" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3926" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3930" class="Symbol">))</a>
  <a id="3935" href="decidability.html#3840" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3937" class="Symbol">(</a><a id="3938" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3944" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3946" href="decidability.html#3946" class="Bound">α</a> <a id="3948" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3950" href="decidability.html#3950" class="Bound">β</a><a id="3951" class="Symbol">)</a> <a id="3953" class="Symbol">=</a> <a id="3955" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3959" class="Symbol">(λ</a> <a id="3962" href="decidability.html#3962" class="Bound">x</a> <a id="3964" class="Symbol">→</a> <a id="3966" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3984" class="Symbol">(</a><a id="3985" href="decidability.html#3946" class="Bound">α</a> <a id="3987" href="decidability.html#3962" class="Bound">x</a><a id="3988" class="Symbol">))</a>
</pre>
<h2 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h2>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is odd. <!--
<pre class="Agda"><a id="4511" class="Keyword">module</a> <a id="4518" href="decidability.html#4518" class="Module">_</a> <a id="4520" class="Keyword">where</a>
 <a id="4527" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4553" href="decidability.html#4553" class="Function">is-even</a> <a id="4561" class="Symbol">:</a> <a id="4563" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4565" class="Symbol">→</a> <a id="4567" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
  <a id="4574" href="decidability.html#4553" class="Function">is-even</a> <a id="4582" href="decidability.html#4582" class="Bound">x</a> <a id="4584" class="Symbol">=</a> <a id="4586" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4588" href="decidability.html#4588" class="Bound">y</a> <a id="4590" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4592" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4594" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4596" href="decidability.html#4582" class="Bound">x</a> <a id="4598" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4600" class="Number">2</a> <a id="4602" href="natural-numbers-type.html#2889" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4604" href="decidability.html#4588" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="4806" href="decidability.html#4806" class="Function">check-even</a> <a id="4817" class="Symbol">:</a> <a id="4819" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4821" class="Symbol">→</a> <a id="4823" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
  <a id="4830" href="decidability.html#4806" class="Function">check-even</a> <a id="4841" class="Number">0</a>       <a id="4849" class="Symbol">=</a> <a id="4851" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4858" href="decidability.html#4806" class="Function">check-even</a> <a id="4869" class="Symbol">(</a><a id="4870" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="4874" href="decidability.html#4874" class="Bound">x</a><a id="4875" class="Symbol">)</a> <a id="4877" class="Symbol">=</a> <a id="4879" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4883" class="Symbol">(</a><a id="4884" href="decidability.html#4806" class="Function">check-even</a> <a id="4895" href="decidability.html#4874" class="Bound">x</a><a id="4896" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5306" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5329" class="Symbol">:</a> <a id="5331" class="Symbol">{</a><a id="5332" href="decidability.html#5332" class="Bound">X</a> <a id="5334" class="Symbol">:</a> <a id="5336" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5340" class="Symbol">}</a> <a id="5342" class="Symbol">→</a> <a id="5344" class="Symbol">(</a><a id="5345" href="decidability.html#5332" class="Bound">X</a> <a id="5347" class="Symbol">→</a> <a id="5349" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5353" class="Symbol">)</a> <a id="5355" class="Symbol">→</a> <a id="5357" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="5362" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5385" class="Symbol">{</a><a id="5386" href="decidability.html#5386" class="Bound">X</a><a id="5387" class="Symbol">}</a> <a id="5389" href="decidability.html#5389" class="Bound">A</a> <a id="5391" class="Symbol">=</a> <a id="5393" class="Symbol">(</a><a id="5394" href="decidability.html#5394" class="Bound">x</a> <a id="5396" class="Symbol">:</a> <a id="5398" href="decidability.html#5386" class="Bound">X</a><a id="5399" class="Symbol">)</a> <a id="5401" class="Symbol">→</a> <a id="5403" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="5416" class="Symbol">(</a><a id="5417" href="decidability.html#5389" class="Bound">A</a> <a id="5419" href="decidability.html#5394" class="Bound">x</a><a id="5420" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="5944" href="decidability.html#5944" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="5981" class="Symbol">:</a> <a id="5983" class="Symbol">{</a><a id="5984" href="decidability.html#5984" class="Bound">X</a> <a id="5986" class="Symbol">:</a> <a id="5988" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5992" class="Symbol">}</a> <a id="5994" class="Symbol">(</a><a id="5995" href="decidability.html#5995" class="Bound">A</a> <a id="5997" class="Symbol">:</a> <a id="5999" href="decidability.html#5984" class="Bound">X</a> <a id="6001" class="Symbol">→</a> <a id="6003" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="6007" class="Symbol">)</a>
                                     <a id="6046" class="Symbol">→</a> <a id="6048" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6071" href="decidability.html#5995" class="Bound">A</a>
                                     <a id="6110" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6112" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6114" href="decidability.html#6114" class="Bound">α</a> <a id="6116" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6118" class="Symbol">(</a><a id="6119" href="decidability.html#5984" class="Bound">X</a> <a id="6121" class="Symbol">→</a> <a id="6123" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6127" class="Symbol">)</a> <a id="6129" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6131" class="Symbol">((</a><a id="6133" href="decidability.html#6133" class="Bound">x</a> <a id="6135" class="Symbol">:</a> <a id="6137" href="decidability.html#5984" class="Bound">X</a><a id="6138" class="Symbol">)</a> <a id="6140" class="Symbol">→</a> <a id="6142" href="decidability.html#5995" class="Bound">A</a> <a id="6144" href="decidability.html#6133" class="Bound">x</a> <a id="6146" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6148" href="decidability.html#6114" class="Bound">α</a> <a id="6150" href="decidability.html#6133" class="Bound">x</a> <a id="6152" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6154" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6158" class="Symbol">)</a>
<a id="6160" href="decidability.html#5944" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6197" class="Symbol">{</a><a id="6198" href="decidability.html#6198" class="Bound">X</a><a id="6199" class="Symbol">}</a> <a id="6201" href="decidability.html#6201" class="Bound">A</a> <a id="6203" class="Symbol">=</a> <a id="6205" href="decidability.html#6220" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6207" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6209" href="decidability.html#6865" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6212" class="Keyword">where</a>
  <a id="6220" href="decidability.html#6220" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6222" class="Symbol">:</a> <a id="6224" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6247" href="decidability.html#6201" class="Bound">A</a> <a id="6249" class="Symbol">→</a> <a id="6251" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6253" href="decidability.html#6253" class="Bound">α</a> <a id="6255" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6257" class="Symbol">(</a><a id="6258" href="decidability.html#6198" class="Bound">X</a> <a id="6260" class="Symbol">→</a> <a id="6262" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6266" class="Symbol">)</a> <a id="6268" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6270" class="Symbol">((</a><a id="6272" href="decidability.html#6272" class="Bound">x</a> <a id="6274" class="Symbol">:</a> <a id="6276" href="decidability.html#6198" class="Bound">X</a><a id="6277" class="Symbol">)</a> <a id="6279" class="Symbol">→</a> <a id="6281" href="decidability.html#6201" class="Bound">A</a> <a id="6283" href="decidability.html#6272" class="Bound">x</a> <a id="6285" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6287" href="decidability.html#6253" class="Bound">α</a> <a id="6289" href="decidability.html#6272" class="Bound">x</a> <a id="6291" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6293" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6297" class="Symbol">)</a>
  <a id="6301" href="decidability.html#6220" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6303" href="decidability.html#6303" class="Bound">d</a> <a id="6305" class="Symbol">=</a> <a id="6307" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6309" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6311" href="decidability.html#6498" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6316" class="Keyword">where</a>
    <a id="6326" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6328" class="Symbol">:</a> <a id="6330" href="decidability.html#6198" class="Bound">X</a> <a id="6332" class="Symbol">→</a> <a id="6334" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
    <a id="6343" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6345" href="decidability.html#6345" class="Bound">x</a> <a id="6347" class="Symbol">=</a> <a id="6349" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a> <a id="6353" class="Symbol">(</a><a id="6354" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6369" href="decidability.html#6395" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6371" class="Symbol">(</a><a id="6372" href="decidability.html#6303" class="Bound">d</a> <a id="6374" href="decidability.html#6345" class="Bound">x</a><a id="6375" class="Symbol">))</a>
     <a id="6383" class="Keyword">where</a>
      <a id="6395" href="decidability.html#6395" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6397" class="Symbol">:</a> <a id="6399" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="6412" class="Symbol">(</a><a id="6413" href="decidability.html#6201" class="Bound">A</a> <a id="6415" href="decidability.html#6345" class="Bound">x</a><a id="6416" class="Symbol">)</a> <a id="6418" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6420" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6422" href="decidability.html#6422" class="Bound">b</a> <a id="6424" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6426" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6431" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6433" class="Symbol">(</a><a id="6434" href="decidability.html#6201" class="Bound">A</a> <a id="6436" href="decidability.html#6345" class="Bound">x</a> <a id="6438" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6440" href="decidability.html#6422" class="Bound">b</a> <a id="6442" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6444" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6448" class="Symbol">)</a>
      <a id="6456" href="decidability.html#6395" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6458" class="Symbol">=</a> <a id="6460" href="decidability.html#3413" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6487" class="Symbol">(</a><a id="6488" href="decidability.html#6201" class="Bound">A</a> <a id="6490" href="decidability.html#6345" class="Bound">x</a><a id="6491" class="Symbol">)</a>

    <a id="6498" href="decidability.html#6498" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6500" class="Symbol">:</a> <a id="6502" class="Symbol">(</a><a id="6503" href="decidability.html#6503" class="Bound">x</a> <a id="6505" class="Symbol">:</a> <a id="6507" href="decidability.html#6198" class="Bound">X</a><a id="6508" class="Symbol">)</a> <a id="6510" class="Symbol">→</a> <a id="6512" href="decidability.html#6201" class="Bound">A</a> <a id="6514" href="decidability.html#6503" class="Bound">x</a> <a id="6516" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6518" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6520" href="decidability.html#6503" class="Bound">x</a> <a id="6522" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6524" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6533" href="decidability.html#6498" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6535" href="decidability.html#6535" class="Bound">x</a> <a id="6537" class="Symbol">=</a> <a id="6539" href="decidability.html#6745" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6541" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6543" href="decidability.html#6807" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6550" class="Keyword">where</a>
      <a id="6562" href="decidability.html#6562" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6564" class="Symbol">:</a> <a id="6566" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="6579" class="Symbol">(</a><a id="6580" href="decidability.html#6201" class="Bound">A</a> <a id="6582" href="decidability.html#6535" class="Bound">x</a><a id="6583" class="Symbol">)</a> <a id="6585" class="Symbol">→</a> <a id="6587" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6589" href="decidability.html#6589" class="Bound">b</a> <a id="6591" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6593" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6598" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6600" class="Symbol">(</a><a id="6601" href="decidability.html#6201" class="Bound">A</a> <a id="6603" href="decidability.html#6535" class="Bound">x</a> <a id="6605" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6607" href="decidability.html#6589" class="Bound">b</a> <a id="6609" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6611" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6615" class="Symbol">)</a>
      <a id="6623" href="decidability.html#6562" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6625" class="Symbol">=</a> <a id="6627" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6642" class="Symbol">(</a><a id="6643" href="decidability.html#3413" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6670" class="Symbol">(</a><a id="6671" href="decidability.html#6201" class="Bound">A</a> <a id="6673" href="decidability.html#6535" class="Bound">x</a><a id="6674" class="Symbol">))</a>

      <a id="6684" href="decidability.html#6684" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6687" class="Symbol">:</a> <a id="6689" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6691" href="decidability.html#6691" class="Bound">b</a> <a id="6693" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6695" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6700" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6702" class="Symbol">(</a><a id="6703" href="decidability.html#6201" class="Bound">A</a> <a id="6705" href="decidability.html#6535" class="Bound">x</a> <a id="6707" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6709" href="decidability.html#6691" class="Bound">b</a> <a id="6711" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6713" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6717" class="Symbol">)</a>
      <a id="6725" href="decidability.html#6684" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6728" class="Symbol">=</a> <a id="6730" href="decidability.html#6562" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6732" class="Symbol">(</a><a id="6733" href="decidability.html#6303" class="Bound">d</a> <a id="6735" href="decidability.html#6535" class="Bound">x</a><a id="6736" class="Symbol">)</a>

      <a id="6745" href="decidability.html#6745" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6747" class="Symbol">:</a> <a id="6749" href="decidability.html#6201" class="Bound">A</a> <a id="6751" href="decidability.html#6535" class="Bound">x</a> <a id="6753" class="Symbol">→</a> <a id="6755" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6757" href="decidability.html#6535" class="Bound">x</a> <a id="6759" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6761" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="6772" href="decidability.html#6745" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6774" class="Symbol">=</a> <a id="6776" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6791" class="Symbol">(</a><a id="6792" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6796" href="decidability.html#6684" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6798" class="Symbol">)</a>

      <a id="6807" href="decidability.html#6807" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6809" class="Symbol">:</a> <a id="6811" href="decidability.html#6326" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6813" href="decidability.html#6535" class="Bound">x</a> <a id="6815" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6817" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="6822" class="Symbol">→</a> <a id="6824" href="decidability.html#6201" class="Bound">A</a> <a id="6826" href="decidability.html#6535" class="Bound">x</a>
      <a id="6834" href="decidability.html#6807" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6836" class="Symbol">=</a> <a id="6838" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="6853" class="Symbol">(</a><a id="6854" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6858" href="decidability.html#6684" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6860" class="Symbol">)</a>

  <a id="6865" href="decidability.html#6865" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6867" class="Symbol">:</a> <a id="6869" class="Symbol">(</a><a id="6870" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6872" href="decidability.html#6872" class="Bound">α</a> <a id="6874" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6876" class="Symbol">(</a><a id="6877" href="decidability.html#6198" class="Bound">X</a> <a id="6879" class="Symbol">→</a> <a id="6881" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6885" class="Symbol">)</a> <a id="6887" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6889" class="Symbol">((</a><a id="6891" href="decidability.html#6891" class="Bound">x</a> <a id="6893" class="Symbol">:</a> <a id="6895" href="decidability.html#6198" class="Bound">X</a><a id="6896" class="Symbol">)</a> <a id="6898" class="Symbol">→</a> <a id="6900" href="decidability.html#6201" class="Bound">A</a> <a id="6902" href="decidability.html#6891" class="Bound">x</a> <a id="6904" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6906" href="decidability.html#6872" class="Bound">α</a> <a id="6908" href="decidability.html#6891" class="Bound">x</a> <a id="6910" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6912" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6916" class="Symbol">))</a> <a id="6919" class="Symbol">→</a> <a id="6921" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6944" href="decidability.html#6201" class="Bound">A</a>
  <a id="6948" href="decidability.html#6865" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6950" class="Symbol">(</a><a id="6951" href="decidability.html#6951" class="Bound">α</a> <a id="6953" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6955" href="decidability.html#6955" class="Bound">ϕ</a><a id="6956" class="Symbol">)</a> <a id="6958" class="Symbol">=</a> <a id="6960" href="decidability.html#6975" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="6965" class="Keyword">where</a>
    <a id="6975" href="decidability.html#6975" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="6977" class="Symbol">:</a> <a id="6979" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7002" href="decidability.html#6201" class="Bound">A</a>
    <a id="7008" href="decidability.html#6975" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7010" href="decidability.html#7010" class="Bound">x</a> <a id="7012" class="Symbol">=</a> <a id="7014" href="decidability.html#7224" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7023" class="Keyword">where</a>
      <a id="7035" href="decidability.html#7035" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7037" class="Symbol">:</a> <a id="7039" class="Symbol">(</a><a id="7040" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7042" href="decidability.html#7042" class="Bound">b</a> <a id="7044" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7046" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7051" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7053" class="Symbol">(</a><a id="7054" href="decidability.html#6201" class="Bound">A</a> <a id="7056" href="decidability.html#7010" class="Bound">x</a> <a id="7058" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7060" href="decidability.html#7042" class="Bound">b</a> <a id="7062" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7064" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7068" class="Symbol">))</a> <a id="7071" class="Symbol">→</a> <a id="7073" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="7086" class="Symbol">(</a><a id="7087" href="decidability.html#6201" class="Bound">A</a> <a id="7089" href="decidability.html#7010" class="Bound">x</a><a id="7090" class="Symbol">)</a>
      <a id="7098" href="decidability.html#7035" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7100" class="Symbol">=</a> <a id="7102" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7117" class="Symbol">(</a><a id="7118" href="decidability.html#3413" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7145" class="Symbol">(</a><a id="7146" href="decidability.html#6201" class="Bound">A</a> <a id="7148" href="decidability.html#7010" class="Bound">x</a><a id="7149" class="Symbol">))</a>

      <a id="7159" href="decidability.html#7159" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7162" class="Symbol">:</a> <a id="7164" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7166" href="decidability.html#7166" class="Bound">b</a> <a id="7168" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7170" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7175" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7177" class="Symbol">(</a><a id="7178" href="decidability.html#6201" class="Bound">A</a> <a id="7180" href="decidability.html#7010" class="Bound">x</a> <a id="7182" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7184" href="decidability.html#7166" class="Bound">b</a> <a id="7186" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7188" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7192" class="Symbol">)</a>
      <a id="7200" href="decidability.html#7159" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7203" class="Symbol">=</a> <a id="7205" class="Symbol">(</a><a id="7206" href="decidability.html#6951" class="Bound">α</a> <a id="7208" href="decidability.html#7010" class="Bound">x</a> <a id="7210" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7212" href="decidability.html#6955" class="Bound">ϕ</a> <a id="7214" href="decidability.html#7010" class="Bound">x</a><a id="7215" class="Symbol">)</a>

      <a id="7224" href="decidability.html#7224" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7228" class="Symbol">:</a> <a id="7230" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="7243" class="Symbol">(</a><a id="7244" href="decidability.html#6201" class="Bound">A</a> <a id="7246" href="decidability.html#7010" class="Bound">x</a><a id="7247" class="Symbol">)</a>
      <a id="7255" href="decidability.html#7224" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7259" class="Symbol">=</a> <a id="7261" href="decidability.html#7035" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7263" href="decidability.html#7159" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h2 id="preservation-of-decidability">Preservation of decidability</h2>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="7804" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7818" class="Symbol">:</a> <a id="7820" class="Symbol">{</a><a id="7821" href="decidability.html#7821" class="Bound">A</a> <a id="7823" href="decidability.html#7823" class="Bound">B</a> <a id="7825" class="Symbol">:</a> <a id="7827" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7831" class="Symbol">}</a> <a id="7833" class="Symbol">→</a> <a id="7835" class="Symbol">(</a><a id="7836" href="decidability.html#7821" class="Bound">A</a> <a id="7838" class="Symbol">→</a> <a id="7840" href="decidability.html#7823" class="Bound">B</a><a id="7841" class="Symbol">)</a> <a id="7843" class="Symbol">→</a> <a id="7845" class="Symbol">(</a><a id="7846" href="decidability.html#7823" class="Bound">B</a> <a id="7848" class="Symbol">→</a> <a id="7850" href="decidability.html#7821" class="Bound">A</a><a id="7851" class="Symbol">)</a> <a id="7853" class="Symbol">→</a> <a id="7855" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="7868" href="decidability.html#7821" class="Bound">A</a> <a id="7870" class="Symbol">→</a> <a id="7872" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="7885" href="decidability.html#7823" class="Bound">B</a>
<a id="7887" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7901" href="decidability.html#7901" class="Bound">f</a> <a id="7903" href="decidability.html#7903" class="Bound">g</a> <a id="7905" class="Symbol">(</a><a id="7906" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7910" href="decidability.html#7910" class="Bound">x</a><a id="7911" class="Symbol">)</a> <a id="7913" class="Symbol">=</a> <a id="7915" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7919" class="Symbol">(</a><a id="7920" href="decidability.html#7901" class="Bound">f</a> <a id="7922" href="decidability.html#7910" class="Bound">x</a><a id="7923" class="Symbol">)</a>
<a id="7925" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7939" href="decidability.html#7939" class="Bound">f</a> <a id="7941" href="decidability.html#7941" class="Bound">g</a> <a id="7943" class="Symbol">(</a><a id="7944" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7948" href="decidability.html#7948" class="Bound">h</a><a id="7949" class="Symbol">)</a> <a id="7951" class="Symbol">=</a> <a id="7953" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7957" class="Symbol">(λ</a> <a id="7960" href="decidability.html#7960" class="Bound">y</a> <a id="7962" class="Symbol">→</a> <a id="7964" href="decidability.html#7948" class="Bound">h</a> <a id="7966" class="Symbol">(</a><a id="7967" href="decidability.html#7941" class="Bound">g</a> <a id="7969" href="decidability.html#7960" class="Bound">y</a><a id="7970" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="7974" href="decidability.html#7974" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="7998" class="Symbol">:</a> <a id="8000" class="Symbol">{</a><a id="8001" href="decidability.html#8001" class="Bound">A</a> <a id="8003" href="decidability.html#8003" class="Bound">B</a> <a id="8005" class="Symbol">:</a> <a id="8007" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8011" class="Symbol">}</a> <a id="8013" class="Symbol">→</a> <a id="8015" class="Symbol">(</a><a id="8016" href="decidability.html#8001" class="Bound">A</a> <a id="8018" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8020" href="decidability.html#8003" class="Bound">B</a><a id="8021" class="Symbol">)</a> <a id="8023" class="Symbol">→</a> <a id="8025" class="Symbol">(</a><a id="8026" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8039" href="decidability.html#8001" class="Bound">A</a> <a id="8041" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8043" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8056" href="decidability.html#8003" class="Bound">B</a><a id="8057" class="Symbol">)</a>
<a id="8059" href="decidability.html#7974" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8083" class="Symbol">(</a><a id="8084" href="decidability.html#8084" class="Bound">f</a> <a id="8086" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8088" href="decidability.html#8088" class="Bound">g</a><a id="8089" class="Symbol">)</a> <a id="8091" class="Symbol">=</a> <a id="8093" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8107" href="decidability.html#8084" class="Bound">f</a> <a id="8109" href="decidability.html#8088" class="Bound">g</a> <a id="8111" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8113" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8127" href="decidability.html#8088" class="Bound">g</a> <a id="8129" href="decidability.html#8084" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8154" href="decidability.html#8154" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8169" class="Symbol">:</a> <a id="8171" class="Symbol">{</a><a id="8172" href="decidability.html#8172" class="Bound">A</a> <a id="8174" href="decidability.html#8174" class="Bound">B</a> <a id="8176" class="Symbol">:</a> <a id="8178" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8182" class="Symbol">}</a> <a id="8184" class="Symbol">→</a> <a id="8186" class="Symbol">(</a><a id="8187" href="decidability.html#8172" class="Bound">A</a> <a id="8189" class="Symbol">→</a> <a id="8191" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8193" href="decidability.html#8174" class="Bound">B</a><a id="8194" class="Symbol">)</a> <a id="8196" class="Symbol">→</a> <a id="8198" class="Symbol">(</a><a id="8199" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8201" href="decidability.html#8172" class="Bound">A</a> <a id="8203" class="Symbol">→</a> <a id="8205" href="decidability.html#8174" class="Bound">B</a><a id="8206" class="Symbol">)</a> <a id="8208" class="Symbol">→</a> <a id="8210" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8223" href="decidability.html#8172" class="Bound">A</a> <a id="8225" class="Symbol">→</a> <a id="8227" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8240" href="decidability.html#8174" class="Bound">B</a>
<a id="8242" href="decidability.html#8154" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8257" href="decidability.html#8257" class="Bound">f</a> <a id="8259" href="decidability.html#8259" class="Bound">g</a> <a id="8261" class="Symbol">(</a><a id="8262" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8266" href="decidability.html#8266" class="Bound">x</a><a id="8267" class="Symbol">)</a> <a id="8269" class="Symbol">=</a> <a id="8271" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8275" class="Symbol">(</a><a id="8276" href="decidability.html#8257" class="Bound">f</a> <a id="8278" href="decidability.html#8266" class="Bound">x</a><a id="8279" class="Symbol">)</a>
<a id="8281" href="decidability.html#8154" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8296" href="decidability.html#8296" class="Bound">f</a> <a id="8298" href="decidability.html#8298" class="Bound">g</a> <a id="8300" class="Symbol">(</a><a id="8301" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8305" href="decidability.html#8305" class="Bound">h</a><a id="8306" class="Symbol">)</a> <a id="8308" class="Symbol">=</a> <a id="8310" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8314" class="Symbol">(</a><a id="8315" href="decidability.html#8298" class="Bound">g</a> <a id="8317" href="decidability.html#8305" class="Bound">h</a><a id="8318" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8333" href="decidability.html#8333" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8361" class="Symbol">:</a> <a id="8363" class="Symbol">{</a><a id="8364" href="decidability.html#8364" class="Bound">A</a> <a id="8366" class="Symbol">:</a> <a id="8368" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8372" class="Symbol">}</a> <a id="8374" class="Symbol">→</a> <a id="8376" href="decidability.html#8364" class="Bound">A</a> <a id="8378" class="Symbol">→</a> <a id="8380" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8393" href="decidability.html#8364" class="Bound">A</a>
<a id="8395" href="decidability.html#8333" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8423" class="Symbol">=</a> <a id="8425" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8430" href="decidability.html#8430" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8456" class="Symbol">:</a> <a id="8458" class="Symbol">{</a><a id="8459" href="decidability.html#8459" class="Bound">A</a> <a id="8461" class="Symbol">:</a> <a id="8463" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8467" class="Symbol">}</a> <a id="8469" class="Symbol">→</a> <a id="8471" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8473" href="decidability.html#8459" class="Bound">A</a> <a id="8475" class="Symbol">→</a> <a id="8477" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8490" href="decidability.html#8459" class="Bound">A</a>
<a id="8492" href="decidability.html#8430" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8518" class="Symbol">=</a> <a id="8520" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8525" href="decidability.html#8525" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8540" class="Symbol">:</a> <a id="8542" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8555" href="unit-type.html#352" data-type="Type" class="Record">𝟙</a>
<a id="8557" href="decidability.html#8525" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8572" class="Symbol">=</a> <a id="8574" href="decidability.html#8333" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8602" href="unit-type.html#382" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8605" href="decidability.html#8605" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8620" class="Symbol">:</a> <a id="8622" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8635" href="empty-type.html#479" data-type="Set" class="Datatype">𝟘</a>
<a id="8637" href="decidability.html#8605" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8652" class="Symbol">=</a> <a id="8654" href="decidability.html#8430" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8680" href="empty-type.html#3580" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="8692" href="decidability.html#8692" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8717" class="Symbol">:</a> <a id="8719" class="Symbol">{</a><a id="8720" href="decidability.html#8720" class="Bound">A</a> <a id="8722" href="decidability.html#8722" class="Bound">B</a> <a id="8724" class="Symbol">:</a> <a id="8726" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8730" class="Symbol">}</a>
                         <a id="8757" class="Symbol">→</a> <a id="8759" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8772" href="decidability.html#8720" class="Bound">A</a>
                         <a id="8799" class="Symbol">→</a> <a id="8801" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8814" href="decidability.html#8722" class="Bound">B</a>
                         <a id="8841" class="Symbol">→</a> <a id="8843" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="8856" class="Symbol">(</a><a id="8857" href="decidability.html#8720" class="Bound">A</a> <a id="8859" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="8861" href="decidability.html#8722" class="Bound">B</a><a id="8862" class="Symbol">)</a>
<a id="8864" href="decidability.html#8692" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8889" class="Symbol">(</a><a id="8890" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8894" href="decidability.html#8894" class="Bound">x</a><a id="8895" class="Symbol">)</a> <a id="8897" class="Symbol">_</a>       <a id="8905" class="Symbol">=</a> <a id="8907" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8911" class="Symbol">(</a><a id="8912" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8916" href="decidability.html#8894" class="Bound">x</a><a id="8917" class="Symbol">)</a>
<a id="8919" href="decidability.html#8692" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8944" class="Symbol">(</a><a id="8945" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8949" class="Symbol">_)</a> <a id="8952" class="Symbol">(</a><a id="8953" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8957" href="decidability.html#8957" class="Bound">y</a><a id="8958" class="Symbol">)</a> <a id="8960" class="Symbol">=</a> <a id="8962" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8966" class="Symbol">(</a><a id="8967" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8971" href="decidability.html#8957" class="Bound">y</a><a id="8972" class="Symbol">)</a>
<a id="8974" href="decidability.html#8692" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8999" class="Symbol">(</a><a id="9000" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9004" href="decidability.html#9004" class="Bound">h</a><a id="9005" class="Symbol">)</a> <a id="9007" class="Symbol">(</a><a id="9008" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9012" href="decidability.html#9012" class="Bound">k</a><a id="9013" class="Symbol">)</a> <a id="9015" class="Symbol">=</a> <a id="9017" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9021" class="Symbol">(</a><a id="9022" href="binary-sums.html#3551" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9036" href="decidability.html#9004" class="Bound">h</a> <a id="9038" href="decidability.html#9012" class="Bound">k</a><a id="9039" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9042" href="decidability.html#9042" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9067" class="Symbol">:</a> <a id="9069" class="Symbol">{</a><a id="9070" href="decidability.html#9070" class="Bound">A</a> <a id="9072" href="decidability.html#9072" class="Bound">B</a> <a id="9074" class="Symbol">:</a> <a id="9076" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9080" class="Symbol">}</a>
                         <a id="9107" class="Symbol">→</a> <a id="9109" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9122" href="decidability.html#9070" class="Bound">A</a>
                         <a id="9149" class="Symbol">→</a> <a id="9151" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9164" href="decidability.html#9072" class="Bound">B</a>
                         <a id="9191" class="Symbol">→</a> <a id="9193" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9206" class="Symbol">(</a><a id="9207" href="decidability.html#9070" class="Bound">A</a> <a id="9209" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9211" href="decidability.html#9072" class="Bound">B</a><a id="9212" class="Symbol">)</a>
<a id="9214" href="decidability.html#9042" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9239" class="Symbol">(</a><a id="9240" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9244" href="decidability.html#9244" class="Bound">x</a><a id="9245" class="Symbol">)</a> <a id="9247" class="Symbol">(</a><a id="9248" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9252" href="decidability.html#9252" class="Bound">y</a><a id="9253" class="Symbol">)</a> <a id="9255" class="Symbol">=</a> <a id="9257" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9261" class="Symbol">(</a><a id="9262" href="decidability.html#9244" class="Bound">x</a> <a id="9264" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9266" href="decidability.html#9252" class="Bound">y</a><a id="9267" class="Symbol">)</a>
<a id="9269" href="decidability.html#9042" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9294" class="Symbol">(</a><a id="9295" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9299" class="Symbol">_)</a> <a id="9302" class="Symbol">(</a><a id="9303" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9307" href="decidability.html#9307" class="Bound">k</a><a id="9308" class="Symbol">)</a> <a id="9310" class="Symbol">=</a> <a id="9312" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9316" class="Symbol">(λ</a> <a id="9319" class="Symbol">(</a><a id="9320" href="decidability.html#9320" class="Bound">x</a> <a id="9322" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9324" href="decidability.html#9324" class="Bound">y</a><a id="9325" class="Symbol">)</a> <a id="9327" class="Symbol">→</a> <a id="9329" href="decidability.html#9307" class="Bound">k</a> <a id="9331" href="decidability.html#9324" class="Bound">y</a><a id="9332" class="Symbol">)</a>
<a id="9334" href="decidability.html#9042" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9359" class="Symbol">(</a><a id="9360" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9364" href="decidability.html#9364" class="Bound">h</a><a id="9365" class="Symbol">)</a> <a id="9367" class="Symbol">_</a>       <a id="9375" class="Symbol">=</a> <a id="9377" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9381" class="Symbol">(λ</a> <a id="9384" class="Symbol">(</a><a id="9385" href="decidability.html#9385" class="Bound">x</a> <a id="9387" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9389" href="decidability.html#9389" class="Bound">y</a><a id="9390" class="Symbol">)</a> <a id="9392" class="Symbol">→</a> <a id="9394" href="decidability.html#9364" class="Bound">h</a> <a id="9396" href="decidability.html#9385" class="Bound">x</a><a id="9397" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9400" href="decidability.html#9400" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9425" class="Symbol">:</a> <a id="9427" class="Symbol">{</a><a id="9428" href="decidability.html#9428" class="Bound">A</a> <a id="9430" href="decidability.html#9430" class="Bound">B</a> <a id="9432" class="Symbol">:</a> <a id="9434" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9438" class="Symbol">}</a>
                         <a id="9465" class="Symbol">→</a> <a id="9467" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9480" href="decidability.html#9428" class="Bound">A</a>
                         <a id="9507" class="Symbol">→</a> <a id="9509" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9522" href="decidability.html#9430" class="Bound">B</a>
                         <a id="9549" class="Symbol">→</a> <a id="9551" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9564" class="Symbol">(</a><a id="9565" href="decidability.html#9428" class="Bound">A</a> <a id="9567" class="Symbol">→</a> <a id="9569" href="decidability.html#9430" class="Bound">B</a><a id="9570" class="Symbol">)</a>
<a id="9572" href="decidability.html#9400" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9597" class="Symbol">_</a>       <a id="9605" class="Symbol">(</a><a id="9606" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9610" href="decidability.html#9610" class="Bound">y</a><a id="9611" class="Symbol">)</a> <a id="9613" class="Symbol">=</a> <a id="9615" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9619" class="Symbol">(λ</a> <a id="9622" href="decidability.html#9622" class="Bound">_</a> <a id="9624" class="Symbol">→</a> <a id="9626" href="decidability.html#9610" class="Bound">y</a><a id="9627" class="Symbol">)</a>
<a id="9629" href="decidability.html#9400" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9654" class="Symbol">(</a><a id="9655" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9659" href="decidability.html#9659" class="Bound">x</a><a id="9660" class="Symbol">)</a> <a id="9662" class="Symbol">(</a><a id="9663" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9667" href="decidability.html#9667" class="Bound">k</a><a id="9668" class="Symbol">)</a> <a id="9670" class="Symbol">=</a> <a id="9672" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9676" class="Symbol">(λ</a> <a id="9679" href="decidability.html#9679" class="Bound">f</a> <a id="9681" class="Symbol">→</a> <a id="9683" href="decidability.html#9667" class="Bound">k</a> <a id="9685" class="Symbol">(</a><a id="9686" href="decidability.html#9679" class="Bound">f</a> <a id="9688" href="decidability.html#9659" class="Bound">x</a><a id="9689" class="Symbol">))</a>
<a id="9692" href="decidability.html#9400" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9717" class="Symbol">(</a><a id="9718" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9722" href="decidability.html#9722" class="Bound">h</a><a id="9723" class="Symbol">)</a> <a id="9725" class="Symbol">(</a><a id="9726" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9730" href="decidability.html#9730" class="Bound">k</a><a id="9731" class="Symbol">)</a> <a id="9733" class="Symbol">=</a> <a id="9735" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9739" class="Symbol">(λ</a> <a id="9742" href="decidability.html#9742" class="Bound">x</a> <a id="9744" class="Symbol">→</a> <a id="9746" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="9753" class="Symbol">(</a><a id="9754" href="decidability.html#9722" class="Bound">h</a> <a id="9756" href="decidability.html#9742" class="Bound">x</a><a id="9757" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="9761" href="decidability.html#9761" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9786" class="Symbol">:</a> <a id="9788" class="Symbol">{</a><a id="9789" href="decidability.html#9789" class="Bound">A</a> <a id="9791" class="Symbol">:</a> <a id="9793" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9797" class="Symbol">}</a>
                         <a id="9824" class="Symbol">→</a> <a id="9826" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9839" href="decidability.html#9789" class="Bound">A</a>
                         <a id="9866" class="Symbol">→</a> <a id="9868" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="9881" class="Symbol">(</a><a id="9882" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="9884" href="decidability.html#9789" class="Bound">A</a><a id="9885" class="Symbol">)</a>
<a id="9887" href="decidability.html#9761" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9912" href="decidability.html#9912" class="Bound">d</a> <a id="9914" class="Symbol">=</a> <a id="9916" href="decidability.html#9400" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9941" href="decidability.html#9912" class="Bound">d</a> <a id="9943" href="decidability.html#8605" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h2 id="exhaustively-searchable-types">Exhaustively searchable
types</h2>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10470" href="decidability.html#10470" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10497" class="Symbol">:</a> <a id="10499" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="10504" class="Symbol">→</a> <a id="10506" href="general-notation.html#683" data-type="Set₂" class="Function">Type₁</a>
<a id="10512" href="decidability.html#10470" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10539" href="decidability.html#10539" class="Bound">X</a> <a id="10541" class="Symbol">=</a> <a id="10543" class="Symbol">(</a><a id="10544" href="decidability.html#10544" class="Bound">A</a> <a id="10546" class="Symbol">:</a> <a id="10548" href="decidability.html#10539" class="Bound">X</a> <a id="10550" class="Symbol">→</a> <a id="10552" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="10556" class="Symbol">)</a>
                             <a id="10587" class="Symbol">→</a> <a id="10589" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10612" href="decidability.html#10544" class="Bound">A</a>
                             <a id="10643" class="Symbol">→</a> <a id="10645" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="10658" class="Symbol">(</a><a id="10659" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="10661" href="decidability.html#10661" class="Bound">x</a> <a id="10663" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="10665" href="decidability.html#10539" class="Bound">X</a> <a id="10667" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="10669" href="decidability.html#10544" class="Bound">A</a> <a id="10671" href="decidability.html#10661" class="Bound">x</a><a id="10672" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12091" href="decidability.html#12091" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12108" class="Symbol">:</a> <a id="12110" class="Symbol">(</a><a id="12111" href="decidability.html#12111" class="Bound">X</a> <a id="12113" class="Symbol">:</a> <a id="12115" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12119" class="Symbol">)</a>
                 <a id="12138" class="Symbol">→</a> <a id="12140" href="decidability.html#10470" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12167" href="decidability.html#12111" class="Bound">X</a>
                 <a id="12186" class="Symbol">→</a> <a id="12188" class="Symbol">(</a><a id="12189" href="decidability.html#12189" class="Bound">A</a> <a id="12191" class="Symbol">:</a> <a id="12193" href="decidability.html#12111" class="Bound">X</a> <a id="12195" class="Symbol">→</a> <a id="12197" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12201" class="Symbol">)</a>
                 <a id="12220" class="Symbol">→</a> <a id="12222" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12245" href="decidability.html#12189" class="Bound">A</a>
                 <a id="12264" class="Symbol">→</a> <a id="12266" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="12279" class="Symbol">(</a><a id="12280" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12282" href="decidability.html#12282" class="Bound">x</a> <a id="12284" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12286" href="decidability.html#12111" class="Bound">X</a> <a id="12288" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12290" href="decidability.html#12189" class="Bound">A</a> <a id="12292" href="decidability.html#12282" class="Bound">x</a><a id="12293" class="Symbol">)</a>
<a id="12295" href="decidability.html#12091" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12312" href="decidability.html#12312" class="Bound">X</a> <a id="12314" href="decidability.html#12314" class="Bound">s</a> <a id="12316" href="decidability.html#12316" class="Bound">A</a> <a id="12318" href="decidability.html#12318" class="Bound">d</a> <a id="12320" class="Symbol">=</a> <a id="12322" href="decidability.html#12806" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12326" class="Keyword">where</a>
  <a id="12334" href="decidability.html#12334" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12336" class="Symbol">:</a> <a id="12338" href="decidability.html#5306" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12361" class="Symbol">(λ</a> <a id="12364" href="decidability.html#12364" class="Bound">x</a> <a id="12366" class="Symbol">→</a> <a id="12368" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12370" class="Symbol">(</a><a id="12371" href="decidability.html#12316" class="Bound">A</a> <a id="12373" href="decidability.html#12364" class="Bound">x</a><a id="12374" class="Symbol">))</a>
  <a id="12379" href="decidability.html#12334" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12381" href="decidability.html#12381" class="Bound">x</a> <a id="12383" class="Symbol">=</a> <a id="12385" href="decidability.html#9761" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12410" class="Symbol">(</a><a id="12411" href="decidability.html#12318" class="Bound">d</a> <a id="12413" href="decidability.html#12381" class="Bound">x</a><a id="12414" class="Symbol">)</a>

  <a id="12419" href="decidability.html#12419" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12422" class="Symbol">:</a> <a id="12424" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="12437" class="Symbol">(</a><a id="12438" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12440" href="decidability.html#12440" class="Bound">x</a> <a id="12442" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12444" href="decidability.html#12312" class="Bound">X</a> <a id="12446" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12448" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12450" class="Symbol">(</a><a id="12451" href="decidability.html#12316" class="Bound">A</a> <a id="12453" href="decidability.html#12440" class="Bound">x</a><a id="12454" class="Symbol">))</a>
  <a id="12459" href="decidability.html#12419" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12462" class="Symbol">=</a> <a id="12464" href="decidability.html#12314" class="Bound">s</a> <a id="12466" class="Symbol">(λ</a> <a id="12469" href="decidability.html#12469" class="Bound">x</a> <a id="12471" class="Symbol">→</a> <a id="12473" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12475" class="Symbol">(</a><a id="12476" href="decidability.html#12316" class="Bound">A</a> <a id="12478" href="decidability.html#12469" class="Bound">x</a><a id="12479" class="Symbol">))</a> <a id="12482" href="decidability.html#12334" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12487" href="decidability.html#12487" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12491" class="Symbol">:</a> <a id="12493" class="Symbol">(</a><a id="12494" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12496" href="decidability.html#12496" class="Bound">x</a> <a id="12498" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12500" href="decidability.html#12312" class="Bound">X</a> <a id="12502" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12504" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12506" class="Symbol">(</a><a id="12507" href="decidability.html#12316" class="Bound">A</a> <a id="12509" href="decidability.html#12496" class="Bound">x</a><a id="12510" class="Symbol">))</a> <a id="12513" class="Symbol">→</a> <a id="12515" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12517" class="Symbol">(</a><a id="12518" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12520" href="decidability.html#12520" class="Bound">x</a> <a id="12522" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12524" href="decidability.html#12312" class="Bound">X</a> <a id="12526" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12528" href="decidability.html#12316" class="Bound">A</a> <a id="12530" href="decidability.html#12520" class="Bound">x</a><a id="12531" class="Symbol">)</a>
  <a id="12535" href="decidability.html#12487" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12539" class="Symbol">(</a><a id="12540" href="decidability.html#12540" class="Bound">x</a> <a id="12542" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12544" href="decidability.html#12544" class="Bound">f</a><a id="12545" class="Symbol">)</a> <a id="12547" href="decidability.html#12547" class="Bound">g</a> <a id="12549" class="Symbol">=</a> <a id="12551" href="decidability.html#12544" class="Bound">f</a> <a id="12553" class="Symbol">(</a><a id="12554" href="decidability.html#12547" class="Bound">g</a> <a id="12556" href="decidability.html#12540" class="Bound">x</a><a id="12557" class="Symbol">)</a>

  <a id="12562" href="decidability.html#12562" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12565" class="Symbol">:</a> <a id="12567" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12569" class="Symbol">(</a><a id="12570" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12572" href="decidability.html#12572" class="Bound">x</a> <a id="12574" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12576" href="decidability.html#12312" class="Bound">X</a> <a id="12578" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12580" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12582" class="Symbol">(</a><a id="12583" href="decidability.html#12316" class="Bound">A</a> <a id="12585" href="decidability.html#12572" class="Bound">x</a><a id="12586" class="Symbol">))</a> <a id="12589" class="Symbol">→</a> <a id="12591" class="Symbol">(</a><a id="12592" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12594" href="decidability.html#12594" class="Bound">x</a> <a id="12596" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12598" href="decidability.html#12312" class="Bound">X</a> <a id="12600" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12602" href="decidability.html#12316" class="Bound">A</a> <a id="12604" href="decidability.html#12594" class="Bound">x</a><a id="12605" class="Symbol">)</a>
  <a id="12609" href="decidability.html#12562" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12612" href="decidability.html#12612" class="Bound">h</a> <a id="12614" href="decidability.html#12614" class="Bound">x</a> <a id="12616" class="Symbol">=</a> <a id="12618" href="decidability.html#12670" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="12624" class="Keyword">where</a>
    <a id="12634" href="decidability.html#12634" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12636" class="Symbol">:</a> <a id="12638" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="12641" href="decidability.html#12316" class="Bound">A</a> <a id="12643" href="decidability.html#12614" class="Bound">x</a>
    <a id="12649" href="decidability.html#12634" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12651" href="decidability.html#12651" class="Bound">f</a> <a id="12653" class="Symbol">=</a> <a id="12655" href="decidability.html#12612" class="Bound">h</a> <a id="12657" class="Symbol">(</a><a id="12658" href="decidability.html#12614" class="Bound">x</a> <a id="12660" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12662" href="decidability.html#12651" class="Bound">f</a><a id="12663" class="Symbol">)</a>

    <a id="12670" href="decidability.html#12670" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12673" class="Symbol">:</a> <a id="12675" href="decidability.html#12316" class="Bound">A</a> <a id="12677" href="decidability.html#12614" class="Bound">x</a>
    <a id="12683" href="decidability.html#12670" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12686" class="Symbol">=</a> <a id="12688" href="decidability.html#2883" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="12696" class="Symbol">(</a><a id="12697" href="decidability.html#12318" class="Bound">d</a> <a id="12699" href="decidability.html#12614" class="Bound">x</a><a id="12700" class="Symbol">)</a> <a id="12702" href="decidability.html#12634" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="12707" href="decidability.html#12707" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12709" class="Symbol">:</a> <a id="12711" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="12724" class="Symbol">(</a><a id="12725" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12727" href="decidability.html#12727" class="Bound">x</a> <a id="12729" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12731" href="decidability.html#12312" class="Bound">X</a> <a id="12733" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12735" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12737" class="Symbol">(</a><a id="12738" href="decidability.html#12316" class="Bound">A</a> <a id="12740" href="decidability.html#12727" class="Bound">x</a><a id="12741" class="Symbol">))</a> <a id="12744" class="Symbol">→</a> <a id="12746" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="12759" class="Symbol">(</a><a id="12760" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12762" href="decidability.html#12762" class="Bound">x</a> <a id="12764" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12766" href="decidability.html#12312" class="Bound">X</a> <a id="12768" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12770" href="decidability.html#12316" class="Bound">A</a> <a id="12772" href="decidability.html#12762" class="Bound">x</a><a id="12773" class="Symbol">)</a>
  <a id="12777" href="decidability.html#12707" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12779" class="Symbol">=</a> <a id="12781" href="decidability.html#8154" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="12796" href="decidability.html#12487" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12800" href="decidability.html#12562" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="12806" href="decidability.html#12806" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12809" class="Symbol">:</a> <a id="12811" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="12824" class="Symbol">(</a><a id="12825" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12827" href="decidability.html#12827" class="Bound">x</a> <a id="12829" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12831" href="decidability.html#12312" class="Bound">X</a> <a id="12833" href="products.html#4084" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12835" href="decidability.html#12316" class="Bound">A</a> <a id="12837" href="decidability.html#12827" class="Bound">x</a><a id="12838" class="Symbol">)</a>
  <a id="12842" href="decidability.html#12806" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12845" class="Symbol">=</a> <a id="12847" href="decidability.html#12707" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12849" href="decidability.html#12419" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h2 id="decidable-equality">Decidable equality</h2>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13375" href="decidability.html#13375" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13398" class="Symbol">:</a> <a id="13400" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="13405" class="Symbol">→</a> <a id="13407" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="13412" href="decidability.html#13375" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13435" href="decidability.html#13435" class="Bound">X</a> <a id="13437" class="Symbol">=</a> <a id="13439" class="Symbol">(</a><a id="13440" href="decidability.html#13440" class="Bound">x</a> <a id="13442" href="decidability.html#13442" class="Bound">y</a> <a id="13444" class="Symbol">:</a> <a id="13446" href="decidability.html#13435" class="Bound">X</a><a id="13447" class="Symbol">)</a> <a id="13449" class="Symbol">→</a> <a id="13451" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="13464" class="Symbol">(</a><a id="13465" href="decidability.html#13440" class="Bound">x</a> <a id="13467" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13469" href="decidability.html#13442" class="Bound">y</a><a id="13470" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="13676" href="decidability.html#13676" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13704" class="Symbol">:</a> <a id="13706" href="decidability.html#13375" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13729" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="13734" href="decidability.html#13676" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13762" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13768" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13774" class="Symbol">=</a> <a id="13776" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13780" class="Symbol">(</a><a id="13781" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13786" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="13790" class="Symbol">)</a>
<a id="13792" href="decidability.html#13676" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13820" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13826" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13832" class="Symbol">=</a> <a id="13834" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13838" href="negation.html#3353" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="13856" href="decidability.html#13676" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13884" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13890" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13896" class="Symbol">=</a> <a id="13898" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13902" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="13920" href="decidability.html#13676" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13948" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13954" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13960" class="Symbol">=</a> <a id="13962" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13966" class="Symbol">(</a><a id="13967" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13972" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="13977" class="Symbol">)</a>

<a id="13980" class="Keyword">open</a> <a id="13985" class="Keyword">import</a> <a id="13992" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14019" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14044" class="Symbol">:</a> <a id="14046" href="decidability.html#13375" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14069" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>
<a id="14071" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14096" class="Number">0</a>       <a id="14104" class="Number">0</a>       <a id="14112" class="Symbol">=</a> <a id="14114" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14118" class="Symbol">(</a><a id="14119" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14124" href="introduction.html#551" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14128" class="Symbol">)</a>
<a id="14130" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14155" class="Number">0</a>       <a id="14163" class="Symbol">(</a><a id="14164" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14168" href="decidability.html#14168" class="Bound">y</a><a id="14169" class="Symbol">)</a> <a id="14171" class="Symbol">=</a> <a id="14173" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14177" href="natural-numbers-functions.html#501" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14193" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14218" class="Symbol">(</a><a id="14219" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14223" href="decidability.html#14223" class="Bound">x</a><a id="14224" class="Symbol">)</a> <a id="14226" class="Number">0</a>       <a id="14234" class="Symbol">=</a> <a id="14236" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14240" href="natural-numbers-functions.html#443" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14256" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14281" class="Symbol">(</a><a id="14282" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14286" href="decidability.html#14286" class="Bound">x</a><a id="14287" class="Symbol">)</a> <a id="14289" class="Symbol">(</a><a id="14290" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14294" href="decidability.html#14294" class="Bound">y</a><a id="14295" class="Symbol">)</a> <a id="14297" class="Symbol">=</a> <a id="14299" href="decidability.html#14473" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14304" class="Keyword">where</a>
  <a id="14312" href="decidability.html#14312" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14315" class="Symbol">:</a> <a id="14317" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="14330" class="Symbol">(</a><a id="14331" href="decidability.html#14286" class="Bound">x</a> <a id="14333" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14335" href="decidability.html#14294" class="Bound">y</a><a id="14336" class="Symbol">)</a>
  <a id="14340" href="decidability.html#14312" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14343" class="Symbol">=</a> <a id="14345" href="decidability.html#14019" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14370" href="decidability.html#14286" class="Bound">x</a> <a id="14372" href="decidability.html#14294" class="Bound">y</a>

  <a id="14377" href="decidability.html#14377" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14379" class="Symbol">:</a> <a id="14381" href="decidability.html#14286" class="Bound">x</a> <a id="14383" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14385" href="decidability.html#14294" class="Bound">y</a> <a id="14387" class="Symbol">→</a> <a id="14389" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14393" href="decidability.html#14286" class="Bound">x</a> <a id="14395" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14397" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14401" href="decidability.html#14294" class="Bound">y</a>
  <a id="14405" href="decidability.html#14377" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14407" class="Symbol">=</a> <a id="14409" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14412" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14419" href="decidability.html#14419" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14422" class="Symbol">:</a> <a id="14424" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14428" href="decidability.html#14286" class="Bound">x</a> <a id="14430" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14432" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14436" href="decidability.html#14294" class="Bound">y</a> <a id="14438" class="Symbol">→</a> <a id="14440" href="decidability.html#14286" class="Bound">x</a> <a id="14442" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14444" href="decidability.html#14294" class="Bound">y</a>
  <a id="14448" href="decidability.html#14419" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14451" class="Symbol">=</a> <a id="14453" href="natural-numbers-functions.html#607" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14473" href="decidability.html#14473" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14477" class="Symbol">:</a> <a id="14479" href="decidability.html#2608" data-type="Type → Type" class="Function">is-decidable</a> <a id="14492" class="Symbol">(</a><a id="14493" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14497" href="decidability.html#14286" class="Bound">x</a> <a id="14499" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14501" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14505" href="decidability.html#14294" class="Bound">y</a><a id="14506" class="Symbol">)</a>
  <a id="14510" href="decidability.html#14473" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14514" class="Symbol">=</a> <a id="14516" href="decidability.html#7804" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14530" href="decidability.html#14377" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14532" href="decidability.html#14419" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14535" href="decidability.html#14312" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h2 id="equality-of-functions">Equality of functions</h2>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="14823" class="Keyword">private</a>
 <a id="f"></a><a id="14832" href="decidability.html#14832" class="Function">f</a> <a id="g"></a><a id="14834" href="decidability.html#14834" class="Function">g</a> <a id="h"></a><a id="14836" href="decidability.html#14836" class="Function">h</a> <a id="14838" class="Symbol">:</a> <a id="14840" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="14842" class="Symbol">→</a> <a id="14844" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>

 <a id="14848" href="decidability.html#14832" class="Function">f</a> <a id="14850" href="decidability.html#14850" class="Bound">x</a> <a id="14852" class="Symbol">=</a> <a id="14854" href="decidability.html#14850" class="Bound">x</a>

 <a id="14858" href="decidability.html#14834" class="Function">g</a> <a id="14860" class="Number">0</a>       <a id="14868" class="Symbol">=</a> <a id="14870" class="Number">0</a>
 <a id="14873" href="decidability.html#14834" class="Function">g</a> <a id="14875" class="Symbol">(</a><a id="14876" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14880" href="decidability.html#14880" class="Bound">x</a><a id="14881" class="Symbol">)</a> <a id="14883" class="Symbol">=</a> <a id="14885" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14889" class="Symbol">(</a><a id="14890" href="decidability.html#14834" class="Function">g</a> <a id="14892" href="decidability.html#14880" class="Bound">x</a><a id="14893" class="Symbol">)</a>

 <a id="14897" href="decidability.html#14836" class="Function">h</a> <a id="14899" href="decidability.html#14899" class="Bound">x</a> <a id="14901" class="Symbol">=</a> <a id="14903" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14907" href="decidability.html#14899" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="14911" href="decidability.html#14911" class="Function">f-equals-g</a> <a id="14922" class="Symbol">:</a> <a id="14924" href="decidability.html#14832" class="Function">f</a> <a id="14926" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="14928" href="decidability.html#14834" class="Function">g</a>
 <a id="14931" href="decidability.html#14911" class="Function">f-equals-g</a> <a id="14942" class="Number">0</a>       <a id="14950" class="Symbol">=</a> <a id="14952" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14957" class="Symbol">(</a><a id="14958" href="decidability.html#14832" class="Function">f</a> <a id="14960" class="Number">0</a><a id="14961" class="Symbol">)</a>
 <a id="14964" href="decidability.html#14911" class="Function">f-equals-g</a> <a id="14975" class="Symbol">(</a><a id="14976" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14980" href="decidability.html#14980" class="Bound">x</a><a id="14981" class="Symbol">)</a> <a id="14983" class="Symbol">=</a> <a id="14985" href="decidability.html#15041" class="Function">goal</a>
  <a id="14992" class="Keyword">where</a>
   <a id="15001" href="decidability.html#15001" class="Function">IH</a> <a id="15004" class="Symbol">:</a> <a id="15006" href="decidability.html#14832" class="Function">f</a> <a id="15008" href="decidability.html#14980" class="Bound">x</a> <a id="15010" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15012" href="decidability.html#14834" class="Function">g</a> <a id="15014" href="decidability.html#14980" class="Bound">x</a>
   <a id="15019" href="decidability.html#15001" class="Function">IH</a> <a id="15022" class="Symbol">=</a> <a id="15024" href="decidability.html#14911" class="Function">f-equals-g</a> <a id="15035" href="decidability.html#14980" class="Bound">x</a>

   <a id="15041" href="decidability.html#15041" class="Function">goal</a> <a id="15046" class="Symbol">:</a> <a id="15048" href="decidability.html#14832" class="Function">f</a> <a id="15050" class="Symbol">(</a><a id="15051" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15055" href="decidability.html#14980" class="Bound">x</a><a id="15056" class="Symbol">)</a> <a id="15058" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15060" href="decidability.html#14834" class="Function">g</a> <a id="15062" class="Symbol">(</a><a id="15063" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15067" href="decidability.html#14980" class="Bound">x</a><a id="15068" class="Symbol">)</a>
   <a id="15073" href="decidability.html#15041" class="Function">goal</a> <a id="15078" class="Symbol">=</a> <a id="15080" href="decidability.html#14832" class="Function">f</a> <a id="15082" class="Symbol">(</a><a id="15083" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15087" href="decidability.html#14980" class="Bound">x</a><a id="15088" class="Symbol">)</a> <a id="15090" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15093" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15098" class="Symbol">_</a> <a id="15100" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15112" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15116" href="decidability.html#14980" class="Bound">x</a>     <a id="15122" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15125" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15130" class="Symbol">_</a> <a id="15132" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15144" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15148" class="Symbol">(</a><a id="15149" href="decidability.html#14832" class="Function">f</a> <a id="15151" href="decidability.html#14980" class="Bound">x</a><a id="15152" class="Symbol">)</a> <a id="15154" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15157" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15160" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15164" href="decidability.html#15001" class="Function">IH</a> <a id="15167" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15179" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15183" class="Symbol">(</a><a id="15184" href="decidability.html#14834" class="Function">g</a> <a id="15186" href="decidability.html#14980" class="Bound">x</a><a id="15187" class="Symbol">)</a> <a id="15189" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15192" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15197" class="Symbol">_</a> <a id="15199" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
          <a id="15211" href="decidability.html#14834" class="Function">g</a> <a id="15213" class="Symbol">(</a><a id="15214" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15218" href="decidability.html#14980" class="Bound">x</a><a id="15219" class="Symbol">)</a> <a id="15221" href="identity-type.html#4194" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15225" href="decidability.html#15225" class="Function">f-not-equals-h</a> <a id="15240" class="Symbol">:</a> <a id="15242" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15244" class="Symbol">(</a><a id="15245" href="decidability.html#14832" class="Function">f</a> <a id="15247" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15249" href="decidability.html#14836" class="Function">h</a><a id="15250" class="Symbol">)</a>
 <a id="15253" href="decidability.html#15225" class="Function">f-not-equals-h</a> <a id="15268" href="decidability.html#15268" class="Bound">e</a> <a id="15270" class="Symbol">=</a> <a id="15272" href="decidability.html#15324" class="Function">contradiction</a> <a id="15286" href="decidability.html#15299" class="Function">d</a>
  <a id="15290" class="Keyword">where</a>
   <a id="15299" href="decidability.html#15299" class="Function">d</a> <a id="15301" class="Symbol">:</a> <a id="15303" class="Number">0</a> <a id="15305" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15307" class="Number">1</a>
   <a id="15312" href="decidability.html#15299" class="Function">d</a> <a id="15314" class="Symbol">=</a> <a id="15316" href="decidability.html#15268" class="Bound">e</a> <a id="15318" class="Number">0</a>

   <a id="15324" href="decidability.html#15324" class="Function">contradiction</a> <a id="15338" class="Symbol">:</a> <a id="15340" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15342" class="Symbol">(</a><a id="15343" class="Number">0</a> <a id="15345" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15347" class="Number">1</a><a id="15348" class="Symbol">)</a>
   <a id="15353" href="decidability.html#15324" class="Function">contradiction</a> <a id="15367" class="Symbol">()</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip; }

div#post-toc-container { max-width: 120ch; margin: auto; }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg); 
  font-size: var(--code-font-size); }

</html>
