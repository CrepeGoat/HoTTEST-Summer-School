<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module <a
href="https://program-and-modules-handbook.bham.ac.uk/webhandbooks/WebHandbooks-control-servlet?Action=getModuleDetailsList%22Advanced%20Functional%20Programming%22pgSubj=06%22Advanced%20Functional%20Programming%22pgCrse=35309%22Advanced%20Functional%20Programming%22searchTerm=002022">Advanced
Functional Programmin</a> at the <a
href="https://www.birmingham.ac.uk/schools/computer-science/index.aspx">School
of Computer Science</a> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="579" class="Symbol">{-#</a> <a id="583" class="Keyword">OPTIONS</a> <a id="591" class="Pragma">--without-K</a> <a id="603" class="Pragma">--safe</a> <a id="610" class="Symbol">#-}</a>

<a id="615" class="Keyword">module</a> <a id="622" href="decidability.html" class="Module">decidability</a> <a id="635" class="Keyword">where</a>

<a id="642" class="Keyword">open</a> <a id="647" class="Keyword">import</a> <a id="654" href="prelude.html" class="Module">prelude</a>
<a id="662" class="Keyword">open</a> <a id="667" class="Keyword">import</a> <a id="674" href="negation.html" class="Module">negation</a>
<a id="683" class="Keyword">open</a> <a id="688" class="Keyword">import</a> <a id="695" href="natural-numbers-type.html" class="Module">natural-numbers-type</a>
</pre>-->
<h1
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h1>
<p>When programming in conventional programming languages such as
Haskell, C, Java, Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h2 id="discussion-and-motivation">Discussion and motivation</h2>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h2 id="decidable-propositions">Decidable propositions</h2>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2992" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="3005" class="Symbol">:</a> <a id="3007" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a> <a id="3012" class="Symbol">→</a> <a id="3014" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a>
<a id="3019" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="3032" href="decidability.html#3032" class="Bound">A</a> <a id="3034" class="Symbol">=</a> <a id="3036" href="decidability.html#3032" class="Bound">A</a> <a id="3038" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3040" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="3042" href="decidability.html#3032" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="3267" href="decidability.html#3267" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3275" class="Symbol">:</a> <a id="3277" class="Symbol">{</a><a id="3278" href="decidability.html#3278" class="Bound">A</a> <a id="3280" class="Symbol">:</a> <a id="3282" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3286" class="Symbol">}</a> <a id="3288" class="Symbol">→</a> <a id="3290" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="3303" href="decidability.html#3278" class="Bound">A</a> <a id="3305" class="Symbol">→</a> <a id="3307" href="negation.html#2352" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="3310" href="decidability.html#3278" class="Bound">A</a> <a id="3312" class="Symbol">→</a> <a id="3314" href="decidability.html#3278" class="Bound">A</a>
<a id="3316" href="decidability.html#3267" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3324" class="Symbol">(</a><a id="3325" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3329" href="decidability.html#3329" class="Bound">x</a><a id="3330" class="Symbol">)</a> <a id="3332" href="decidability.html#3332" class="Bound">f</a> <a id="3334" class="Symbol">=</a> <a id="3336" href="decidability.html#3329" class="Bound">x</a>
<a id="3338" href="decidability.html#3267" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3346" class="Symbol">(</a><a id="3347" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3351" href="decidability.html#3351" class="Bound">g</a><a id="3352" class="Symbol">)</a> <a id="3354" href="decidability.html#3354" class="Bound">f</a> <a id="3356" class="Symbol">=</a> <a id="3358" href="empty-type.html#2126" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3365" class="Symbol">(</a><a id="3366" href="decidability.html#3354" class="Bound">f</a> <a id="3368" href="decidability.html#3351" class="Bound">g</a><a id="3369" class="Symbol">)</a>
</pre>
<h2 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h2>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3797" href="decidability.html#3797" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3824" class="Symbol">:</a> <a id="3826" class="Symbol">(</a><a id="3827" href="decidability.html#3827" class="Bound">A</a> <a id="3829" class="Symbol">:</a> <a id="3831" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3835" class="Symbol">)</a> <a id="3837" class="Symbol">→</a> <a id="3839" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="3852" href="decidability.html#3827" class="Bound">A</a> <a id="3854" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3856" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3858" href="decidability.html#3858" class="Bound">b</a> <a id="3860" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3862" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="3867" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3869" class="Symbol">(</a><a id="3870" href="decidability.html#3827" class="Bound">A</a> <a id="3872" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3874" href="decidability.html#3858" class="Bound">b</a> <a id="3876" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3878" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="3882" class="Symbol">)</a>
<a id="3884" href="decidability.html#3797" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3911" href="decidability.html#3911" class="Bound">A</a> <a id="3913" class="Symbol">=</a> <a id="3915" href="decidability.html#3930" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3917" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3919" href="decidability.html#4224" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3922" class="Keyword">where</a>
  <a id="3930" href="decidability.html#3930" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3932" class="Symbol">:</a> <a id="3934" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="3947" href="decidability.html#3911" class="Bound">A</a> <a id="3949" class="Symbol">→</a> <a id="3951" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3953" href="decidability.html#3953" class="Bound">b</a> <a id="3955" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3957" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="3962" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3964" class="Symbol">(</a><a id="3965" href="decidability.html#3911" class="Bound">A</a> <a id="3967" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3969" href="decidability.html#3953" class="Bound">b</a> <a id="3971" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3973" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="3977" class="Symbol">)</a>
  <a id="3981" href="decidability.html#3930" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3983" class="Symbol">(</a><a id="3984" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3988" href="decidability.html#3988" class="Bound">x</a><a id="3989" class="Symbol">)</a> <a id="3991" class="Symbol">=</a> <a id="3993" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="3998" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4000" class="Symbol">(</a><a id="4001" href="decidability.html#4021" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="4003" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4005" href="decidability.html#4066" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="4006" class="Symbol">)</a>
   <a id="4011" class="Keyword">where</a>
    <a id="4021" href="decidability.html#4021" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="4023" class="Symbol">:</a> <a id="4025" href="decidability.html#3911" class="Bound">A</a> <a id="4027" class="Symbol">→</a> <a id="4029" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="4034" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4036" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="4045" href="decidability.html#4021" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="4047" class="Symbol">_</a> <a id="4049" class="Symbol">=</a> <a id="4051" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4056" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="4066" href="decidability.html#4066" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="4068" class="Symbol">:</a> <a id="4070" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="4075" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4077" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="4082" class="Symbol">→</a> <a id="4084" href="decidability.html#3911" class="Bound">A</a>
    <a id="4090" href="decidability.html#4066" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="4092" class="Symbol">_</a> <a id="4094" class="Symbol">=</a> <a id="4096" href="decidability.html#3988" class="Bound">x</a>

  <a id="4101" href="decidability.html#3930" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="4103" class="Symbol">(</a><a id="4104" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4108" href="decidability.html#4108" class="Bound">ν</a><a id="4109" class="Symbol">)</a> <a id="4111" class="Symbol">=</a> <a id="4113" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="4119" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4121" class="Symbol">(</a><a id="4122" href="decidability.html#4142" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="4124" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4126" href="decidability.html#4191" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="4127" class="Symbol">)</a>
   <a id="4132" class="Keyword">where</a>
    <a id="4142" href="decidability.html#4142" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="4144" class="Symbol">:</a> <a id="4146" href="decidability.html#3911" class="Bound">A</a> <a id="4148" class="Symbol">→</a> <a id="4150" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="4156" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4158" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="4167" href="decidability.html#4142" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="4169" href="decidability.html#4169" class="Bound">x</a> <a id="4171" class="Symbol">=</a> <a id="4173" href="empty-type.html#2126" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="4180" class="Symbol">(</a><a id="4181" href="decidability.html#4108" class="Bound">ν</a> <a id="4183" href="decidability.html#4169" class="Bound">x</a><a id="4184" class="Symbol">)</a>

    <a id="4191" href="decidability.html#4191" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="4193" class="Symbol">:</a> <a id="4195" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="4201" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4203" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="4208" class="Symbol">→</a> <a id="4210" href="decidability.html#3911" class="Bound">A</a>
    <a id="4216" href="decidability.html#4191" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="4218" class="Symbol">()</a>

  <a id="4224" href="decidability.html#4224" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="4226" class="Symbol">:</a> <a id="4228" class="Symbol">(</a><a id="4229" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4231" href="decidability.html#4231" class="Bound">b</a> <a id="4233" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4235" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="4240" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4242" class="Symbol">(</a><a id="4243" href="decidability.html#3911" class="Bound">A</a> <a id="4245" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="4247" href="decidability.html#4231" class="Bound">b</a> <a id="4249" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4251" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="4255" class="Symbol">))</a> <a id="4258" class="Symbol">→</a> <a id="4260" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="4273" href="decidability.html#3911" class="Bound">A</a>
  <a id="4277" href="decidability.html#4224" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="4279" class="Symbol">(</a><a id="4280" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="4285" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="4288" href="decidability.html#4288" class="Bound">α</a> <a id="4290" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4292" href="decidability.html#4292" class="Bound">β</a><a id="4293" class="Symbol">)</a> <a id="4295" class="Symbol">=</a> <a id="4297" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="4301" class="Symbol">(</a><a id="4302" href="decidability.html#4292" class="Bound">β</a> <a id="4304" class="Symbol">(</a><a id="4305" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4310" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="4314" class="Symbol">))</a>
  <a id="4319" href="decidability.html#4224" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="4321" class="Symbol">(</a><a id="4322" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="4328" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4330" href="decidability.html#4330" class="Bound">α</a> <a id="4332" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4334" href="decidability.html#4334" class="Bound">β</a><a id="4335" class="Symbol">)</a> <a id="4337" class="Symbol">=</a> <a id="4339" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4343" class="Symbol">(λ</a> <a id="4346" href="decidability.html#4346" class="Bound">x</a> <a id="4348" class="Symbol">→</a> <a id="4350" href="negation.html#3699" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="4368" class="Symbol">(</a><a id="4369" href="decidability.html#4330" class="Bound">α</a> <a id="4371" href="decidability.html#4346" class="Bound">x</a><a id="4372" class="Symbol">))</a>
</pre>
<h2 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h2>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is even. <!--
<pre class="Agda"><a id="4896" class="Keyword">module</a> <a id="4903" href="decidability.html#4903" class="Module">_</a> <a id="4905" class="Keyword">where</a>
 <a id="4912" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4938" href="decidability.html#4938" class="Function">is-even</a> <a id="4946" class="Symbol">:</a> <a id="4948" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a> <a id="4950" class="Symbol">→</a> <a id="4952" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a>
  <a id="4959" href="decidability.html#4938" class="Function">is-even</a> <a id="4967" href="decidability.html#4967" class="Bound">x</a> <a id="4969" class="Symbol">=</a> <a id="4971" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4973" href="decidability.html#4973" class="Bound">y</a> <a id="4975" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4977" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a> <a id="4979" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4981" href="decidability.html#4967" class="Bound">x</a> <a id="4983" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4985" class="Number">2</a> <a id="4987" href="natural-numbers-type.html#3291" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4989" href="decidability.html#4973" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="5191" href="decidability.html#5191" class="Function">check-even</a> <a id="5202" class="Symbol">:</a> <a id="5204" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a> <a id="5206" class="Symbol">→</a> <a id="5208" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a>
  <a id="5215" href="decidability.html#5191" class="Function">check-even</a> <a id="5226" class="Number">0</a>       <a id="5234" class="Symbol">=</a> <a id="5236" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="5243" href="decidability.html#5191" class="Function">check-even</a> <a id="5254" class="Symbol">(</a><a id="5255" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="5259" href="decidability.html#5259" class="Bound">x</a><a id="5260" class="Symbol">)</a> <a id="5262" class="Symbol">=</a> <a id="5264" href="Bool.html#4408" data-type="Bool → Bool" class="Function">not</a> <a id="5268" class="Symbol">(</a><a id="5269" href="decidability.html#5191" class="Function">check-even</a> <a id="5280" href="decidability.html#5259" class="Bound">x</a><a id="5281" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5691" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5714" class="Symbol">:</a> <a id="5716" class="Symbol">{</a><a id="5717" href="decidability.html#5717" class="Bound">X</a> <a id="5719" class="Symbol">:</a> <a id="5721" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="5725" class="Symbol">}</a> <a id="5727" class="Symbol">→</a> <a id="5729" class="Symbol">(</a><a id="5730" href="decidability.html#5717" class="Bound">X</a> <a id="5732" class="Symbol">→</a> <a id="5734" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="5738" class="Symbol">)</a> <a id="5740" class="Symbol">→</a> <a id="5742" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a>
<a id="5747" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5770" class="Symbol">{</a><a id="5771" href="decidability.html#5771" class="Bound">X</a><a id="5772" class="Symbol">}</a> <a id="5774" href="decidability.html#5774" class="Bound">A</a> <a id="5776" class="Symbol">=</a> <a id="5778" class="Symbol">(</a><a id="5779" href="decidability.html#5779" class="Bound">x</a> <a id="5781" class="Symbol">:</a> <a id="5783" href="decidability.html#5771" class="Bound">X</a><a id="5784" class="Symbol">)</a> <a id="5786" class="Symbol">→</a> <a id="5788" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="5801" class="Symbol">(</a><a id="5802" href="decidability.html#5774" class="Bound">A</a> <a id="5804" href="decidability.html#5779" class="Bound">x</a><a id="5805" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="6329" href="decidability.html#6329" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6366" class="Symbol">:</a> <a id="6368" class="Symbol">{</a><a id="6369" href="decidability.html#6369" class="Bound">X</a> <a id="6371" class="Symbol">:</a> <a id="6373" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="6377" class="Symbol">}</a> <a id="6379" class="Symbol">(</a><a id="6380" href="decidability.html#6380" class="Bound">A</a> <a id="6382" class="Symbol">:</a> <a id="6384" href="decidability.html#6369" class="Bound">X</a> <a id="6386" class="Symbol">→</a> <a id="6388" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="6392" class="Symbol">)</a>
                                     <a id="6431" class="Symbol">→</a> <a id="6433" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6456" href="decidability.html#6380" class="Bound">A</a>
                                     <a id="6495" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6497" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6499" href="decidability.html#6499" class="Bound">α</a> <a id="6501" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6503" class="Symbol">(</a><a id="6504" href="decidability.html#6369" class="Bound">X</a> <a id="6506" class="Symbol">→</a> <a id="6508" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a><a id="6512" class="Symbol">)</a> <a id="6514" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6516" class="Symbol">((</a><a id="6518" href="decidability.html#6518" class="Bound">x</a> <a id="6520" class="Symbol">:</a> <a id="6522" href="decidability.html#6369" class="Bound">X</a><a id="6523" class="Symbol">)</a> <a id="6525" class="Symbol">→</a> <a id="6527" href="decidability.html#6380" class="Bound">A</a> <a id="6529" href="decidability.html#6518" class="Bound">x</a> <a id="6531" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6533" href="decidability.html#6499" class="Bound">α</a> <a id="6535" href="decidability.html#6518" class="Bound">x</a> <a id="6537" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6539" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="6543" class="Symbol">)</a>
<a id="6545" href="decidability.html#6329" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6582" class="Symbol">{</a><a id="6583" href="decidability.html#6583" class="Bound">X</a><a id="6584" class="Symbol">}</a> <a id="6586" href="decidability.html#6586" class="Bound">A</a> <a id="6588" class="Symbol">=</a> <a id="6590" href="decidability.html#6605" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6592" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6594" href="decidability.html#7250" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6597" class="Keyword">where</a>
  <a id="6605" href="decidability.html#6605" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6607" class="Symbol">:</a> <a id="6609" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6632" href="decidability.html#6586" class="Bound">A</a> <a id="6634" class="Symbol">→</a> <a id="6636" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6638" href="decidability.html#6638" class="Bound">α</a> <a id="6640" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6642" class="Symbol">(</a><a id="6643" href="decidability.html#6583" class="Bound">X</a> <a id="6645" class="Symbol">→</a> <a id="6647" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a><a id="6651" class="Symbol">)</a> <a id="6653" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6655" class="Symbol">((</a><a id="6657" href="decidability.html#6657" class="Bound">x</a> <a id="6659" class="Symbol">:</a> <a id="6661" href="decidability.html#6583" class="Bound">X</a><a id="6662" class="Symbol">)</a> <a id="6664" class="Symbol">→</a> <a id="6666" href="decidability.html#6586" class="Bound">A</a> <a id="6668" href="decidability.html#6657" class="Bound">x</a> <a id="6670" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6672" href="decidability.html#6638" class="Bound">α</a> <a id="6674" href="decidability.html#6657" class="Bound">x</a> <a id="6676" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6678" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="6682" class="Symbol">)</a>
  <a id="6686" href="decidability.html#6605" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6688" href="decidability.html#6688" class="Bound">d</a> <a id="6690" class="Symbol">=</a> <a id="6692" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6694" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6696" href="decidability.html#6883" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6701" class="Keyword">where</a>
    <a id="6711" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6713" class="Symbol">:</a> <a id="6715" href="decidability.html#6583" class="Bound">X</a> <a id="6717" class="Symbol">→</a> <a id="6719" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a>
    <a id="6728" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6730" href="decidability.html#6730" class="Bound">x</a> <a id="6732" class="Symbol">=</a> <a id="6734" href="sums.html#2892" data-type="Σ B → A" class="Field">pr₁</a> <a id="6738" class="Symbol">(</a><a id="6739" href="binary-products.html#1918" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6754" href="decidability.html#6780" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6756" class="Symbol">(</a><a id="6757" href="decidability.html#6688" class="Bound">d</a> <a id="6759" href="decidability.html#6730" class="Bound">x</a><a id="6760" class="Symbol">))</a>
     <a id="6768" class="Keyword">where</a>
      <a id="6780" href="decidability.html#6780" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6782" class="Symbol">:</a> <a id="6784" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="6797" class="Symbol">(</a><a id="6798" href="decidability.html#6586" class="Bound">A</a> <a id="6800" href="decidability.html#6730" class="Bound">x</a><a id="6801" class="Symbol">)</a> <a id="6803" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6805" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6807" href="decidability.html#6807" class="Bound">b</a> <a id="6809" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6811" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="6816" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6818" class="Symbol">(</a><a id="6819" href="decidability.html#6586" class="Bound">A</a> <a id="6821" href="decidability.html#6730" class="Bound">x</a> <a id="6823" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6825" href="decidability.html#6807" class="Bound">b</a> <a id="6827" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6829" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="6833" class="Symbol">)</a>
      <a id="6841" href="decidability.html#6780" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6843" class="Symbol">=</a> <a id="6845" href="decidability.html#3797" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6872" class="Symbol">(</a><a id="6873" href="decidability.html#6586" class="Bound">A</a> <a id="6875" href="decidability.html#6730" class="Bound">x</a><a id="6876" class="Symbol">)</a>

    <a id="6883" href="decidability.html#6883" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6885" class="Symbol">:</a> <a id="6887" class="Symbol">(</a><a id="6888" href="decidability.html#6888" class="Bound">x</a> <a id="6890" class="Symbol">:</a> <a id="6892" href="decidability.html#6583" class="Bound">X</a><a id="6893" class="Symbol">)</a> <a id="6895" class="Symbol">→</a> <a id="6897" href="decidability.html#6586" class="Bound">A</a> <a id="6899" href="decidability.html#6888" class="Bound">x</a> <a id="6901" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6903" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6905" href="decidability.html#6888" class="Bound">x</a> <a id="6907" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6909" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6918" href="decidability.html#6883" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6920" href="decidability.html#6920" class="Bound">x</a> <a id="6922" class="Symbol">=</a> <a id="6924" href="decidability.html#7130" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6926" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6928" href="decidability.html#7192" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6935" class="Keyword">where</a>
      <a id="6947" href="decidability.html#6947" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6949" class="Symbol">:</a> <a id="6951" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="6964" class="Symbol">(</a><a id="6965" href="decidability.html#6586" class="Bound">A</a> <a id="6967" href="decidability.html#6920" class="Bound">x</a><a id="6968" class="Symbol">)</a> <a id="6970" class="Symbol">→</a> <a id="6972" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6974" href="decidability.html#6974" class="Bound">b</a> <a id="6976" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6978" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="6983" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6985" class="Symbol">(</a><a id="6986" href="decidability.html#6586" class="Bound">A</a> <a id="6988" href="decidability.html#6920" class="Bound">x</a> <a id="6990" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6992" href="decidability.html#6974" class="Bound">b</a> <a id="6994" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6996" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="7000" class="Symbol">)</a>
      <a id="7008" href="decidability.html#6947" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="7010" class="Symbol">=</a> <a id="7012" href="binary-products.html#1918" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="7027" class="Symbol">(</a><a id="7028" href="decidability.html#3797" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7055" class="Symbol">(</a><a id="7056" href="decidability.html#6586" class="Bound">A</a> <a id="7058" href="decidability.html#6920" class="Bound">x</a><a id="7059" class="Symbol">))</a>

      <a id="7069" href="decidability.html#7069" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7072" class="Symbol">:</a> <a id="7074" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7076" href="decidability.html#7076" class="Bound">b</a> <a id="7078" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7080" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="7085" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7087" class="Symbol">(</a><a id="7088" href="decidability.html#6586" class="Bound">A</a> <a id="7090" href="decidability.html#6920" class="Bound">x</a> <a id="7092" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7094" href="decidability.html#7076" class="Bound">b</a> <a id="7096" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7098" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="7102" class="Symbol">)</a>
      <a id="7110" href="decidability.html#7069" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7113" class="Symbol">=</a> <a id="7115" href="decidability.html#6947" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="7117" class="Symbol">(</a><a id="7118" href="decidability.html#6688" class="Bound">d</a> <a id="7120" href="decidability.html#6920" class="Bound">x</a><a id="7121" class="Symbol">)</a>

      <a id="7130" href="decidability.html#7130" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="7132" class="Symbol">:</a> <a id="7134" href="decidability.html#6586" class="Bound">A</a> <a id="7136" href="decidability.html#6920" class="Bound">x</a> <a id="7138" class="Symbol">→</a> <a id="7140" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="7142" href="decidability.html#6920" class="Bound">x</a> <a id="7144" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7146" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="7157" href="decidability.html#7130" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="7159" class="Symbol">=</a> <a id="7161" href="binary-products.html#1918" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="7176" class="Symbol">(</a><a id="7177" href="sums.html#2902" data-type="(r : Σ B) → B (pr₁ r)" class="Field">pr₂</a> <a id="7181" href="decidability.html#7069" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="7183" class="Symbol">)</a>

      <a id="7192" href="decidability.html#7192" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="7194" class="Symbol">:</a> <a id="7196" href="decidability.html#6711" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="7198" href="decidability.html#6920" class="Bound">x</a> <a id="7200" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7202" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a> <a id="7207" class="Symbol">→</a> <a id="7209" href="decidability.html#6586" class="Bound">A</a> <a id="7211" href="decidability.html#6920" class="Bound">x</a>
      <a id="7219" href="decidability.html#7192" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="7221" class="Symbol">=</a> <a id="7223" href="binary-products.html#1990" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7238" class="Symbol">(</a><a id="7239" href="sums.html#2902" data-type="(r : Σ B) → B (pr₁ r)" class="Field">pr₂</a> <a id="7243" href="decidability.html#7069" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="7245" class="Symbol">)</a>

  <a id="7250" href="decidability.html#7250" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="7252" class="Symbol">:</a> <a id="7254" class="Symbol">(</a><a id="7255" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7257" href="decidability.html#7257" class="Bound">α</a> <a id="7259" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7261" class="Symbol">(</a><a id="7262" href="decidability.html#6583" class="Bound">X</a> <a id="7264" class="Symbol">→</a> <a id="7266" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a><a id="7270" class="Symbol">)</a> <a id="7272" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7274" class="Symbol">((</a><a id="7276" href="decidability.html#7276" class="Bound">x</a> <a id="7278" class="Symbol">:</a> <a id="7280" href="decidability.html#6583" class="Bound">X</a><a id="7281" class="Symbol">)</a> <a id="7283" class="Symbol">→</a> <a id="7285" href="decidability.html#6586" class="Bound">A</a> <a id="7287" href="decidability.html#7276" class="Bound">x</a> <a id="7289" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7291" href="decidability.html#7257" class="Bound">α</a> <a id="7293" href="decidability.html#7276" class="Bound">x</a> <a id="7295" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7297" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="7301" class="Symbol">))</a> <a id="7304" class="Symbol">→</a> <a id="7306" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7329" href="decidability.html#6586" class="Bound">A</a>
  <a id="7333" href="decidability.html#7250" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="7335" class="Symbol">(</a><a id="7336" href="decidability.html#7336" class="Bound">α</a> <a id="7338" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7340" href="decidability.html#7340" class="Bound">ϕ</a><a id="7341" class="Symbol">)</a> <a id="7343" class="Symbol">=</a> <a id="7345" href="decidability.html#7360" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="7350" class="Keyword">where</a>
    <a id="7360" href="decidability.html#7360" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7362" class="Symbol">:</a> <a id="7364" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7387" href="decidability.html#6586" class="Bound">A</a>
    <a id="7393" href="decidability.html#7360" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7395" href="decidability.html#7395" class="Bound">x</a> <a id="7397" class="Symbol">=</a> <a id="7399" href="decidability.html#7609" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7408" class="Keyword">where</a>
      <a id="7420" href="decidability.html#7420" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7422" class="Symbol">:</a> <a id="7424" class="Symbol">(</a><a id="7425" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7427" href="decidability.html#7427" class="Bound">b</a> <a id="7429" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7431" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="7436" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7438" class="Symbol">(</a><a id="7439" href="decidability.html#6586" class="Bound">A</a> <a id="7441" href="decidability.html#7395" class="Bound">x</a> <a id="7443" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7445" href="decidability.html#7427" class="Bound">b</a> <a id="7447" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7449" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="7453" class="Symbol">))</a> <a id="7456" class="Symbol">→</a> <a id="7458" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="7471" class="Symbol">(</a><a id="7472" href="decidability.html#6586" class="Bound">A</a> <a id="7474" href="decidability.html#7395" class="Bound">x</a><a id="7475" class="Symbol">)</a>
      <a id="7483" href="decidability.html#7420" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7485" class="Symbol">=</a> <a id="7487" href="binary-products.html#1990" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7502" class="Symbol">(</a><a id="7503" href="decidability.html#3797" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7530" class="Symbol">(</a><a id="7531" href="decidability.html#6586" class="Bound">A</a> <a id="7533" href="decidability.html#7395" class="Bound">x</a><a id="7534" class="Symbol">))</a>

      <a id="7544" href="decidability.html#7544" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7547" class="Symbol">:</a> <a id="7549" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7551" href="decidability.html#7551" class="Bound">b</a> <a id="7553" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7555" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a> <a id="7560" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7562" class="Symbol">(</a><a id="7563" href="decidability.html#6586" class="Bound">A</a> <a id="7565" href="decidability.html#7395" class="Bound">x</a> <a id="7567" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7569" href="decidability.html#7551" class="Bound">b</a> <a id="7571" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7573" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="7577" class="Symbol">)</a>
      <a id="7585" href="decidability.html#7544" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7588" class="Symbol">=</a> <a id="7590" class="Symbol">(</a><a id="7591" href="decidability.html#7336" class="Bound">α</a> <a id="7593" href="decidability.html#7395" class="Bound">x</a> <a id="7595" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7597" href="decidability.html#7340" class="Bound">ϕ</a> <a id="7599" href="decidability.html#7395" class="Bound">x</a><a id="7600" class="Symbol">)</a>

      <a id="7609" href="decidability.html#7609" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7613" class="Symbol">:</a> <a id="7615" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="7628" class="Symbol">(</a><a id="7629" href="decidability.html#6586" class="Bound">A</a> <a id="7631" href="decidability.html#7395" class="Bound">x</a><a id="7632" class="Symbol">)</a>
      <a id="7640" href="decidability.html#7609" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7644" class="Symbol">=</a> <a id="7646" href="decidability.html#7420" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7648" href="decidability.html#7544" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h2 id="preservation-of-decidability">Preservation of decidability</h2>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="8189" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8203" class="Symbol">:</a> <a id="8205" class="Symbol">{</a><a id="8206" href="decidability.html#8206" class="Bound">A</a> <a id="8208" href="decidability.html#8208" class="Bound">B</a> <a id="8210" class="Symbol">:</a> <a id="8212" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="8216" class="Symbol">}</a> <a id="8218" class="Symbol">→</a> <a id="8220" class="Symbol">(</a><a id="8221" href="decidability.html#8206" class="Bound">A</a> <a id="8223" class="Symbol">→</a> <a id="8225" href="decidability.html#8208" class="Bound">B</a><a id="8226" class="Symbol">)</a> <a id="8228" class="Symbol">→</a> <a id="8230" class="Symbol">(</a><a id="8231" href="decidability.html#8208" class="Bound">B</a> <a id="8233" class="Symbol">→</a> <a id="8235" href="decidability.html#8206" class="Bound">A</a><a id="8236" class="Symbol">)</a> <a id="8238" class="Symbol">→</a> <a id="8240" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8253" href="decidability.html#8206" class="Bound">A</a> <a id="8255" class="Symbol">→</a> <a id="8257" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8270" href="decidability.html#8208" class="Bound">B</a>
<a id="8272" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8286" href="decidability.html#8286" class="Bound">f</a> <a id="8288" href="decidability.html#8288" class="Bound">g</a> <a id="8290" class="Symbol">(</a><a id="8291" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8295" href="decidability.html#8295" class="Bound">x</a><a id="8296" class="Symbol">)</a> <a id="8298" class="Symbol">=</a> <a id="8300" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8304" class="Symbol">(</a><a id="8305" href="decidability.html#8286" class="Bound">f</a> <a id="8307" href="decidability.html#8295" class="Bound">x</a><a id="8308" class="Symbol">)</a>
<a id="8310" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8324" href="decidability.html#8324" class="Bound">f</a> <a id="8326" href="decidability.html#8326" class="Bound">g</a> <a id="8328" class="Symbol">(</a><a id="8329" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8333" href="decidability.html#8333" class="Bound">h</a><a id="8334" class="Symbol">)</a> <a id="8336" class="Symbol">=</a> <a id="8338" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8342" class="Symbol">(λ</a> <a id="8345" href="decidability.html#8345" class="Bound">y</a> <a id="8347" class="Symbol">→</a> <a id="8349" href="decidability.html#8333" class="Bound">h</a> <a id="8351" class="Symbol">(</a><a id="8352" href="decidability.html#8326" class="Bound">g</a> <a id="8354" href="decidability.html#8345" class="Bound">y</a><a id="8355" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="8359" href="decidability.html#8359" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8383" class="Symbol">:</a> <a id="8385" class="Symbol">{</a><a id="8386" href="decidability.html#8386" class="Bound">A</a> <a id="8388" href="decidability.html#8388" class="Bound">B</a> <a id="8390" class="Symbol">:</a> <a id="8392" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="8396" class="Symbol">}</a> <a id="8398" class="Symbol">→</a> <a id="8400" class="Symbol">(</a><a id="8401" href="decidability.html#8386" class="Bound">A</a> <a id="8403" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8405" href="decidability.html#8388" class="Bound">B</a><a id="8406" class="Symbol">)</a> <a id="8408" class="Symbol">→</a> <a id="8410" class="Symbol">(</a><a id="8411" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8424" href="decidability.html#8386" class="Bound">A</a> <a id="8426" href="binary-products.html#1671" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8428" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8441" href="decidability.html#8388" class="Bound">B</a><a id="8442" class="Symbol">)</a>
<a id="8444" href="decidability.html#8359" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8468" class="Symbol">(</a><a id="8469" href="decidability.html#8469" class="Bound">f</a> <a id="8471" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8473" href="decidability.html#8473" class="Bound">g</a><a id="8474" class="Symbol">)</a> <a id="8476" class="Symbol">=</a> <a id="8478" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8492" href="decidability.html#8469" class="Bound">f</a> <a id="8494" href="decidability.html#8473" class="Bound">g</a> <a id="8496" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8498" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8512" href="decidability.html#8473" class="Bound">g</a> <a id="8514" href="decidability.html#8469" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8539" href="decidability.html#8539" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8554" class="Symbol">:</a> <a id="8556" class="Symbol">{</a><a id="8557" href="decidability.html#8557" class="Bound">A</a> <a id="8559" href="decidability.html#8559" class="Bound">B</a> <a id="8561" class="Symbol">:</a> <a id="8563" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="8567" class="Symbol">}</a> <a id="8569" class="Symbol">→</a> <a id="8571" class="Symbol">(</a><a id="8572" href="decidability.html#8557" class="Bound">A</a> <a id="8574" class="Symbol">→</a> <a id="8576" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="8578" href="decidability.html#8559" class="Bound">B</a><a id="8579" class="Symbol">)</a> <a id="8581" class="Symbol">→</a> <a id="8583" class="Symbol">(</a><a id="8584" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="8586" href="decidability.html#8557" class="Bound">A</a> <a id="8588" class="Symbol">→</a> <a id="8590" href="decidability.html#8559" class="Bound">B</a><a id="8591" class="Symbol">)</a> <a id="8593" class="Symbol">→</a> <a id="8595" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8608" href="decidability.html#8557" class="Bound">A</a> <a id="8610" class="Symbol">→</a> <a id="8612" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8625" href="decidability.html#8559" class="Bound">B</a>
<a id="8627" href="decidability.html#8539" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8642" href="decidability.html#8642" class="Bound">f</a> <a id="8644" href="decidability.html#8644" class="Bound">g</a> <a id="8646" class="Symbol">(</a><a id="8647" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8651" href="decidability.html#8651" class="Bound">x</a><a id="8652" class="Symbol">)</a> <a id="8654" class="Symbol">=</a> <a id="8656" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8660" class="Symbol">(</a><a id="8661" href="decidability.html#8642" class="Bound">f</a> <a id="8663" href="decidability.html#8651" class="Bound">x</a><a id="8664" class="Symbol">)</a>
<a id="8666" href="decidability.html#8539" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8681" href="decidability.html#8681" class="Bound">f</a> <a id="8683" href="decidability.html#8683" class="Bound">g</a> <a id="8685" class="Symbol">(</a><a id="8686" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8690" href="decidability.html#8690" class="Bound">h</a><a id="8691" class="Symbol">)</a> <a id="8693" class="Symbol">=</a> <a id="8695" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8699" class="Symbol">(</a><a id="8700" href="decidability.html#8683" class="Bound">g</a> <a id="8702" href="decidability.html#8690" class="Bound">h</a><a id="8703" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8718" href="decidability.html#8718" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8746" class="Symbol">:</a> <a id="8748" class="Symbol">{</a><a id="8749" href="decidability.html#8749" class="Bound">A</a> <a id="8751" class="Symbol">:</a> <a id="8753" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="8757" class="Symbol">}</a> <a id="8759" class="Symbol">→</a> <a id="8761" href="decidability.html#8749" class="Bound">A</a> <a id="8763" class="Symbol">→</a> <a id="8765" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8778" href="decidability.html#8749" class="Bound">A</a>
<a id="8780" href="decidability.html#8718" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8808" class="Symbol">=</a> <a id="8810" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8815" href="decidability.html#8815" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8841" class="Symbol">:</a> <a id="8843" class="Symbol">{</a><a id="8844" href="decidability.html#8844" class="Bound">A</a> <a id="8846" class="Symbol">:</a> <a id="8848" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="8852" class="Symbol">}</a> <a id="8854" class="Symbol">→</a> <a id="8856" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="8858" href="decidability.html#8844" class="Bound">A</a> <a id="8860" class="Symbol">→</a> <a id="8862" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8875" href="decidability.html#8844" class="Bound">A</a>
<a id="8877" href="decidability.html#8815" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8903" class="Symbol">=</a> <a id="8905" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8910" href="decidability.html#8910" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8925" class="Symbol">:</a> <a id="8927" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="8940" href="unit-type.html#753" data-type="Type" class="Record">𝟙</a>
<a id="8942" href="decidability.html#8910" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8957" class="Symbol">=</a> <a id="8959" href="decidability.html#8718" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8987" href="unit-type.html#783" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8990" href="decidability.html#8990" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="9005" class="Symbol">:</a> <a id="9007" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9020" href="empty-type.html#880" data-type="Set" class="Datatype">𝟘</a>
<a id="9022" href="decidability.html#8990" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="9037" class="Symbol">=</a> <a id="9039" href="decidability.html#8815" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="9065" href="empty-type.html#3981" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="9077" href="decidability.html#9077" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9102" class="Symbol">:</a> <a id="9104" class="Symbol">{</a><a id="9105" href="decidability.html#9105" class="Bound">A</a> <a id="9107" href="decidability.html#9107" class="Bound">B</a> <a id="9109" class="Symbol">:</a> <a id="9111" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="9115" class="Symbol">}</a>
                         <a id="9142" class="Symbol">→</a> <a id="9144" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9157" href="decidability.html#9105" class="Bound">A</a>
                         <a id="9184" class="Symbol">→</a> <a id="9186" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9199" href="decidability.html#9107" class="Bound">B</a>
                         <a id="9226" class="Symbol">→</a> <a id="9228" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9241" class="Symbol">(</a><a id="9242" href="decidability.html#9105" class="Bound">A</a> <a id="9244" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="9246" href="decidability.html#9107" class="Bound">B</a><a id="9247" class="Symbol">)</a>
<a id="9249" href="decidability.html#9077" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9274" class="Symbol">(</a><a id="9275" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9279" href="decidability.html#9279" class="Bound">x</a><a id="9280" class="Symbol">)</a> <a id="9282" class="Symbol">_</a>       <a id="9290" class="Symbol">=</a> <a id="9292" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9296" class="Symbol">(</a><a id="9297" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9301" href="decidability.html#9279" class="Bound">x</a><a id="9302" class="Symbol">)</a>
<a id="9304" href="decidability.html#9077" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9329" class="Symbol">(</a><a id="9330" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9334" class="Symbol">_)</a> <a id="9337" class="Symbol">(</a><a id="9338" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9342" href="decidability.html#9342" class="Bound">y</a><a id="9343" class="Symbol">)</a> <a id="9345" class="Symbol">=</a> <a id="9347" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9351" class="Symbol">(</a><a id="9352" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9356" href="decidability.html#9342" class="Bound">y</a><a id="9357" class="Symbol">)</a>
<a id="9359" href="decidability.html#9077" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9384" class="Symbol">(</a><a id="9385" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9389" href="decidability.html#9389" class="Bound">h</a><a id="9390" class="Symbol">)</a> <a id="9392" class="Symbol">(</a><a id="9393" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9397" href="decidability.html#9397" class="Bound">k</a><a id="9398" class="Symbol">)</a> <a id="9400" class="Symbol">=</a> <a id="9402" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9406" class="Symbol">(</a><a id="9407" href="binary-sums.html#4151" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9421" href="decidability.html#9389" class="Bound">h</a> <a id="9423" href="decidability.html#9397" class="Bound">k</a><a id="9424" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9427" href="decidability.html#9427" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9452" class="Symbol">:</a> <a id="9454" class="Symbol">{</a><a id="9455" href="decidability.html#9455" class="Bound">A</a> <a id="9457" href="decidability.html#9457" class="Bound">B</a> <a id="9459" class="Symbol">:</a> <a id="9461" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="9465" class="Symbol">}</a>
                         <a id="9492" class="Symbol">→</a> <a id="9494" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9507" href="decidability.html#9455" class="Bound">A</a>
                         <a id="9534" class="Symbol">→</a> <a id="9536" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9549" href="decidability.html#9457" class="Bound">B</a>
                         <a id="9576" class="Symbol">→</a> <a id="9578" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9591" class="Symbol">(</a><a id="9592" href="decidability.html#9455" class="Bound">A</a> <a id="9594" href="binary-products.html#1027" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9596" href="decidability.html#9457" class="Bound">B</a><a id="9597" class="Symbol">)</a>
<a id="9599" href="decidability.html#9427" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9624" class="Symbol">(</a><a id="9625" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9629" href="decidability.html#9629" class="Bound">x</a><a id="9630" class="Symbol">)</a> <a id="9632" class="Symbol">(</a><a id="9633" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9637" href="decidability.html#9637" class="Bound">y</a><a id="9638" class="Symbol">)</a> <a id="9640" class="Symbol">=</a> <a id="9642" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9646" class="Symbol">(</a><a id="9647" href="decidability.html#9629" class="Bound">x</a> <a id="9649" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9651" href="decidability.html#9637" class="Bound">y</a><a id="9652" class="Symbol">)</a>
<a id="9654" href="decidability.html#9427" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9679" class="Symbol">(</a><a id="9680" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9684" class="Symbol">_)</a> <a id="9687" class="Symbol">(</a><a id="9688" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9692" href="decidability.html#9692" class="Bound">k</a><a id="9693" class="Symbol">)</a> <a id="9695" class="Symbol">=</a> <a id="9697" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9701" class="Symbol">(λ</a> <a id="9704" class="Symbol">(</a><a id="9705" href="decidability.html#9705" class="Bound">x</a> <a id="9707" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9709" href="decidability.html#9709" class="Bound">y</a><a id="9710" class="Symbol">)</a> <a id="9712" class="Symbol">→</a> <a id="9714" href="decidability.html#9692" class="Bound">k</a> <a id="9716" href="decidability.html#9709" class="Bound">y</a><a id="9717" class="Symbol">)</a>
<a id="9719" href="decidability.html#9427" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9744" class="Symbol">(</a><a id="9745" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9749" href="decidability.html#9749" class="Bound">h</a><a id="9750" class="Symbol">)</a> <a id="9752" class="Symbol">_</a>       <a id="9760" class="Symbol">=</a> <a id="9762" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9766" class="Symbol">(λ</a> <a id="9769" class="Symbol">(</a><a id="9770" href="decidability.html#9770" class="Bound">x</a> <a id="9772" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9774" href="decidability.html#9774" class="Bound">y</a><a id="9775" class="Symbol">)</a> <a id="9777" class="Symbol">→</a> <a id="9779" href="decidability.html#9749" class="Bound">h</a> <a id="9781" href="decidability.html#9770" class="Bound">x</a><a id="9782" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9785" href="decidability.html#9785" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9810" class="Symbol">:</a> <a id="9812" class="Symbol">{</a><a id="9813" href="decidability.html#9813" class="Bound">A</a> <a id="9815" href="decidability.html#9815" class="Bound">B</a> <a id="9817" class="Symbol">:</a> <a id="9819" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="9823" class="Symbol">}</a>
                         <a id="9850" class="Symbol">→</a> <a id="9852" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9865" href="decidability.html#9813" class="Bound">A</a>
                         <a id="9892" class="Symbol">→</a> <a id="9894" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9907" href="decidability.html#9815" class="Bound">B</a>
                         <a id="9934" class="Symbol">→</a> <a id="9936" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="9949" class="Symbol">(</a><a id="9950" href="decidability.html#9813" class="Bound">A</a> <a id="9952" class="Symbol">→</a> <a id="9954" href="decidability.html#9815" class="Bound">B</a><a id="9955" class="Symbol">)</a>
<a id="9957" href="decidability.html#9785" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9982" class="Symbol">_</a>       <a id="9990" class="Symbol">(</a><a id="9991" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9995" href="decidability.html#9995" class="Bound">y</a><a id="9996" class="Symbol">)</a> <a id="9998" class="Symbol">=</a> <a id="10000" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="10004" class="Symbol">(λ</a> <a id="10007" href="decidability.html#10007" class="Bound">_</a> <a id="10009" class="Symbol">→</a> <a id="10011" href="decidability.html#9995" class="Bound">y</a><a id="10012" class="Symbol">)</a>
<a id="10014" href="decidability.html#9785" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="10039" class="Symbol">(</a><a id="10040" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="10044" href="decidability.html#10044" class="Bound">x</a><a id="10045" class="Symbol">)</a> <a id="10047" class="Symbol">(</a><a id="10048" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="10052" href="decidability.html#10052" class="Bound">k</a><a id="10053" class="Symbol">)</a> <a id="10055" class="Symbol">=</a> <a id="10057" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="10061" class="Symbol">(λ</a> <a id="10064" href="decidability.html#10064" class="Bound">f</a> <a id="10066" class="Symbol">→</a> <a id="10068" href="decidability.html#10052" class="Bound">k</a> <a id="10070" class="Symbol">(</a><a id="10071" href="decidability.html#10064" class="Bound">f</a> <a id="10073" href="decidability.html#10044" class="Bound">x</a><a id="10074" class="Symbol">))</a>
<a id="10077" href="decidability.html#9785" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="10102" class="Symbol">(</a><a id="10103" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="10107" href="decidability.html#10107" class="Bound">h</a><a id="10108" class="Symbol">)</a> <a id="10110" class="Symbol">(</a><a id="10111" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="10115" href="decidability.html#10115" class="Bound">k</a><a id="10116" class="Symbol">)</a> <a id="10118" class="Symbol">=</a> <a id="10120" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="10124" class="Symbol">(λ</a> <a id="10127" href="decidability.html#10127" class="Bound">x</a> <a id="10129" class="Symbol">→</a> <a id="10131" href="empty-type.html#2126" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="10138" class="Symbol">(</a><a id="10139" href="decidability.html#10107" class="Bound">h</a> <a id="10141" href="decidability.html#10127" class="Bound">x</a><a id="10142" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="10146" href="decidability.html#10146" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="10171" class="Symbol">:</a> <a id="10173" class="Symbol">{</a><a id="10174" href="decidability.html#10174" class="Bound">A</a> <a id="10176" class="Symbol">:</a> <a id="10178" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="10182" class="Symbol">}</a>
                         <a id="10209" class="Symbol">→</a> <a id="10211" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="10224" href="decidability.html#10174" class="Bound">A</a>
                         <a id="10251" class="Symbol">→</a> <a id="10253" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="10266" class="Symbol">(</a><a id="10267" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="10269" href="decidability.html#10174" class="Bound">A</a><a id="10270" class="Symbol">)</a>
<a id="10272" href="decidability.html#10146" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="10297" href="decidability.html#10297" class="Bound">d</a> <a id="10299" class="Symbol">=</a> <a id="10301" href="decidability.html#9785" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="10326" href="decidability.html#10297" class="Bound">d</a> <a id="10328" href="decidability.html#8990" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h2 id="exhaustively-searchable-types">Exhaustively searchable
types</h2>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10855" href="decidability.html#10855" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10882" class="Symbol">:</a> <a id="10884" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a> <a id="10889" class="Symbol">→</a> <a id="10891" href="general-notation.html#1084" data-type="Set₂" class="Function">Type₁</a>
<a id="10897" href="decidability.html#10855" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10924" href="decidability.html#10924" class="Bound">X</a> <a id="10926" class="Symbol">=</a> <a id="10928" class="Symbol">(</a><a id="10929" href="decidability.html#10929" class="Bound">A</a> <a id="10931" class="Symbol">:</a> <a id="10933" href="decidability.html#10924" class="Bound">X</a> <a id="10935" class="Symbol">→</a> <a id="10937" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="10941" class="Symbol">)</a>
                             <a id="10972" class="Symbol">→</a> <a id="10974" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10997" href="decidability.html#10929" class="Bound">A</a>
                             <a id="11028" class="Symbol">→</a> <a id="11030" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="11043" class="Symbol">(</a><a id="11044" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="11046" href="decidability.html#11046" class="Bound">x</a> <a id="11048" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="11050" href="decidability.html#10924" class="Bound">X</a> <a id="11052" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="11054" href="decidability.html#10929" class="Bound">A</a> <a id="11056" href="decidability.html#11046" class="Bound">x</a><a id="11057" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12476" href="decidability.html#12476" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12493" class="Symbol">:</a> <a id="12495" class="Symbol">(</a><a id="12496" href="decidability.html#12496" class="Bound">X</a> <a id="12498" class="Symbol">:</a> <a id="12500" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="12504" class="Symbol">)</a>
                 <a id="12523" class="Symbol">→</a> <a id="12525" href="decidability.html#10855" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12552" href="decidability.html#12496" class="Bound">X</a>
                 <a id="12571" class="Symbol">→</a> <a id="12573" class="Symbol">(</a><a id="12574" href="decidability.html#12574" class="Bound">A</a> <a id="12576" class="Symbol">:</a> <a id="12578" href="decidability.html#12496" class="Bound">X</a> <a id="12580" class="Symbol">→</a> <a id="12582" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="12586" class="Symbol">)</a>
                 <a id="12605" class="Symbol">→</a> <a id="12607" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12630" href="decidability.html#12574" class="Bound">A</a>
                 <a id="12649" class="Symbol">→</a> <a id="12651" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="12664" class="Symbol">(</a><a id="12665" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12667" href="decidability.html#12667" class="Bound">x</a> <a id="12669" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12671" href="decidability.html#12496" class="Bound">X</a> <a id="12673" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12675" href="decidability.html#12574" class="Bound">A</a> <a id="12677" href="decidability.html#12667" class="Bound">x</a><a id="12678" class="Symbol">)</a>
<a id="12680" href="decidability.html#12476" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12697" href="decidability.html#12697" class="Bound">X</a> <a id="12699" href="decidability.html#12699" class="Bound">s</a> <a id="12701" href="decidability.html#12701" class="Bound">A</a> <a id="12703" href="decidability.html#12703" class="Bound">d</a> <a id="12705" class="Symbol">=</a> <a id="12707" href="decidability.html#13191" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12711" class="Keyword">where</a>
  <a id="12719" href="decidability.html#12719" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12721" class="Symbol">:</a> <a id="12723" href="decidability.html#5691" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12746" class="Symbol">(λ</a> <a id="12749" href="decidability.html#12749" class="Bound">x</a> <a id="12751" class="Symbol">→</a> <a id="12753" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12755" class="Symbol">(</a><a id="12756" href="decidability.html#12701" class="Bound">A</a> <a id="12758" href="decidability.html#12749" class="Bound">x</a><a id="12759" class="Symbol">))</a>
  <a id="12764" href="decidability.html#12719" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12766" href="decidability.html#12766" class="Bound">x</a> <a id="12768" class="Symbol">=</a> <a id="12770" href="decidability.html#10146" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12795" class="Symbol">(</a><a id="12796" href="decidability.html#12703" class="Bound">d</a> <a id="12798" href="decidability.html#12766" class="Bound">x</a><a id="12799" class="Symbol">)</a>

  <a id="12804" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12807" class="Symbol">:</a> <a id="12809" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="12822" class="Symbol">(</a><a id="12823" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12825" href="decidability.html#12825" class="Bound">x</a> <a id="12827" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12829" href="decidability.html#12697" class="Bound">X</a> <a id="12831" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12833" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12835" class="Symbol">(</a><a id="12836" href="decidability.html#12701" class="Bound">A</a> <a id="12838" href="decidability.html#12825" class="Bound">x</a><a id="12839" class="Symbol">))</a>
  <a id="12844" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12847" class="Symbol">=</a> <a id="12849" href="decidability.html#12699" class="Bound">s</a> <a id="12851" class="Symbol">(λ</a> <a id="12854" href="decidability.html#12854" class="Bound">x</a> <a id="12856" class="Symbol">→</a> <a id="12858" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12860" class="Symbol">(</a><a id="12861" href="decidability.html#12701" class="Bound">A</a> <a id="12863" href="decidability.html#12854" class="Bound">x</a><a id="12864" class="Symbol">))</a> <a id="12867" href="decidability.html#12719" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12872" href="decidability.html#12872" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12876" class="Symbol">:</a> <a id="12878" class="Symbol">(</a><a id="12879" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12881" href="decidability.html#12881" class="Bound">x</a> <a id="12883" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12885" href="decidability.html#12697" class="Bound">X</a> <a id="12887" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12889" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12891" class="Symbol">(</a><a id="12892" href="decidability.html#12701" class="Bound">A</a> <a id="12894" href="decidability.html#12881" class="Bound">x</a><a id="12895" class="Symbol">))</a> <a id="12898" class="Symbol">→</a> <a id="12900" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12902" class="Symbol">(</a><a id="12903" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12905" href="decidability.html#12905" class="Bound">x</a> <a id="12907" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12909" href="decidability.html#12697" class="Bound">X</a> <a id="12911" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12913" href="decidability.html#12701" class="Bound">A</a> <a id="12915" href="decidability.html#12905" class="Bound">x</a><a id="12916" class="Symbol">)</a>
  <a id="12920" href="decidability.html#12872" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12924" class="Symbol">(</a><a id="12925" href="decidability.html#12925" class="Bound">x</a> <a id="12927" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12929" href="decidability.html#12929" class="Bound">f</a><a id="12930" class="Symbol">)</a> <a id="12932" href="decidability.html#12932" class="Bound">g</a> <a id="12934" class="Symbol">=</a> <a id="12936" href="decidability.html#12929" class="Bound">f</a> <a id="12938" class="Symbol">(</a><a id="12939" href="decidability.html#12932" class="Bound">g</a> <a id="12941" href="decidability.html#12925" class="Bound">x</a><a id="12942" class="Symbol">)</a>

  <a id="12947" href="decidability.html#12947" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12950" class="Symbol">:</a> <a id="12952" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12954" class="Symbol">(</a><a id="12955" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12957" href="decidability.html#12957" class="Bound">x</a> <a id="12959" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12961" href="decidability.html#12697" class="Bound">X</a> <a id="12963" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12965" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="12967" class="Symbol">(</a><a id="12968" href="decidability.html#12701" class="Bound">A</a> <a id="12970" href="decidability.html#12957" class="Bound">x</a><a id="12971" class="Symbol">))</a> <a id="12974" class="Symbol">→</a> <a id="12976" class="Symbol">(</a><a id="12977" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12979" href="decidability.html#12979" class="Bound">x</a> <a id="12981" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12983" href="decidability.html#12697" class="Bound">X</a> <a id="12985" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12987" href="decidability.html#12701" class="Bound">A</a> <a id="12989" href="decidability.html#12979" class="Bound">x</a><a id="12990" class="Symbol">)</a>
  <a id="12994" href="decidability.html#12947" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12997" href="decidability.html#12997" class="Bound">h</a> <a id="12999" href="decidability.html#12999" class="Bound">x</a> <a id="13001" class="Symbol">=</a> <a id="13003" href="decidability.html#13055" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="13009" class="Keyword">where</a>
    <a id="13019" href="decidability.html#13019" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="13021" class="Symbol">:</a> <a id="13023" href="negation.html#2352" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="13026" href="decidability.html#12701" class="Bound">A</a> <a id="13028" href="decidability.html#12999" class="Bound">x</a>
    <a id="13034" href="decidability.html#13019" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="13036" href="decidability.html#13036" class="Bound">f</a> <a id="13038" class="Symbol">=</a> <a id="13040" href="decidability.html#12997" class="Bound">h</a> <a id="13042" class="Symbol">(</a><a id="13043" href="decidability.html#12999" class="Bound">x</a> <a id="13045" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="13047" href="decidability.html#13036" class="Bound">f</a><a id="13048" class="Symbol">)</a>

    <a id="13055" href="decidability.html#13055" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="13058" class="Symbol">:</a> <a id="13060" href="decidability.html#12701" class="Bound">A</a> <a id="13062" href="decidability.html#12999" class="Bound">x</a>
    <a id="13068" href="decidability.html#13055" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="13071" class="Symbol">=</a> <a id="13073" href="decidability.html#3267" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="13081" class="Symbol">(</a><a id="13082" href="decidability.html#12703" class="Bound">d</a> <a id="13084" href="decidability.html#12999" class="Bound">x</a><a id="13085" class="Symbol">)</a> <a id="13087" href="decidability.html#13019" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="13092" href="decidability.html#13092" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="13094" class="Symbol">:</a> <a id="13096" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="13109" class="Symbol">(</a><a id="13110" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="13112" href="decidability.html#13112" class="Bound">x</a> <a id="13114" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="13116" href="decidability.html#12697" class="Bound">X</a> <a id="13118" href="sums.html#3965" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="13120" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="13122" class="Symbol">(</a><a id="13123" href="decidability.html#12701" class="Bound">A</a> <a id="13125" href="decidability.html#13112" class="Bound">x</a><a id="13126" class="Symbol">))</a> <a id="13129" class="Symbol">→</a> <a id="13131" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="13144" class="Symbol">(</a><a id="13145" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="13147" href="decidability.html#13147" class="Bound">x</a> <a id="13149" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="13151" href="decidability.html#12697" class="Bound">X</a> <a id="13153" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="13155" href="decidability.html#12701" class="Bound">A</a> <a id="13157" href="decidability.html#13147" class="Bound">x</a><a id="13158" class="Symbol">)</a>
  <a id="13162" href="decidability.html#13092" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="13164" class="Symbol">=</a> <a id="13166" href="decidability.html#8539" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="13181" href="decidability.html#12872" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="13185" href="decidability.html#12947" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="13191" href="decidability.html#13191" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="13194" class="Symbol">:</a> <a id="13196" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="13209" class="Symbol">(</a><a id="13210" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="13212" href="decidability.html#13212" class="Bound">x</a> <a id="13214" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="13216" href="decidability.html#12697" class="Bound">X</a> <a id="13218" href="products.html#4454" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="13220" href="decidability.html#12701" class="Bound">A</a> <a id="13222" href="decidability.html#13212" class="Bound">x</a><a id="13223" class="Symbol">)</a>
  <a id="13227" href="decidability.html#13191" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="13230" class="Symbol">=</a> <a id="13232" href="decidability.html#13092" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="13234" href="decidability.html#12804" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h2 id="decidable-equality">Decidable equality</h2>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13760" href="decidability.html#13760" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13783" class="Symbol">:</a> <a id="13785" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a> <a id="13790" class="Symbol">→</a> <a id="13792" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a>
<a id="13797" href="decidability.html#13760" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13820" href="decidability.html#13820" class="Bound">X</a> <a id="13822" class="Symbol">=</a> <a id="13824" class="Symbol">(</a><a id="13825" href="decidability.html#13825" class="Bound">x</a> <a id="13827" href="decidability.html#13827" class="Bound">y</a> <a id="13829" class="Symbol">:</a> <a id="13831" href="decidability.html#13820" class="Bound">X</a><a id="13832" class="Symbol">)</a> <a id="13834" class="Symbol">→</a> <a id="13836" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="13849" class="Symbol">(</a><a id="13850" href="decidability.html#13825" class="Bound">x</a> <a id="13852" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13854" href="decidability.html#13827" class="Bound">y</a><a id="13855" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="14061" href="decidability.html#14061" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14089" class="Symbol">:</a> <a id="14091" href="decidability.html#13760" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14114" href="Bool.html#849" data-type="Set" class="Datatype">Bool</a>
<a id="14119" href="decidability.html#14061" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14147" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>  <a id="14153" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>  <a id="14159" class="Symbol">=</a> <a id="14161" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14165" class="Symbol">(</a><a id="14166" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14171" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a><a id="14175" class="Symbol">)</a>
<a id="14177" href="decidability.html#14061" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14205" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>  <a id="14211" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="14217" class="Symbol">=</a> <a id="14219" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14223" href="negation.html#3754" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="14241" href="decidability.html#14061" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14269" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="14275" href="Bool.html#868" data-type="Bool" class="InductiveConstructor">true</a>  <a id="14281" class="Symbol">=</a> <a id="14283" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14287" href="negation.html#3699" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="14305" href="decidability.html#14061" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14333" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="14339" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a> <a id="14345" class="Symbol">=</a> <a id="14347" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14351" class="Symbol">(</a><a id="14352" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14357" href="Bool.html#873" data-type="Bool" class="InductiveConstructor">false</a><a id="14362" class="Symbol">)</a>

<a id="14365" class="Keyword">open</a> <a id="14370" class="Keyword">import</a> <a id="14377" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14404" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14429" class="Symbol">:</a> <a id="14431" href="decidability.html#13760" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14454" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a>
<a id="14456" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14481" class="Number">0</a>       <a id="14489" class="Number">0</a>       <a id="14497" class="Symbol">=</a> <a id="14499" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14503" class="Symbol">(</a><a id="14504" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14509" href="introduction.html#1407" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14513" class="Symbol">)</a>
<a id="14515" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14540" class="Number">0</a>       <a id="14548" class="Symbol">(</a><a id="14549" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14553" href="decidability.html#14553" class="Bound">y</a><a id="14554" class="Symbol">)</a> <a id="14556" class="Symbol">=</a> <a id="14558" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14562" href="natural-numbers-functions.html#885" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14578" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14603" class="Symbol">(</a><a id="14604" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14608" href="decidability.html#14608" class="Bound">x</a><a id="14609" class="Symbol">)</a> <a id="14611" class="Number">0</a>       <a id="14619" class="Symbol">=</a> <a id="14621" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14625" href="natural-numbers-functions.html#827" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14641" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14666" class="Symbol">(</a><a id="14667" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14671" href="decidability.html#14671" class="Bound">x</a><a id="14672" class="Symbol">)</a> <a id="14674" class="Symbol">(</a><a id="14675" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14679" href="decidability.html#14679" class="Bound">y</a><a id="14680" class="Symbol">)</a> <a id="14682" class="Symbol">=</a> <a id="14684" href="decidability.html#14858" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14689" class="Keyword">where</a>
  <a id="14697" href="decidability.html#14697" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14700" class="Symbol">:</a> <a id="14702" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="14715" class="Symbol">(</a><a id="14716" href="decidability.html#14671" class="Bound">x</a> <a id="14718" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14720" href="decidability.html#14679" class="Bound">y</a><a id="14721" class="Symbol">)</a>
  <a id="14725" href="decidability.html#14697" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14728" class="Symbol">=</a> <a id="14730" href="decidability.html#14404" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14755" href="decidability.html#14671" class="Bound">x</a> <a id="14757" href="decidability.html#14679" class="Bound">y</a>

  <a id="14762" href="decidability.html#14762" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14764" class="Symbol">:</a> <a id="14766" href="decidability.html#14671" class="Bound">x</a> <a id="14768" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14770" href="decidability.html#14679" class="Bound">y</a> <a id="14772" class="Symbol">→</a> <a id="14774" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14778" href="decidability.html#14671" class="Bound">x</a> <a id="14780" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14782" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14786" href="decidability.html#14679" class="Bound">y</a>
  <a id="14790" href="decidability.html#14762" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14792" class="Symbol">=</a> <a id="14794" href="identity-type.html#2664" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14797" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14804" href="decidability.html#14804" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14807" class="Symbol">:</a> <a id="14809" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14813" href="decidability.html#14671" class="Bound">x</a> <a id="14815" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14817" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14821" href="decidability.html#14679" class="Bound">y</a> <a id="14823" class="Symbol">→</a> <a id="14825" href="decidability.html#14671" class="Bound">x</a> <a id="14827" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14829" href="decidability.html#14679" class="Bound">y</a>
  <a id="14833" href="decidability.html#14804" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14836" class="Symbol">=</a> <a id="14838" href="natural-numbers-functions.html#991" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14858" href="decidability.html#14858" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14862" class="Symbol">:</a> <a id="14864" href="decidability.html#2992" data-type="Type → Type" class="Function">is-decidable</a> <a id="14877" class="Symbol">(</a><a id="14878" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14882" href="decidability.html#14671" class="Bound">x</a> <a id="14884" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14886" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14890" href="decidability.html#14679" class="Bound">y</a><a id="14891" class="Symbol">)</a>
  <a id="14895" href="decidability.html#14858" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14899" class="Symbol">=</a> <a id="14901" href="decidability.html#8189" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14915" href="decidability.html#14762" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14917" href="decidability.html#14804" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14920" href="decidability.html#14697" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h2 id="equality-of-functions">Equality of functions</h2>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="15208" class="Keyword">private</a>
 <a id="f"></a><a id="15217" href="decidability.html#15217" class="Function">f</a> <a id="g"></a><a id="15219" href="decidability.html#15219" class="Function">g</a> <a id="h"></a><a id="15221" href="decidability.html#15221" class="Function">h</a> <a id="15223" class="Symbol">:</a> <a id="15225" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a> <a id="15227" class="Symbol">→</a> <a id="15229" href="introduction.html#1391" data-type="Set" class="Datatype">ℕ</a>

 <a id="15233" href="decidability.html#15217" class="Function">f</a> <a id="15235" href="decidability.html#15235" class="Bound">x</a> <a id="15237" class="Symbol">=</a> <a id="15239" href="decidability.html#15235" class="Bound">x</a>

 <a id="15243" href="decidability.html#15219" class="Function">g</a> <a id="15245" class="Number">0</a>       <a id="15253" class="Symbol">=</a> <a id="15255" class="Number">0</a>
 <a id="15258" href="decidability.html#15219" class="Function">g</a> <a id="15260" class="Symbol">(</a><a id="15261" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15265" href="decidability.html#15265" class="Bound">x</a><a id="15266" class="Symbol">)</a> <a id="15268" class="Symbol">=</a> <a id="15270" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15274" class="Symbol">(</a><a id="15275" href="decidability.html#15219" class="Function">g</a> <a id="15277" href="decidability.html#15265" class="Bound">x</a><a id="15278" class="Symbol">)</a>

 <a id="15282" href="decidability.html#15221" class="Function">h</a> <a id="15284" href="decidability.html#15284" class="Bound">x</a> <a id="15286" class="Symbol">=</a> <a id="15288" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15292" href="decidability.html#15284" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="15296" href="decidability.html#15296" class="Function">f-equals-g</a> <a id="15307" class="Symbol">:</a> <a id="15309" href="decidability.html#15217" class="Function">f</a> <a id="15311" href="identity-type.html#3615" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15313" href="decidability.html#15219" class="Function">g</a>
 <a id="15316" href="decidability.html#15296" class="Function">f-equals-g</a> <a id="15327" class="Number">0</a>       <a id="15335" class="Symbol">=</a> <a id="15337" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15342" class="Symbol">(</a><a id="15343" href="decidability.html#15217" class="Function">f</a> <a id="15345" class="Number">0</a><a id="15346" class="Symbol">)</a>
 <a id="15349" href="decidability.html#15296" class="Function">f-equals-g</a> <a id="15360" class="Symbol">(</a><a id="15361" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15365" href="decidability.html#15365" class="Bound">x</a><a id="15366" class="Symbol">)</a> <a id="15368" class="Symbol">=</a> <a id="15370" href="decidability.html#15423" class="Function">γ</a>
  <a id="15374" class="Keyword">where</a>
   <a id="15383" href="decidability.html#15383" class="Function">IH</a> <a id="15386" class="Symbol">:</a> <a id="15388" href="decidability.html#15217" class="Function">f</a> <a id="15390" href="decidability.html#15365" class="Bound">x</a> <a id="15392" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15394" href="decidability.html#15219" class="Function">g</a> <a id="15396" href="decidability.html#15365" class="Bound">x</a>
   <a id="15401" href="decidability.html#15383" class="Function">IH</a> <a id="15404" class="Symbol">=</a> <a id="15406" href="decidability.html#15296" class="Function">f-equals-g</a> <a id="15417" href="decidability.html#15365" class="Bound">x</a>

   <a id="15423" href="decidability.html#15423" class="Function">γ</a> <a id="15425" class="Symbol">:</a> <a id="15427" href="decidability.html#15217" class="Function">f</a> <a id="15429" class="Symbol">(</a><a id="15430" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15434" href="decidability.html#15365" class="Bound">x</a><a id="15435" class="Symbol">)</a> <a id="15437" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15439" href="decidability.html#15219" class="Function">g</a> <a id="15441" class="Symbol">(</a><a id="15442" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15446" href="decidability.html#15365" class="Bound">x</a><a id="15447" class="Symbol">)</a>
   <a id="15452" href="decidability.html#15423" class="Function">γ</a> <a id="15454" class="Symbol">=</a> <a id="15456" href="decidability.html#15217" class="Function">f</a> <a id="15458" class="Symbol">(</a><a id="15459" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15463" href="decidability.html#15365" class="Bound">x</a><a id="15464" class="Symbol">)</a> <a id="15466" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15469" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15474" class="Symbol">_</a> <a id="15476" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15485" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15489" href="decidability.html#15365" class="Bound">x</a>     <a id="15495" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15498" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15503" class="Symbol">_</a> <a id="15505" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15514" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15518" class="Symbol">(</a><a id="15519" href="decidability.html#15217" class="Function">f</a> <a id="15521" href="decidability.html#15365" class="Bound">x</a><a id="15522" class="Symbol">)</a> <a id="15524" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15527" href="identity-type.html#2664" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15530" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15534" href="decidability.html#15383" class="Function">IH</a> <a id="15537" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15546" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15550" class="Symbol">(</a><a id="15551" href="decidability.html#15219" class="Function">g</a> <a id="15553" href="decidability.html#15365" class="Bound">x</a><a id="15554" class="Symbol">)</a> <a id="15556" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15559" href="identity-type.html#1021" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15564" class="Symbol">_</a> <a id="15566" href="identity-type.html#4509" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15575" href="decidability.html#15219" class="Function">g</a> <a id="15577" class="Symbol">(</a><a id="15578" href="introduction.html#1417" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15582" href="decidability.html#15365" class="Bound">x</a><a id="15583" class="Symbol">)</a> <a id="15585" href="identity-type.html#4595" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15589" href="decidability.html#15589" class="Function">f-not-equals-h</a> <a id="15604" class="Symbol">:</a> <a id="15606" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="15608" class="Symbol">(</a><a id="15609" href="decidability.html#15217" class="Function">f</a> <a id="15611" href="identity-type.html#3615" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15613" href="decidability.html#15221" class="Function">h</a><a id="15614" class="Symbol">)</a>
 <a id="15617" href="decidability.html#15589" class="Function">f-not-equals-h</a> <a id="15632" href="decidability.html#15632" class="Bound">e</a> <a id="15634" class="Symbol">=</a> <a id="15636" href="decidability.html#15688" class="Function">contradiction</a> <a id="15650" href="decidability.html#15663" class="Function">d</a>
  <a id="15654" class="Keyword">where</a>
   <a id="15663" href="decidability.html#15663" class="Function">d</a> <a id="15665" class="Symbol">:</a> <a id="15667" class="Number">0</a> <a id="15669" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15671" class="Number">1</a>
   <a id="15676" href="decidability.html#15663" class="Function">d</a> <a id="15678" class="Symbol">=</a> <a id="15680" href="decidability.html#15632" class="Bound">e</a> <a id="15682" class="Number">0</a>

   <a id="15688" href="decidability.html#15688" class="Function">contradiction</a> <a id="15702" class="Symbol">:</a> <a id="15704" href="empty-type.html#2042" data-type="Type → Type" class="Function Operator">¬</a> <a id="15706" class="Symbol">(</a><a id="15707" class="Number">0</a> <a id="15709" href="identity-type.html#984" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15711" class="Number">1</a><a id="15712" class="Symbol">)</a>
   <a id="15717" href="decidability.html#15688" class="Function">contradiction</a> <a id="15731" class="Symbol">()</a>
</pre>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
