<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module “Advanced Functional Programming” at
the <a
href="https://www.birmingham.ac.uk/schools/computer-science/index.aspx">School
of Computer Science</a> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="324" class="Symbol">{-#</a> <a id="328" class="Keyword">OPTIONS</a> <a id="336" class="Pragma">--without-K</a> <a id="348" class="Pragma">--safe</a> <a id="355" class="Symbol">#-}</a>

<a id="360" class="Keyword">module</a> <a id="367" href="decidability.html" class="Module">decidability</a> <a id="380" class="Keyword">where</a>

<a id="387" class="Keyword">open</a> <a id="392" class="Keyword">import</a> <a id="399" href="prelude.html" class="Module">prelude</a>
<a id="407" class="Keyword">open</a> <a id="412" class="Keyword">import</a> <a id="419" href="negation.html" class="Module">negation</a>
<a id="428" class="Keyword">open</a> <a id="433" class="Keyword">import</a> <a id="440" href="natural-numbers-type.html" class="Module">natural-numbers-type</a>
</pre>-->
<h1
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h1>
<p>When programming in conventional programming languages such as
Haskell, C, Java, Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h2 id="discussion-and-motivation">Discussion and motivation</h2>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h2 id="decidable-propositions">Decidable propositions</h2>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2737" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="2750" class="Symbol">:</a> <a id="2752" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a> <a id="2757" class="Symbol">→</a> <a id="2759" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
<a id="2764" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="2777" href="decidability.html#2777" class="Bound">A</a> <a id="2779" class="Symbol">=</a> <a id="2781" href="decidability.html#2777" class="Bound">A</a> <a id="2783" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2785" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="2787" href="decidability.html#2777" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="3012" href="decidability.html#3012" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3020" class="Symbol">:</a> <a id="3022" class="Symbol">{</a><a id="3023" href="decidability.html#3023" class="Bound">A</a> <a id="3025" class="Symbol">:</a> <a id="3027" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3031" class="Symbol">}</a> <a id="3033" class="Symbol">→</a> <a id="3035" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="3048" href="decidability.html#3023" class="Bound">A</a> <a id="3050" class="Symbol">→</a> <a id="3052" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="3055" href="decidability.html#3023" class="Bound">A</a> <a id="3057" class="Symbol">→</a> <a id="3059" href="decidability.html#3023" class="Bound">A</a>
<a id="3061" href="decidability.html#3012" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3069" class="Symbol">(</a><a id="3070" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3074" href="decidability.html#3074" class="Bound">x</a><a id="3075" class="Symbol">)</a> <a id="3077" href="decidability.html#3077" class="Bound">f</a> <a id="3079" class="Symbol">=</a> <a id="3081" href="decidability.html#3074" class="Bound">x</a>
<a id="3083" href="decidability.html#3012" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="3091" class="Symbol">(</a><a id="3092" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3096" href="decidability.html#3096" class="Bound">g</a><a id="3097" class="Symbol">)</a> <a id="3099" href="decidability.html#3099" class="Bound">f</a> <a id="3101" class="Symbol">=</a> <a id="3103" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3110" class="Symbol">(</a><a id="3111" href="decidability.html#3099" class="Bound">f</a> <a id="3113" href="decidability.html#3096" class="Bound">g</a><a id="3114" class="Symbol">)</a>
</pre>
<h2 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h2>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3542" href="decidability.html#3542" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3569" class="Symbol">:</a> <a id="3571" class="Symbol">(</a><a id="3572" href="decidability.html#3572" class="Bound">A</a> <a id="3574" class="Symbol">:</a> <a id="3576" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3580" class="Symbol">)</a> <a id="3582" class="Symbol">→</a> <a id="3584" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="3597" href="decidability.html#3572" class="Bound">A</a> <a id="3599" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3601" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3603" href="decidability.html#3603" class="Bound">b</a> <a id="3605" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3607" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="3612" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3614" class="Symbol">(</a><a id="3615" href="decidability.html#3572" class="Bound">A</a> <a id="3617" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3619" href="decidability.html#3603" class="Bound">b</a> <a id="3621" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3623" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="3627" class="Symbol">)</a>
<a id="3629" href="decidability.html#3542" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3656" href="decidability.html#3656" class="Bound">A</a> <a id="3658" class="Symbol">=</a> <a id="3660" href="decidability.html#3675" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3662" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3664" href="decidability.html#3969" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3667" class="Keyword">where</a>
  <a id="3675" href="decidability.html#3675" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3677" class="Symbol">:</a> <a id="3679" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="3692" href="decidability.html#3656" class="Bound">A</a> <a id="3694" class="Symbol">→</a> <a id="3696" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3698" href="decidability.html#3698" class="Bound">b</a> <a id="3700" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3702" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="3707" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3709" class="Symbol">(</a><a id="3710" href="decidability.html#3656" class="Bound">A</a> <a id="3712" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3714" href="decidability.html#3698" class="Bound">b</a> <a id="3716" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3718" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="3722" class="Symbol">)</a>
  <a id="3726" href="decidability.html#3675" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3728" class="Symbol">(</a><a id="3729" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3733" href="decidability.html#3733" class="Bound">x</a><a id="3734" class="Symbol">)</a> <a id="3736" class="Symbol">=</a> <a id="3738" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3743" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3745" class="Symbol">(</a><a id="3746" href="decidability.html#3766" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3748" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3750" href="decidability.html#3811" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="3751" class="Symbol">)</a>
   <a id="3756" class="Keyword">where</a>
    <a id="3766" href="decidability.html#3766" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3768" class="Symbol">:</a> <a id="3770" href="decidability.html#3656" class="Bound">A</a> <a id="3772" class="Symbol">→</a> <a id="3774" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3779" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3781" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3790" href="decidability.html#3766" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3792" class="Symbol">_</a> <a id="3794" class="Symbol">=</a> <a id="3796" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3801" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="3811" href="decidability.html#3811" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3813" class="Symbol">:</a> <a id="3815" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3820" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3822" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3827" class="Symbol">→</a> <a id="3829" href="decidability.html#3656" class="Bound">A</a>
    <a id="3835" href="decidability.html#3811" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3837" class="Symbol">_</a> <a id="3839" class="Symbol">=</a> <a id="3841" href="decidability.html#3733" class="Bound">x</a>

  <a id="3846" href="decidability.html#3675" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3848" class="Symbol">(</a><a id="3849" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3853" href="decidability.html#3853" class="Bound">ν</a><a id="3854" class="Symbol">)</a> <a id="3856" class="Symbol">=</a> <a id="3858" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3864" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3866" class="Symbol">(</a><a id="3867" href="decidability.html#3887" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3869" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3871" href="decidability.html#3936" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="3872" class="Symbol">)</a>
   <a id="3877" class="Keyword">where</a>
    <a id="3887" href="decidability.html#3887" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3889" class="Symbol">:</a> <a id="3891" href="decidability.html#3656" class="Bound">A</a> <a id="3893" class="Symbol">→</a> <a id="3895" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3901" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3903" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3912" href="decidability.html#3887" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3914" href="decidability.html#3914" class="Bound">x</a> <a id="3916" class="Symbol">=</a> <a id="3918" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3925" class="Symbol">(</a><a id="3926" href="decidability.html#3853" class="Bound">ν</a> <a id="3928" href="decidability.html#3914" class="Bound">x</a><a id="3929" class="Symbol">)</a>

    <a id="3936" href="decidability.html#3936" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3938" class="Symbol">:</a> <a id="3940" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3946" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3948" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3953" class="Symbol">→</a> <a id="3955" href="decidability.html#3656" class="Bound">A</a>
    <a id="3961" href="decidability.html#3936" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3963" class="Symbol">()</a>

  <a id="3969" href="decidability.html#3969" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3971" class="Symbol">:</a> <a id="3973" class="Symbol">(</a><a id="3974" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3976" href="decidability.html#3976" class="Bound">b</a> <a id="3978" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3980" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="3985" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3987" class="Symbol">(</a><a id="3988" href="decidability.html#3656" class="Bound">A</a> <a id="3990" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3992" href="decidability.html#3976" class="Bound">b</a> <a id="3994" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3996" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="4000" class="Symbol">))</a> <a id="4003" class="Symbol">→</a> <a id="4005" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="4018" href="decidability.html#3656" class="Bound">A</a>
  <a id="4022" href="decidability.html#3969" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="4024" class="Symbol">(</a><a id="4025" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="4030" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="4033" href="decidability.html#4033" class="Bound">α</a> <a id="4035" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4037" href="decidability.html#4037" class="Bound">β</a><a id="4038" class="Symbol">)</a> <a id="4040" class="Symbol">=</a> <a id="4042" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="4046" class="Symbol">(</a><a id="4047" href="decidability.html#4037" class="Bound">β</a> <a id="4049" class="Symbol">(</a><a id="4050" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4055" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="4059" class="Symbol">))</a>
  <a id="4064" href="decidability.html#3969" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="4066" class="Symbol">(</a><a id="4067" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="4073" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4075" href="decidability.html#4075" class="Bound">α</a> <a id="4077" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4079" href="decidability.html#4079" class="Bound">β</a><a id="4080" class="Symbol">)</a> <a id="4082" class="Symbol">=</a> <a id="4084" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4088" class="Symbol">(λ</a> <a id="4091" href="decidability.html#4091" class="Bound">x</a> <a id="4093" class="Symbol">→</a> <a id="4095" href="negation.html#3444" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="4113" class="Symbol">(</a><a id="4114" href="decidability.html#4075" class="Bound">α</a> <a id="4116" href="decidability.html#4091" class="Bound">x</a><a id="4117" class="Symbol">))</a>
</pre>
<h2 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h2>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is even. <!--
<pre class="Agda"><a id="4641" class="Keyword">module</a> <a id="4648" href="decidability.html#4648" class="Module">_</a> <a id="4650" class="Keyword">where</a>
 <a id="4657" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4683" href="decidability.html#4683" class="Function">is-even</a> <a id="4691" class="Symbol">:</a> <a id="4693" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a> <a id="4695" class="Symbol">→</a> <a id="4697" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
  <a id="4704" href="decidability.html#4683" class="Function">is-even</a> <a id="4712" href="decidability.html#4712" class="Bound">x</a> <a id="4714" class="Symbol">=</a> <a id="4716" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4718" href="decidability.html#4718" class="Bound">y</a> <a id="4720" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4722" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a> <a id="4724" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4726" href="decidability.html#4712" class="Bound">x</a> <a id="4728" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4730" class="Number">2</a> <a id="4732" href="natural-numbers-type.html#3036" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4734" href="decidability.html#4718" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="4936" href="decidability.html#4936" class="Function">check-even</a> <a id="4947" class="Symbol">:</a> <a id="4949" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a> <a id="4951" class="Symbol">→</a> <a id="4953" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a>
  <a id="4960" href="decidability.html#4936" class="Function">check-even</a> <a id="4971" class="Number">0</a>       <a id="4979" class="Symbol">=</a> <a id="4981" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4988" href="decidability.html#4936" class="Function">check-even</a> <a id="4999" class="Symbol">(</a><a id="5000" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="5004" href="decidability.html#5004" class="Bound">x</a><a id="5005" class="Symbol">)</a> <a id="5007" class="Symbol">=</a> <a id="5009" href="Bool.html#4153" data-type="Bool → Bool" class="Function">not</a> <a id="5013" class="Symbol">(</a><a id="5014" href="decidability.html#4936" class="Function">check-even</a> <a id="5025" href="decidability.html#5004" class="Bound">x</a><a id="5026" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5436" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5459" class="Symbol">:</a> <a id="5461" class="Symbol">{</a><a id="5462" href="decidability.html#5462" class="Bound">X</a> <a id="5464" class="Symbol">:</a> <a id="5466" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="5470" class="Symbol">}</a> <a id="5472" class="Symbol">→</a> <a id="5474" class="Symbol">(</a><a id="5475" href="decidability.html#5462" class="Bound">X</a> <a id="5477" class="Symbol">→</a> <a id="5479" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="5483" class="Symbol">)</a> <a id="5485" class="Symbol">→</a> <a id="5487" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
<a id="5492" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5515" class="Symbol">{</a><a id="5516" href="decidability.html#5516" class="Bound">X</a><a id="5517" class="Symbol">}</a> <a id="5519" href="decidability.html#5519" class="Bound">A</a> <a id="5521" class="Symbol">=</a> <a id="5523" class="Symbol">(</a><a id="5524" href="decidability.html#5524" class="Bound">x</a> <a id="5526" class="Symbol">:</a> <a id="5528" href="decidability.html#5516" class="Bound">X</a><a id="5529" class="Symbol">)</a> <a id="5531" class="Symbol">→</a> <a id="5533" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="5546" class="Symbol">(</a><a id="5547" href="decidability.html#5519" class="Bound">A</a> <a id="5549" href="decidability.html#5524" class="Bound">x</a><a id="5550" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="6074" href="decidability.html#6074" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6111" class="Symbol">:</a> <a id="6113" class="Symbol">{</a><a id="6114" href="decidability.html#6114" class="Bound">X</a> <a id="6116" class="Symbol">:</a> <a id="6118" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="6122" class="Symbol">}</a> <a id="6124" class="Symbol">(</a><a id="6125" href="decidability.html#6125" class="Bound">A</a> <a id="6127" class="Symbol">:</a> <a id="6129" href="decidability.html#6114" class="Bound">X</a> <a id="6131" class="Symbol">→</a> <a id="6133" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="6137" class="Symbol">)</a>
                                     <a id="6176" class="Symbol">→</a> <a id="6178" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6201" href="decidability.html#6125" class="Bound">A</a>
                                     <a id="6240" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6242" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6244" href="decidability.html#6244" class="Bound">α</a> <a id="6246" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6248" class="Symbol">(</a><a id="6249" href="decidability.html#6114" class="Bound">X</a> <a id="6251" class="Symbol">→</a> <a id="6253" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a><a id="6257" class="Symbol">)</a> <a id="6259" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6261" class="Symbol">((</a><a id="6263" href="decidability.html#6263" class="Bound">x</a> <a id="6265" class="Symbol">:</a> <a id="6267" href="decidability.html#6114" class="Bound">X</a><a id="6268" class="Symbol">)</a> <a id="6270" class="Symbol">→</a> <a id="6272" href="decidability.html#6125" class="Bound">A</a> <a id="6274" href="decidability.html#6263" class="Bound">x</a> <a id="6276" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6278" href="decidability.html#6244" class="Bound">α</a> <a id="6280" href="decidability.html#6263" class="Bound">x</a> <a id="6282" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6284" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="6288" class="Symbol">)</a>
<a id="6290" href="decidability.html#6074" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6327" class="Symbol">{</a><a id="6328" href="decidability.html#6328" class="Bound">X</a><a id="6329" class="Symbol">}</a> <a id="6331" href="decidability.html#6331" class="Bound">A</a> <a id="6333" class="Symbol">=</a> <a id="6335" href="decidability.html#6350" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6337" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6339" href="decidability.html#6995" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6342" class="Keyword">where</a>
  <a id="6350" href="decidability.html#6350" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6352" class="Symbol">:</a> <a id="6354" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6377" href="decidability.html#6331" class="Bound">A</a> <a id="6379" class="Symbol">→</a> <a id="6381" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6383" href="decidability.html#6383" class="Bound">α</a> <a id="6385" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6387" class="Symbol">(</a><a id="6388" href="decidability.html#6328" class="Bound">X</a> <a id="6390" class="Symbol">→</a> <a id="6392" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a><a id="6396" class="Symbol">)</a> <a id="6398" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6400" class="Symbol">((</a><a id="6402" href="decidability.html#6402" class="Bound">x</a> <a id="6404" class="Symbol">:</a> <a id="6406" href="decidability.html#6328" class="Bound">X</a><a id="6407" class="Symbol">)</a> <a id="6409" class="Symbol">→</a> <a id="6411" href="decidability.html#6331" class="Bound">A</a> <a id="6413" href="decidability.html#6402" class="Bound">x</a> <a id="6415" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6417" href="decidability.html#6383" class="Bound">α</a> <a id="6419" href="decidability.html#6402" class="Bound">x</a> <a id="6421" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6423" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="6427" class="Symbol">)</a>
  <a id="6431" href="decidability.html#6350" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6433" href="decidability.html#6433" class="Bound">d</a> <a id="6435" class="Symbol">=</a> <a id="6437" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6439" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6441" href="decidability.html#6628" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6446" class="Keyword">where</a>
    <a id="6456" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6458" class="Symbol">:</a> <a id="6460" href="decidability.html#6328" class="Bound">X</a> <a id="6462" class="Symbol">→</a> <a id="6464" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a>
    <a id="6473" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6475" href="decidability.html#6475" class="Bound">x</a> <a id="6477" class="Symbol">=</a> <a id="6479" href="sums.html#2637" data-type="Σ B → A" class="Field">pr₁</a> <a id="6483" class="Symbol">(</a><a id="6484" href="binary-products.html#1663" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6499" href="decidability.html#6525" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6501" class="Symbol">(</a><a id="6502" href="decidability.html#6433" class="Bound">d</a> <a id="6504" href="decidability.html#6475" class="Bound">x</a><a id="6505" class="Symbol">))</a>
     <a id="6513" class="Keyword">where</a>
      <a id="6525" href="decidability.html#6525" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6527" class="Symbol">:</a> <a id="6529" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="6542" class="Symbol">(</a><a id="6543" href="decidability.html#6331" class="Bound">A</a> <a id="6545" href="decidability.html#6475" class="Bound">x</a><a id="6546" class="Symbol">)</a> <a id="6548" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6550" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6552" href="decidability.html#6552" class="Bound">b</a> <a id="6554" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6556" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="6561" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6563" class="Symbol">(</a><a id="6564" href="decidability.html#6331" class="Bound">A</a> <a id="6566" href="decidability.html#6475" class="Bound">x</a> <a id="6568" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6570" href="decidability.html#6552" class="Bound">b</a> <a id="6572" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6574" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="6578" class="Symbol">)</a>
      <a id="6586" href="decidability.html#6525" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6588" class="Symbol">=</a> <a id="6590" href="decidability.html#3542" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6617" class="Symbol">(</a><a id="6618" href="decidability.html#6331" class="Bound">A</a> <a id="6620" href="decidability.html#6475" class="Bound">x</a><a id="6621" class="Symbol">)</a>

    <a id="6628" href="decidability.html#6628" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6630" class="Symbol">:</a> <a id="6632" class="Symbol">(</a><a id="6633" href="decidability.html#6633" class="Bound">x</a> <a id="6635" class="Symbol">:</a> <a id="6637" href="decidability.html#6328" class="Bound">X</a><a id="6638" class="Symbol">)</a> <a id="6640" class="Symbol">→</a> <a id="6642" href="decidability.html#6331" class="Bound">A</a> <a id="6644" href="decidability.html#6633" class="Bound">x</a> <a id="6646" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6648" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6650" href="decidability.html#6633" class="Bound">x</a> <a id="6652" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6654" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6663" href="decidability.html#6628" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6665" href="decidability.html#6665" class="Bound">x</a> <a id="6667" class="Symbol">=</a> <a id="6669" href="decidability.html#6875" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6671" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6673" href="decidability.html#6937" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6680" class="Keyword">where</a>
      <a id="6692" href="decidability.html#6692" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6694" class="Symbol">:</a> <a id="6696" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="6709" class="Symbol">(</a><a id="6710" href="decidability.html#6331" class="Bound">A</a> <a id="6712" href="decidability.html#6665" class="Bound">x</a><a id="6713" class="Symbol">)</a> <a id="6715" class="Symbol">→</a> <a id="6717" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6719" href="decidability.html#6719" class="Bound">b</a> <a id="6721" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6723" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="6728" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6730" class="Symbol">(</a><a id="6731" href="decidability.html#6331" class="Bound">A</a> <a id="6733" href="decidability.html#6665" class="Bound">x</a> <a id="6735" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6737" href="decidability.html#6719" class="Bound">b</a> <a id="6739" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6741" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="6745" class="Symbol">)</a>
      <a id="6753" href="decidability.html#6692" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6755" class="Symbol">=</a> <a id="6757" href="binary-products.html#1663" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6772" class="Symbol">(</a><a id="6773" href="decidability.html#3542" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6800" class="Symbol">(</a><a id="6801" href="decidability.html#6331" class="Bound">A</a> <a id="6803" href="decidability.html#6665" class="Bound">x</a><a id="6804" class="Symbol">))</a>

      <a id="6814" href="decidability.html#6814" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6817" class="Symbol">:</a> <a id="6819" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6821" href="decidability.html#6821" class="Bound">b</a> <a id="6823" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6825" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="6830" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6832" class="Symbol">(</a><a id="6833" href="decidability.html#6331" class="Bound">A</a> <a id="6835" href="decidability.html#6665" class="Bound">x</a> <a id="6837" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6839" href="decidability.html#6821" class="Bound">b</a> <a id="6841" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6843" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="6847" class="Symbol">)</a>
      <a id="6855" href="decidability.html#6814" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6858" class="Symbol">=</a> <a id="6860" href="decidability.html#6692" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6862" class="Symbol">(</a><a id="6863" href="decidability.html#6433" class="Bound">d</a> <a id="6865" href="decidability.html#6665" class="Bound">x</a><a id="6866" class="Symbol">)</a>

      <a id="6875" href="decidability.html#6875" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6877" class="Symbol">:</a> <a id="6879" href="decidability.html#6331" class="Bound">A</a> <a id="6881" href="decidability.html#6665" class="Bound">x</a> <a id="6883" class="Symbol">→</a> <a id="6885" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6887" href="decidability.html#6665" class="Bound">x</a> <a id="6889" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6891" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="6902" href="decidability.html#6875" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6904" class="Symbol">=</a> <a id="6906" href="binary-products.html#1663" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6921" class="Symbol">(</a><a id="6922" href="sums.html#2647" data-type="(r : Σ B) → B (pr₁ r)" class="Field">pr₂</a> <a id="6926" href="decidability.html#6814" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6928" class="Symbol">)</a>

      <a id="6937" href="decidability.html#6937" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6939" class="Symbol">:</a> <a id="6941" href="decidability.html#6456" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6943" href="decidability.html#6665" class="Bound">x</a> <a id="6945" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6947" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="6952" class="Symbol">→</a> <a id="6954" href="decidability.html#6331" class="Bound">A</a> <a id="6956" href="decidability.html#6665" class="Bound">x</a>
      <a id="6964" href="decidability.html#6937" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6966" class="Symbol">=</a> <a id="6968" href="binary-products.html#1735" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="6983" class="Symbol">(</a><a id="6984" href="sums.html#2647" data-type="(r : Σ B) → B (pr₁ r)" class="Field">pr₂</a> <a id="6988" href="decidability.html#6814" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6990" class="Symbol">)</a>

  <a id="6995" href="decidability.html#6995" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6997" class="Symbol">:</a> <a id="6999" class="Symbol">(</a><a id="7000" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7002" href="decidability.html#7002" class="Bound">α</a> <a id="7004" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7006" class="Symbol">(</a><a id="7007" href="decidability.html#6328" class="Bound">X</a> <a id="7009" class="Symbol">→</a> <a id="7011" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a><a id="7015" class="Symbol">)</a> <a id="7017" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7019" class="Symbol">((</a><a id="7021" href="decidability.html#7021" class="Bound">x</a> <a id="7023" class="Symbol">:</a> <a id="7025" href="decidability.html#6328" class="Bound">X</a><a id="7026" class="Symbol">)</a> <a id="7028" class="Symbol">→</a> <a id="7030" href="decidability.html#6331" class="Bound">A</a> <a id="7032" href="decidability.html#7021" class="Bound">x</a> <a id="7034" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7036" href="decidability.html#7002" class="Bound">α</a> <a id="7038" href="decidability.html#7021" class="Bound">x</a> <a id="7040" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7042" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="7046" class="Symbol">))</a> <a id="7049" class="Symbol">→</a> <a id="7051" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7074" href="decidability.html#6331" class="Bound">A</a>
  <a id="7078" href="decidability.html#6995" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="7080" class="Symbol">(</a><a id="7081" href="decidability.html#7081" class="Bound">α</a> <a id="7083" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7085" href="decidability.html#7085" class="Bound">ϕ</a><a id="7086" class="Symbol">)</a> <a id="7088" class="Symbol">=</a> <a id="7090" href="decidability.html#7105" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="7095" class="Keyword">where</a>
    <a id="7105" href="decidability.html#7105" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7107" class="Symbol">:</a> <a id="7109" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7132" href="decidability.html#6331" class="Bound">A</a>
    <a id="7138" href="decidability.html#7105" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7140" href="decidability.html#7140" class="Bound">x</a> <a id="7142" class="Symbol">=</a> <a id="7144" href="decidability.html#7354" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7153" class="Keyword">where</a>
      <a id="7165" href="decidability.html#7165" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7167" class="Symbol">:</a> <a id="7169" class="Symbol">(</a><a id="7170" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7172" href="decidability.html#7172" class="Bound">b</a> <a id="7174" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7176" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="7181" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7183" class="Symbol">(</a><a id="7184" href="decidability.html#6331" class="Bound">A</a> <a id="7186" href="decidability.html#7140" class="Bound">x</a> <a id="7188" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7190" href="decidability.html#7172" class="Bound">b</a> <a id="7192" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7194" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="7198" class="Symbol">))</a> <a id="7201" class="Symbol">→</a> <a id="7203" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="7216" class="Symbol">(</a><a id="7217" href="decidability.html#6331" class="Bound">A</a> <a id="7219" href="decidability.html#7140" class="Bound">x</a><a id="7220" class="Symbol">)</a>
      <a id="7228" href="decidability.html#7165" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7230" class="Symbol">=</a> <a id="7232" href="binary-products.html#1735" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7247" class="Symbol">(</a><a id="7248" href="decidability.html#3542" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7275" class="Symbol">(</a><a id="7276" href="decidability.html#6331" class="Bound">A</a> <a id="7278" href="decidability.html#7140" class="Bound">x</a><a id="7279" class="Symbol">))</a>

      <a id="7289" href="decidability.html#7289" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7292" class="Symbol">:</a> <a id="7294" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7296" href="decidability.html#7296" class="Bound">b</a> <a id="7298" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7300" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a> <a id="7305" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7307" class="Symbol">(</a><a id="7308" href="decidability.html#6331" class="Bound">A</a> <a id="7310" href="decidability.html#7140" class="Bound">x</a> <a id="7312" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7314" href="decidability.html#7296" class="Bound">b</a> <a id="7316" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7318" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="7322" class="Symbol">)</a>
      <a id="7330" href="decidability.html#7289" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7333" class="Symbol">=</a> <a id="7335" class="Symbol">(</a><a id="7336" href="decidability.html#7081" class="Bound">α</a> <a id="7338" href="decidability.html#7140" class="Bound">x</a> <a id="7340" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7342" href="decidability.html#7085" class="Bound">ϕ</a> <a id="7344" href="decidability.html#7140" class="Bound">x</a><a id="7345" class="Symbol">)</a>

      <a id="7354" href="decidability.html#7354" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7358" class="Symbol">:</a> <a id="7360" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="7373" class="Symbol">(</a><a id="7374" href="decidability.html#6331" class="Bound">A</a> <a id="7376" href="decidability.html#7140" class="Bound">x</a><a id="7377" class="Symbol">)</a>
      <a id="7385" href="decidability.html#7354" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7389" class="Symbol">=</a> <a id="7391" href="decidability.html#7165" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7393" href="decidability.html#7289" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h2 id="preservation-of-decidability">Preservation of decidability</h2>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="7934" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7948" class="Symbol">:</a> <a id="7950" class="Symbol">{</a><a id="7951" href="decidability.html#7951" class="Bound">A</a> <a id="7953" href="decidability.html#7953" class="Bound">B</a> <a id="7955" class="Symbol">:</a> <a id="7957" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="7961" class="Symbol">}</a> <a id="7963" class="Symbol">→</a> <a id="7965" class="Symbol">(</a><a id="7966" href="decidability.html#7951" class="Bound">A</a> <a id="7968" class="Symbol">→</a> <a id="7970" href="decidability.html#7953" class="Bound">B</a><a id="7971" class="Symbol">)</a> <a id="7973" class="Symbol">→</a> <a id="7975" class="Symbol">(</a><a id="7976" href="decidability.html#7953" class="Bound">B</a> <a id="7978" class="Symbol">→</a> <a id="7980" href="decidability.html#7951" class="Bound">A</a><a id="7981" class="Symbol">)</a> <a id="7983" class="Symbol">→</a> <a id="7985" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="7998" href="decidability.html#7951" class="Bound">A</a> <a id="8000" class="Symbol">→</a> <a id="8002" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8015" href="decidability.html#7953" class="Bound">B</a>
<a id="8017" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8031" href="decidability.html#8031" class="Bound">f</a> <a id="8033" href="decidability.html#8033" class="Bound">g</a> <a id="8035" class="Symbol">(</a><a id="8036" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8040" href="decidability.html#8040" class="Bound">x</a><a id="8041" class="Symbol">)</a> <a id="8043" class="Symbol">=</a> <a id="8045" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8049" class="Symbol">(</a><a id="8050" href="decidability.html#8031" class="Bound">f</a> <a id="8052" href="decidability.html#8040" class="Bound">x</a><a id="8053" class="Symbol">)</a>
<a id="8055" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8069" href="decidability.html#8069" class="Bound">f</a> <a id="8071" href="decidability.html#8071" class="Bound">g</a> <a id="8073" class="Symbol">(</a><a id="8074" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8078" href="decidability.html#8078" class="Bound">h</a><a id="8079" class="Symbol">)</a> <a id="8081" class="Symbol">=</a> <a id="8083" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8087" class="Symbol">(λ</a> <a id="8090" href="decidability.html#8090" class="Bound">y</a> <a id="8092" class="Symbol">→</a> <a id="8094" href="decidability.html#8078" class="Bound">h</a> <a id="8096" class="Symbol">(</a><a id="8097" href="decidability.html#8071" class="Bound">g</a> <a id="8099" href="decidability.html#8090" class="Bound">y</a><a id="8100" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="8104" href="decidability.html#8104" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8128" class="Symbol">:</a> <a id="8130" class="Symbol">{</a><a id="8131" href="decidability.html#8131" class="Bound">A</a> <a id="8133" href="decidability.html#8133" class="Bound">B</a> <a id="8135" class="Symbol">:</a> <a id="8137" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="8141" class="Symbol">}</a> <a id="8143" class="Symbol">→</a> <a id="8145" class="Symbol">(</a><a id="8146" href="decidability.html#8131" class="Bound">A</a> <a id="8148" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8150" href="decidability.html#8133" class="Bound">B</a><a id="8151" class="Symbol">)</a> <a id="8153" class="Symbol">→</a> <a id="8155" class="Symbol">(</a><a id="8156" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8169" href="decidability.html#8131" class="Bound">A</a> <a id="8171" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8173" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8186" href="decidability.html#8133" class="Bound">B</a><a id="8187" class="Symbol">)</a>
<a id="8189" href="decidability.html#8104" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8213" class="Symbol">(</a><a id="8214" href="decidability.html#8214" class="Bound">f</a> <a id="8216" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8218" href="decidability.html#8218" class="Bound">g</a><a id="8219" class="Symbol">)</a> <a id="8221" class="Symbol">=</a> <a id="8223" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8237" href="decidability.html#8214" class="Bound">f</a> <a id="8239" href="decidability.html#8218" class="Bound">g</a> <a id="8241" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8243" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8257" href="decidability.html#8218" class="Bound">g</a> <a id="8259" href="decidability.html#8214" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8284" href="decidability.html#8284" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8299" class="Symbol">:</a> <a id="8301" class="Symbol">{</a><a id="8302" href="decidability.html#8302" class="Bound">A</a> <a id="8304" href="decidability.html#8304" class="Bound">B</a> <a id="8306" class="Symbol">:</a> <a id="8308" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="8312" class="Symbol">}</a> <a id="8314" class="Symbol">→</a> <a id="8316" class="Symbol">(</a><a id="8317" href="decidability.html#8302" class="Bound">A</a> <a id="8319" class="Symbol">→</a> <a id="8321" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="8323" href="decidability.html#8304" class="Bound">B</a><a id="8324" class="Symbol">)</a> <a id="8326" class="Symbol">→</a> <a id="8328" class="Symbol">(</a><a id="8329" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="8331" href="decidability.html#8302" class="Bound">A</a> <a id="8333" class="Symbol">→</a> <a id="8335" href="decidability.html#8304" class="Bound">B</a><a id="8336" class="Symbol">)</a> <a id="8338" class="Symbol">→</a> <a id="8340" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8353" href="decidability.html#8302" class="Bound">A</a> <a id="8355" class="Symbol">→</a> <a id="8357" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8370" href="decidability.html#8304" class="Bound">B</a>
<a id="8372" href="decidability.html#8284" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8387" href="decidability.html#8387" class="Bound">f</a> <a id="8389" href="decidability.html#8389" class="Bound">g</a> <a id="8391" class="Symbol">(</a><a id="8392" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8396" href="decidability.html#8396" class="Bound">x</a><a id="8397" class="Symbol">)</a> <a id="8399" class="Symbol">=</a> <a id="8401" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8405" class="Symbol">(</a><a id="8406" href="decidability.html#8387" class="Bound">f</a> <a id="8408" href="decidability.html#8396" class="Bound">x</a><a id="8409" class="Symbol">)</a>
<a id="8411" href="decidability.html#8284" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8426" href="decidability.html#8426" class="Bound">f</a> <a id="8428" href="decidability.html#8428" class="Bound">g</a> <a id="8430" class="Symbol">(</a><a id="8431" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8435" href="decidability.html#8435" class="Bound">h</a><a id="8436" class="Symbol">)</a> <a id="8438" class="Symbol">=</a> <a id="8440" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8444" class="Symbol">(</a><a id="8445" href="decidability.html#8428" class="Bound">g</a> <a id="8447" href="decidability.html#8435" class="Bound">h</a><a id="8448" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8463" href="decidability.html#8463" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8491" class="Symbol">:</a> <a id="8493" class="Symbol">{</a><a id="8494" href="decidability.html#8494" class="Bound">A</a> <a id="8496" class="Symbol">:</a> <a id="8498" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="8502" class="Symbol">}</a> <a id="8504" class="Symbol">→</a> <a id="8506" href="decidability.html#8494" class="Bound">A</a> <a id="8508" class="Symbol">→</a> <a id="8510" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8523" href="decidability.html#8494" class="Bound">A</a>
<a id="8525" href="decidability.html#8463" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8553" class="Symbol">=</a> <a id="8555" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8560" href="decidability.html#8560" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8586" class="Symbol">:</a> <a id="8588" class="Symbol">{</a><a id="8589" href="decidability.html#8589" class="Bound">A</a> <a id="8591" class="Symbol">:</a> <a id="8593" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="8597" class="Symbol">}</a> <a id="8599" class="Symbol">→</a> <a id="8601" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="8603" href="decidability.html#8589" class="Bound">A</a> <a id="8605" class="Symbol">→</a> <a id="8607" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8620" href="decidability.html#8589" class="Bound">A</a>
<a id="8622" href="decidability.html#8560" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8648" class="Symbol">=</a> <a id="8650" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8655" href="decidability.html#8655" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8670" class="Symbol">:</a> <a id="8672" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8685" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a>
<a id="8687" href="decidability.html#8655" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8702" class="Symbol">=</a> <a id="8704" href="decidability.html#8463" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8732" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8735" href="decidability.html#8735" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8750" class="Symbol">:</a> <a id="8752" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8765" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a>
<a id="8767" href="decidability.html#8735" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8782" class="Symbol">=</a> <a id="8784" href="decidability.html#8560" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8810" href="empty-type.html#3726" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="8822" href="decidability.html#8822" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8847" class="Symbol">:</a> <a id="8849" class="Symbol">{</a><a id="8850" href="decidability.html#8850" class="Bound">A</a> <a id="8852" href="decidability.html#8852" class="Bound">B</a> <a id="8854" class="Symbol">:</a> <a id="8856" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="8860" class="Symbol">}</a>
                         <a id="8887" class="Symbol">→</a> <a id="8889" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8902" href="decidability.html#8850" class="Bound">A</a>
                         <a id="8929" class="Symbol">→</a> <a id="8931" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8944" href="decidability.html#8852" class="Bound">B</a>
                         <a id="8971" class="Symbol">→</a> <a id="8973" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="8986" class="Symbol">(</a><a id="8987" href="decidability.html#8850" class="Bound">A</a> <a id="8989" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="8991" href="decidability.html#8852" class="Bound">B</a><a id="8992" class="Symbol">)</a>
<a id="8994" href="decidability.html#8822" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9019" class="Symbol">(</a><a id="9020" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9024" href="decidability.html#9024" class="Bound">x</a><a id="9025" class="Symbol">)</a> <a id="9027" class="Symbol">_</a>       <a id="9035" class="Symbol">=</a> <a id="9037" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9041" class="Symbol">(</a><a id="9042" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9046" href="decidability.html#9024" class="Bound">x</a><a id="9047" class="Symbol">)</a>
<a id="9049" href="decidability.html#8822" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9074" class="Symbol">(</a><a id="9075" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9079" class="Symbol">_)</a> <a id="9082" class="Symbol">(</a><a id="9083" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9087" href="decidability.html#9087" class="Bound">y</a><a id="9088" class="Symbol">)</a> <a id="9090" class="Symbol">=</a> <a id="9092" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9096" class="Symbol">(</a><a id="9097" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9101" href="decidability.html#9087" class="Bound">y</a><a id="9102" class="Symbol">)</a>
<a id="9104" href="decidability.html#8822" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="9129" class="Symbol">(</a><a id="9130" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9134" href="decidability.html#9134" class="Bound">h</a><a id="9135" class="Symbol">)</a> <a id="9137" class="Symbol">(</a><a id="9138" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9142" href="decidability.html#9142" class="Bound">k</a><a id="9143" class="Symbol">)</a> <a id="9145" class="Symbol">=</a> <a id="9147" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9151" class="Symbol">(</a><a id="9152" href="binary-sums.html#3896" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9166" href="decidability.html#9134" class="Bound">h</a> <a id="9168" href="decidability.html#9142" class="Bound">k</a><a id="9169" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9172" href="decidability.html#9172" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9197" class="Symbol">:</a> <a id="9199" class="Symbol">{</a><a id="9200" href="decidability.html#9200" class="Bound">A</a> <a id="9202" href="decidability.html#9202" class="Bound">B</a> <a id="9204" class="Symbol">:</a> <a id="9206" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="9210" class="Symbol">}</a>
                         <a id="9237" class="Symbol">→</a> <a id="9239" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9252" href="decidability.html#9200" class="Bound">A</a>
                         <a id="9279" class="Symbol">→</a> <a id="9281" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9294" href="decidability.html#9202" class="Bound">B</a>
                         <a id="9321" class="Symbol">→</a> <a id="9323" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9336" class="Symbol">(</a><a id="9337" href="decidability.html#9200" class="Bound">A</a> <a id="9339" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9341" href="decidability.html#9202" class="Bound">B</a><a id="9342" class="Symbol">)</a>
<a id="9344" href="decidability.html#9172" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9369" class="Symbol">(</a><a id="9370" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9374" href="decidability.html#9374" class="Bound">x</a><a id="9375" class="Symbol">)</a> <a id="9377" class="Symbol">(</a><a id="9378" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9382" href="decidability.html#9382" class="Bound">y</a><a id="9383" class="Symbol">)</a> <a id="9385" class="Symbol">=</a> <a id="9387" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9391" class="Symbol">(</a><a id="9392" href="decidability.html#9374" class="Bound">x</a> <a id="9394" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9396" href="decidability.html#9382" class="Bound">y</a><a id="9397" class="Symbol">)</a>
<a id="9399" href="decidability.html#9172" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9424" class="Symbol">(</a><a id="9425" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9429" class="Symbol">_)</a> <a id="9432" class="Symbol">(</a><a id="9433" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9437" href="decidability.html#9437" class="Bound">k</a><a id="9438" class="Symbol">)</a> <a id="9440" class="Symbol">=</a> <a id="9442" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9446" class="Symbol">(λ</a> <a id="9449" class="Symbol">(</a><a id="9450" href="decidability.html#9450" class="Bound">x</a> <a id="9452" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9454" href="decidability.html#9454" class="Bound">y</a><a id="9455" class="Symbol">)</a> <a id="9457" class="Symbol">→</a> <a id="9459" href="decidability.html#9437" class="Bound">k</a> <a id="9461" href="decidability.html#9454" class="Bound">y</a><a id="9462" class="Symbol">)</a>
<a id="9464" href="decidability.html#9172" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9489" class="Symbol">(</a><a id="9490" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9494" href="decidability.html#9494" class="Bound">h</a><a id="9495" class="Symbol">)</a> <a id="9497" class="Symbol">_</a>       <a id="9505" class="Symbol">=</a> <a id="9507" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9511" class="Symbol">(λ</a> <a id="9514" class="Symbol">(</a><a id="9515" href="decidability.html#9515" class="Bound">x</a> <a id="9517" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9519" href="decidability.html#9519" class="Bound">y</a><a id="9520" class="Symbol">)</a> <a id="9522" class="Symbol">→</a> <a id="9524" href="decidability.html#9494" class="Bound">h</a> <a id="9526" href="decidability.html#9515" class="Bound">x</a><a id="9527" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9530" href="decidability.html#9530" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9555" class="Symbol">:</a> <a id="9557" class="Symbol">{</a><a id="9558" href="decidability.html#9558" class="Bound">A</a> <a id="9560" href="decidability.html#9560" class="Bound">B</a> <a id="9562" class="Symbol">:</a> <a id="9564" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="9568" class="Symbol">}</a>
                         <a id="9595" class="Symbol">→</a> <a id="9597" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9610" href="decidability.html#9558" class="Bound">A</a>
                         <a id="9637" class="Symbol">→</a> <a id="9639" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9652" href="decidability.html#9560" class="Bound">B</a>
                         <a id="9679" class="Symbol">→</a> <a id="9681" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9694" class="Symbol">(</a><a id="9695" href="decidability.html#9558" class="Bound">A</a> <a id="9697" class="Symbol">→</a> <a id="9699" href="decidability.html#9560" class="Bound">B</a><a id="9700" class="Symbol">)</a>
<a id="9702" href="decidability.html#9530" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9727" class="Symbol">_</a>       <a id="9735" class="Symbol">(</a><a id="9736" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9740" href="decidability.html#9740" class="Bound">y</a><a id="9741" class="Symbol">)</a> <a id="9743" class="Symbol">=</a> <a id="9745" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9749" class="Symbol">(λ</a> <a id="9752" href="decidability.html#9752" class="Bound">_</a> <a id="9754" class="Symbol">→</a> <a id="9756" href="decidability.html#9740" class="Bound">y</a><a id="9757" class="Symbol">)</a>
<a id="9759" href="decidability.html#9530" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9784" class="Symbol">(</a><a id="9785" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9789" href="decidability.html#9789" class="Bound">x</a><a id="9790" class="Symbol">)</a> <a id="9792" class="Symbol">(</a><a id="9793" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9797" href="decidability.html#9797" class="Bound">k</a><a id="9798" class="Symbol">)</a> <a id="9800" class="Symbol">=</a> <a id="9802" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9806" class="Symbol">(λ</a> <a id="9809" href="decidability.html#9809" class="Bound">f</a> <a id="9811" class="Symbol">→</a> <a id="9813" href="decidability.html#9797" class="Bound">k</a> <a id="9815" class="Symbol">(</a><a id="9816" href="decidability.html#9809" class="Bound">f</a> <a id="9818" href="decidability.html#9789" class="Bound">x</a><a id="9819" class="Symbol">))</a>
<a id="9822" href="decidability.html#9530" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9847" class="Symbol">(</a><a id="9848" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9852" href="decidability.html#9852" class="Bound">h</a><a id="9853" class="Symbol">)</a> <a id="9855" class="Symbol">(</a><a id="9856" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9860" href="decidability.html#9860" class="Bound">k</a><a id="9861" class="Symbol">)</a> <a id="9863" class="Symbol">=</a> <a id="9865" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9869" class="Symbol">(λ</a> <a id="9872" href="decidability.html#9872" class="Bound">x</a> <a id="9874" class="Symbol">→</a> <a id="9876" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="9883" class="Symbol">(</a><a id="9884" href="decidability.html#9852" class="Bound">h</a> <a id="9886" href="decidability.html#9872" class="Bound">x</a><a id="9887" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="9891" href="decidability.html#9891" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9916" class="Symbol">:</a> <a id="9918" class="Symbol">{</a><a id="9919" href="decidability.html#9919" class="Bound">A</a> <a id="9921" class="Symbol">:</a> <a id="9923" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="9927" class="Symbol">}</a>
                         <a id="9954" class="Symbol">→</a> <a id="9956" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="9969" href="decidability.html#9919" class="Bound">A</a>
                         <a id="9996" class="Symbol">→</a> <a id="9998" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="10011" class="Symbol">(</a><a id="10012" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="10014" href="decidability.html#9919" class="Bound">A</a><a id="10015" class="Symbol">)</a>
<a id="10017" href="decidability.html#9891" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="10042" href="decidability.html#10042" class="Bound">d</a> <a id="10044" class="Symbol">=</a> <a id="10046" href="decidability.html#9530" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="10071" href="decidability.html#10042" class="Bound">d</a> <a id="10073" href="decidability.html#8735" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h2 id="exhaustively-searchable-types">Exhaustively searchable
types</h2>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10600" href="decidability.html#10600" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10627" class="Symbol">:</a> <a id="10629" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a> <a id="10634" class="Symbol">→</a> <a id="10636" href="general-notation.html#829" data-type="Set₂" class="Function">Type₁</a>
<a id="10642" href="decidability.html#10600" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10669" href="decidability.html#10669" class="Bound">X</a> <a id="10671" class="Symbol">=</a> <a id="10673" class="Symbol">(</a><a id="10674" href="decidability.html#10674" class="Bound">A</a> <a id="10676" class="Symbol">:</a> <a id="10678" href="decidability.html#10669" class="Bound">X</a> <a id="10680" class="Symbol">→</a> <a id="10682" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="10686" class="Symbol">)</a>
                             <a id="10717" class="Symbol">→</a> <a id="10719" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10742" href="decidability.html#10674" class="Bound">A</a>
                             <a id="10773" class="Symbol">→</a> <a id="10775" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="10788" class="Symbol">(</a><a id="10789" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="10791" href="decidability.html#10791" class="Bound">x</a> <a id="10793" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="10795" href="decidability.html#10669" class="Bound">X</a> <a id="10797" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="10799" href="decidability.html#10674" class="Bound">A</a> <a id="10801" href="decidability.html#10791" class="Bound">x</a><a id="10802" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12221" href="decidability.html#12221" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12238" class="Symbol">:</a> <a id="12240" class="Symbol">(</a><a id="12241" href="decidability.html#12241" class="Bound">X</a> <a id="12243" class="Symbol">:</a> <a id="12245" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="12249" class="Symbol">)</a>
                 <a id="12268" class="Symbol">→</a> <a id="12270" href="decidability.html#10600" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12297" href="decidability.html#12241" class="Bound">X</a>
                 <a id="12316" class="Symbol">→</a> <a id="12318" class="Symbol">(</a><a id="12319" href="decidability.html#12319" class="Bound">A</a> <a id="12321" class="Symbol">:</a> <a id="12323" href="decidability.html#12241" class="Bound">X</a> <a id="12325" class="Symbol">→</a> <a id="12327" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="12331" class="Symbol">)</a>
                 <a id="12350" class="Symbol">→</a> <a id="12352" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12375" href="decidability.html#12319" class="Bound">A</a>
                 <a id="12394" class="Symbol">→</a> <a id="12396" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="12409" class="Symbol">(</a><a id="12410" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12412" href="decidability.html#12412" class="Bound">x</a> <a id="12414" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12416" href="decidability.html#12241" class="Bound">X</a> <a id="12418" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12420" href="decidability.html#12319" class="Bound">A</a> <a id="12422" href="decidability.html#12412" class="Bound">x</a><a id="12423" class="Symbol">)</a>
<a id="12425" href="decidability.html#12221" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12442" href="decidability.html#12442" class="Bound">X</a> <a id="12444" href="decidability.html#12444" class="Bound">s</a> <a id="12446" href="decidability.html#12446" class="Bound">A</a> <a id="12448" href="decidability.html#12448" class="Bound">d</a> <a id="12450" class="Symbol">=</a> <a id="12452" href="decidability.html#12936" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12456" class="Keyword">where</a>
  <a id="12464" href="decidability.html#12464" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12466" class="Symbol">:</a> <a id="12468" href="decidability.html#5436" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12491" class="Symbol">(λ</a> <a id="12494" href="decidability.html#12494" class="Bound">x</a> <a id="12496" class="Symbol">→</a> <a id="12498" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12500" class="Symbol">(</a><a id="12501" href="decidability.html#12446" class="Bound">A</a> <a id="12503" href="decidability.html#12494" class="Bound">x</a><a id="12504" class="Symbol">))</a>
  <a id="12509" href="decidability.html#12464" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12511" href="decidability.html#12511" class="Bound">x</a> <a id="12513" class="Symbol">=</a> <a id="12515" href="decidability.html#9891" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12540" class="Symbol">(</a><a id="12541" href="decidability.html#12448" class="Bound">d</a> <a id="12543" href="decidability.html#12511" class="Bound">x</a><a id="12544" class="Symbol">)</a>

  <a id="12549" href="decidability.html#12549" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12552" class="Symbol">:</a> <a id="12554" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="12567" class="Symbol">(</a><a id="12568" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12570" href="decidability.html#12570" class="Bound">x</a> <a id="12572" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12574" href="decidability.html#12442" class="Bound">X</a> <a id="12576" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12578" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12580" class="Symbol">(</a><a id="12581" href="decidability.html#12446" class="Bound">A</a> <a id="12583" href="decidability.html#12570" class="Bound">x</a><a id="12584" class="Symbol">))</a>
  <a id="12589" href="decidability.html#12549" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12592" class="Symbol">=</a> <a id="12594" href="decidability.html#12444" class="Bound">s</a> <a id="12596" class="Symbol">(λ</a> <a id="12599" href="decidability.html#12599" class="Bound">x</a> <a id="12601" class="Symbol">→</a> <a id="12603" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12605" class="Symbol">(</a><a id="12606" href="decidability.html#12446" class="Bound">A</a> <a id="12608" href="decidability.html#12599" class="Bound">x</a><a id="12609" class="Symbol">))</a> <a id="12612" href="decidability.html#12464" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12617" href="decidability.html#12617" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12621" class="Symbol">:</a> <a id="12623" class="Symbol">(</a><a id="12624" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12626" href="decidability.html#12626" class="Bound">x</a> <a id="12628" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12630" href="decidability.html#12442" class="Bound">X</a> <a id="12632" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12634" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12636" class="Symbol">(</a><a id="12637" href="decidability.html#12446" class="Bound">A</a> <a id="12639" href="decidability.html#12626" class="Bound">x</a><a id="12640" class="Symbol">))</a> <a id="12643" class="Symbol">→</a> <a id="12645" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12647" class="Symbol">(</a><a id="12648" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12650" href="decidability.html#12650" class="Bound">x</a> <a id="12652" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12654" href="decidability.html#12442" class="Bound">X</a> <a id="12656" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12658" href="decidability.html#12446" class="Bound">A</a> <a id="12660" href="decidability.html#12650" class="Bound">x</a><a id="12661" class="Symbol">)</a>
  <a id="12665" href="decidability.html#12617" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12669" class="Symbol">(</a><a id="12670" href="decidability.html#12670" class="Bound">x</a> <a id="12672" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12674" href="decidability.html#12674" class="Bound">f</a><a id="12675" class="Symbol">)</a> <a id="12677" href="decidability.html#12677" class="Bound">g</a> <a id="12679" class="Symbol">=</a> <a id="12681" href="decidability.html#12674" class="Bound">f</a> <a id="12683" class="Symbol">(</a><a id="12684" href="decidability.html#12677" class="Bound">g</a> <a id="12686" href="decidability.html#12670" class="Bound">x</a><a id="12687" class="Symbol">)</a>

  <a id="12692" href="decidability.html#12692" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12695" class="Symbol">:</a> <a id="12697" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12699" class="Symbol">(</a><a id="12700" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12702" href="decidability.html#12702" class="Bound">x</a> <a id="12704" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12706" href="decidability.html#12442" class="Bound">X</a> <a id="12708" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12710" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12712" class="Symbol">(</a><a id="12713" href="decidability.html#12446" class="Bound">A</a> <a id="12715" href="decidability.html#12702" class="Bound">x</a><a id="12716" class="Symbol">))</a> <a id="12719" class="Symbol">→</a> <a id="12721" class="Symbol">(</a><a id="12722" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12724" href="decidability.html#12724" class="Bound">x</a> <a id="12726" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12728" href="decidability.html#12442" class="Bound">X</a> <a id="12730" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12732" href="decidability.html#12446" class="Bound">A</a> <a id="12734" href="decidability.html#12724" class="Bound">x</a><a id="12735" class="Symbol">)</a>
  <a id="12739" href="decidability.html#12692" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12742" href="decidability.html#12742" class="Bound">h</a> <a id="12744" href="decidability.html#12744" class="Bound">x</a> <a id="12746" class="Symbol">=</a> <a id="12748" href="decidability.html#12800" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="12754" class="Keyword">where</a>
    <a id="12764" href="decidability.html#12764" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12766" class="Symbol">:</a> <a id="12768" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="12771" href="decidability.html#12446" class="Bound">A</a> <a id="12773" href="decidability.html#12744" class="Bound">x</a>
    <a id="12779" href="decidability.html#12764" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12781" href="decidability.html#12781" class="Bound">f</a> <a id="12783" class="Symbol">=</a> <a id="12785" href="decidability.html#12742" class="Bound">h</a> <a id="12787" class="Symbol">(</a><a id="12788" href="decidability.html#12744" class="Bound">x</a> <a id="12790" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12792" href="decidability.html#12781" class="Bound">f</a><a id="12793" class="Symbol">)</a>

    <a id="12800" href="decidability.html#12800" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12803" class="Symbol">:</a> <a id="12805" href="decidability.html#12446" class="Bound">A</a> <a id="12807" href="decidability.html#12744" class="Bound">x</a>
    <a id="12813" href="decidability.html#12800" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12816" class="Symbol">=</a> <a id="12818" href="decidability.html#3012" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="12826" class="Symbol">(</a><a id="12827" href="decidability.html#12448" class="Bound">d</a> <a id="12829" href="decidability.html#12744" class="Bound">x</a><a id="12830" class="Symbol">)</a> <a id="12832" href="decidability.html#12764" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="12837" href="decidability.html#12837" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12839" class="Symbol">:</a> <a id="12841" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="12854" class="Symbol">(</a><a id="12855" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12857" href="decidability.html#12857" class="Bound">x</a> <a id="12859" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12861" href="decidability.html#12442" class="Bound">X</a> <a id="12863" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12865" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="12867" class="Symbol">(</a><a id="12868" href="decidability.html#12446" class="Bound">A</a> <a id="12870" href="decidability.html#12857" class="Bound">x</a><a id="12871" class="Symbol">))</a> <a id="12874" class="Symbol">→</a> <a id="12876" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="12889" class="Symbol">(</a><a id="12890" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12892" href="decidability.html#12892" class="Bound">x</a> <a id="12894" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12896" href="decidability.html#12442" class="Bound">X</a> <a id="12898" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12900" href="decidability.html#12446" class="Bound">A</a> <a id="12902" href="decidability.html#12892" class="Bound">x</a><a id="12903" class="Symbol">)</a>
  <a id="12907" href="decidability.html#12837" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12909" class="Symbol">=</a> <a id="12911" href="decidability.html#8284" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="12926" href="decidability.html#12617" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12930" href="decidability.html#12692" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="12936" href="decidability.html#12936" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12939" class="Symbol">:</a> <a id="12941" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="12954" class="Symbol">(</a><a id="12955" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12957" href="decidability.html#12957" class="Bound">x</a> <a id="12959" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12961" href="decidability.html#12442" class="Bound">X</a> <a id="12963" href="products.html#4199" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12965" href="decidability.html#12446" class="Bound">A</a> <a id="12967" href="decidability.html#12957" class="Bound">x</a><a id="12968" class="Symbol">)</a>
  <a id="12972" href="decidability.html#12936" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12975" class="Symbol">=</a> <a id="12977" href="decidability.html#12837" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12979" href="decidability.html#12549" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h2 id="decidable-equality">Decidable equality</h2>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13505" href="decidability.html#13505" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13528" class="Symbol">:</a> <a id="13530" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a> <a id="13535" class="Symbol">→</a> <a id="13537" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
<a id="13542" href="decidability.html#13505" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13565" href="decidability.html#13565" class="Bound">X</a> <a id="13567" class="Symbol">=</a> <a id="13569" class="Symbol">(</a><a id="13570" href="decidability.html#13570" class="Bound">x</a> <a id="13572" href="decidability.html#13572" class="Bound">y</a> <a id="13574" class="Symbol">:</a> <a id="13576" href="decidability.html#13565" class="Bound">X</a><a id="13577" class="Symbol">)</a> <a id="13579" class="Symbol">→</a> <a id="13581" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="13594" class="Symbol">(</a><a id="13595" href="decidability.html#13570" class="Bound">x</a> <a id="13597" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13599" href="decidability.html#13572" class="Bound">y</a><a id="13600" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="13806" href="decidability.html#13806" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13834" class="Symbol">:</a> <a id="13836" href="decidability.html#13505" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13859" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a>
<a id="13864" href="decidability.html#13806" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13892" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13898" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13904" class="Symbol">=</a> <a id="13906" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13910" class="Symbol">(</a><a id="13911" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13916" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="13920" class="Symbol">)</a>
<a id="13922" href="decidability.html#13806" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13950" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13956" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="13962" class="Symbol">=</a> <a id="13964" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13968" href="negation.html#3499" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="13986" href="decidability.html#13806" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14014" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="14020" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="14026" class="Symbol">=</a> <a id="14028" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14032" href="negation.html#3444" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="14050" href="decidability.html#13806" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="14078" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="14084" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="14090" class="Symbol">=</a> <a id="14092" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14096" class="Symbol">(</a><a id="14097" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14102" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a><a id="14107" class="Symbol">)</a>

<a id="14110" class="Keyword">open</a> <a id="14115" class="Keyword">import</a> <a id="14122" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14149" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14174" class="Symbol">:</a> <a id="14176" href="decidability.html#13505" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14199" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a>
<a id="14201" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14226" class="Number">0</a>       <a id="14234" class="Number">0</a>       <a id="14242" class="Symbol">=</a> <a id="14244" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14248" class="Symbol">(</a><a id="14249" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14254" href="introduction.html#1152" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14258" class="Symbol">)</a>
<a id="14260" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14285" class="Number">0</a>       <a id="14293" class="Symbol">(</a><a id="14294" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14298" href="decidability.html#14298" class="Bound">y</a><a id="14299" class="Symbol">)</a> <a id="14301" class="Symbol">=</a> <a id="14303" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14307" href="natural-numbers-functions.html#630" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14323" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14348" class="Symbol">(</a><a id="14349" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14353" href="decidability.html#14353" class="Bound">x</a><a id="14354" class="Symbol">)</a> <a id="14356" class="Number">0</a>       <a id="14364" class="Symbol">=</a> <a id="14366" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14370" href="natural-numbers-functions.html#572" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14386" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14411" class="Symbol">(</a><a id="14412" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14416" href="decidability.html#14416" class="Bound">x</a><a id="14417" class="Symbol">)</a> <a id="14419" class="Symbol">(</a><a id="14420" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14424" href="decidability.html#14424" class="Bound">y</a><a id="14425" class="Symbol">)</a> <a id="14427" class="Symbol">=</a> <a id="14429" href="decidability.html#14603" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14434" class="Keyword">where</a>
  <a id="14442" href="decidability.html#14442" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14445" class="Symbol">:</a> <a id="14447" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="14460" class="Symbol">(</a><a id="14461" href="decidability.html#14416" class="Bound">x</a> <a id="14463" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14465" href="decidability.html#14424" class="Bound">y</a><a id="14466" class="Symbol">)</a>
  <a id="14470" href="decidability.html#14442" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14473" class="Symbol">=</a> <a id="14475" href="decidability.html#14149" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14500" href="decidability.html#14416" class="Bound">x</a> <a id="14502" href="decidability.html#14424" class="Bound">y</a>

  <a id="14507" href="decidability.html#14507" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14509" class="Symbol">:</a> <a id="14511" href="decidability.html#14416" class="Bound">x</a> <a id="14513" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14515" href="decidability.html#14424" class="Bound">y</a> <a id="14517" class="Symbol">→</a> <a id="14519" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14523" href="decidability.html#14416" class="Bound">x</a> <a id="14525" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14527" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14531" href="decidability.html#14424" class="Bound">y</a>
  <a id="14535" href="decidability.html#14507" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14537" class="Symbol">=</a> <a id="14539" href="identity-type.html#2409" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14542" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14549" href="decidability.html#14549" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14552" class="Symbol">:</a> <a id="14554" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14558" href="decidability.html#14416" class="Bound">x</a> <a id="14560" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14562" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14566" href="decidability.html#14424" class="Bound">y</a> <a id="14568" class="Symbol">→</a> <a id="14570" href="decidability.html#14416" class="Bound">x</a> <a id="14572" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14574" href="decidability.html#14424" class="Bound">y</a>
  <a id="14578" href="decidability.html#14549" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14581" class="Symbol">=</a> <a id="14583" href="natural-numbers-functions.html#736" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14603" href="decidability.html#14603" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14607" class="Symbol">:</a> <a id="14609" href="decidability.html#2737" data-type="Type → Type" class="Function">is-decidable</a> <a id="14622" class="Symbol">(</a><a id="14623" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14627" href="decidability.html#14416" class="Bound">x</a> <a id="14629" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14631" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14635" href="decidability.html#14424" class="Bound">y</a><a id="14636" class="Symbol">)</a>
  <a id="14640" href="decidability.html#14603" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14644" class="Symbol">=</a> <a id="14646" href="decidability.html#7934" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14660" href="decidability.html#14507" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14662" href="decidability.html#14549" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14665" href="decidability.html#14442" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h2 id="equality-of-functions">Equality of functions</h2>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="14953" class="Keyword">private</a>
 <a id="f"></a><a id="14962" href="decidability.html#14962" class="Function">f</a> <a id="g"></a><a id="14964" href="decidability.html#14964" class="Function">g</a> <a id="h"></a><a id="14966" href="decidability.html#14966" class="Function">h</a> <a id="14968" class="Symbol">:</a> <a id="14970" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a> <a id="14972" class="Symbol">→</a> <a id="14974" href="introduction.html#1136" data-type="Set" class="Datatype">ℕ</a>

 <a id="14978" href="decidability.html#14962" class="Function">f</a> <a id="14980" href="decidability.html#14980" class="Bound">x</a> <a id="14982" class="Symbol">=</a> <a id="14984" href="decidability.html#14980" class="Bound">x</a>

 <a id="14988" href="decidability.html#14964" class="Function">g</a> <a id="14990" class="Number">0</a>       <a id="14998" class="Symbol">=</a> <a id="15000" class="Number">0</a>
 <a id="15003" href="decidability.html#14964" class="Function">g</a> <a id="15005" class="Symbol">(</a><a id="15006" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15010" href="decidability.html#15010" class="Bound">x</a><a id="15011" class="Symbol">)</a> <a id="15013" class="Symbol">=</a> <a id="15015" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15019" class="Symbol">(</a><a id="15020" href="decidability.html#14964" class="Function">g</a> <a id="15022" href="decidability.html#15010" class="Bound">x</a><a id="15023" class="Symbol">)</a>

 <a id="15027" href="decidability.html#14966" class="Function">h</a> <a id="15029" href="decidability.html#15029" class="Bound">x</a> <a id="15031" class="Symbol">=</a> <a id="15033" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15037" href="decidability.html#15029" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="15041" href="decidability.html#15041" class="Function">f-equals-g</a> <a id="15052" class="Symbol">:</a> <a id="15054" href="decidability.html#14962" class="Function">f</a> <a id="15056" href="identity-type.html#3360" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15058" href="decidability.html#14964" class="Function">g</a>
 <a id="15061" href="decidability.html#15041" class="Function">f-equals-g</a> <a id="15072" class="Number">0</a>       <a id="15080" class="Symbol">=</a> <a id="15082" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15087" class="Symbol">(</a><a id="15088" href="decidability.html#14962" class="Function">f</a> <a id="15090" class="Number">0</a><a id="15091" class="Symbol">)</a>
 <a id="15094" href="decidability.html#15041" class="Function">f-equals-g</a> <a id="15105" class="Symbol">(</a><a id="15106" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15110" href="decidability.html#15110" class="Bound">x</a><a id="15111" class="Symbol">)</a> <a id="15113" class="Symbol">=</a> <a id="15115" href="decidability.html#15168" class="Function">γ</a>
  <a id="15119" class="Keyword">where</a>
   <a id="15128" href="decidability.html#15128" class="Function">IH</a> <a id="15131" class="Symbol">:</a> <a id="15133" href="decidability.html#14962" class="Function">f</a> <a id="15135" href="decidability.html#15110" class="Bound">x</a> <a id="15137" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15139" href="decidability.html#14964" class="Function">g</a> <a id="15141" href="decidability.html#15110" class="Bound">x</a>
   <a id="15146" href="decidability.html#15128" class="Function">IH</a> <a id="15149" class="Symbol">=</a> <a id="15151" href="decidability.html#15041" class="Function">f-equals-g</a> <a id="15162" href="decidability.html#15110" class="Bound">x</a>

   <a id="15168" href="decidability.html#15168" class="Function">γ</a> <a id="15170" class="Symbol">:</a> <a id="15172" href="decidability.html#14962" class="Function">f</a> <a id="15174" class="Symbol">(</a><a id="15175" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15179" href="decidability.html#15110" class="Bound">x</a><a id="15180" class="Symbol">)</a> <a id="15182" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15184" href="decidability.html#14964" class="Function">g</a> <a id="15186" class="Symbol">(</a><a id="15187" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15191" href="decidability.html#15110" class="Bound">x</a><a id="15192" class="Symbol">)</a>
   <a id="15197" href="decidability.html#15168" class="Function">γ</a> <a id="15199" class="Symbol">=</a> <a id="15201" href="decidability.html#14962" class="Function">f</a> <a id="15203" class="Symbol">(</a><a id="15204" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15208" href="decidability.html#15110" class="Bound">x</a><a id="15209" class="Symbol">)</a> <a id="15211" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15214" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15219" class="Symbol">_</a> <a id="15221" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15230" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15234" href="decidability.html#15110" class="Bound">x</a>     <a id="15240" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15243" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15248" class="Symbol">_</a> <a id="15250" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15259" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15263" class="Symbol">(</a><a id="15264" href="decidability.html#14962" class="Function">f</a> <a id="15266" href="decidability.html#15110" class="Bound">x</a><a id="15267" class="Symbol">)</a> <a id="15269" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15272" href="identity-type.html#2409" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15275" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15279" href="decidability.html#15128" class="Function">IH</a> <a id="15282" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15291" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15295" class="Symbol">(</a><a id="15296" href="decidability.html#14964" class="Function">g</a> <a id="15298" href="decidability.html#15110" class="Bound">x</a><a id="15299" class="Symbol">)</a> <a id="15301" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15304" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15309" class="Symbol">_</a> <a id="15311" href="identity-type.html#4254" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15320" href="decidability.html#14964" class="Function">g</a> <a id="15322" class="Symbol">(</a><a id="15323" href="introduction.html#1162" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15327" href="decidability.html#15110" class="Bound">x</a><a id="15328" class="Symbol">)</a> <a id="15330" href="identity-type.html#4340" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15334" href="decidability.html#15334" class="Function">f-not-equals-h</a> <a id="15349" class="Symbol">:</a> <a id="15351" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="15353" class="Symbol">(</a><a id="15354" href="decidability.html#14962" class="Function">f</a> <a id="15356" href="identity-type.html#3360" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15358" href="decidability.html#14966" class="Function">h</a><a id="15359" class="Symbol">)</a>
 <a id="15362" href="decidability.html#15334" class="Function">f-not-equals-h</a> <a id="15377" href="decidability.html#15377" class="Bound">e</a> <a id="15379" class="Symbol">=</a> <a id="15381" href="decidability.html#15433" class="Function">contradiction</a> <a id="15395" href="decidability.html#15408" class="Function">d</a>
  <a id="15399" class="Keyword">where</a>
   <a id="15408" href="decidability.html#15408" class="Function">d</a> <a id="15410" class="Symbol">:</a> <a id="15412" class="Number">0</a> <a id="15414" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15416" class="Number">1</a>
   <a id="15421" href="decidability.html#15408" class="Function">d</a> <a id="15423" class="Symbol">=</a> <a id="15425" href="decidability.html#15377" class="Bound">e</a> <a id="15427" class="Number">0</a>

   <a id="15433" href="decidability.html#15433" class="Function">contradiction</a> <a id="15447" class="Symbol">:</a> <a id="15449" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="15451" class="Symbol">(</a><a id="15452" class="Number">0</a> <a id="15454" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15456" class="Number">1</a><a id="15457" class="Symbol">)</a>
   <a id="15462" href="decidability.html#15433" class="Function">contradiction</a> <a id="15476" class="Symbol">()</a>
</pre>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
