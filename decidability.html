<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<a id=moddecidability></a>
<h2
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h2>
<p>When programming in conventional programming languages such as
Haskell, C, Java, Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h3 id="discussion-and-motivation">Discussion and motivation</h3>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h3 id="decidable-propositions">Decidable propositions</h3>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2606" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2619" class="Symbol">:</a> <a id="2621" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="2626" class="Symbol">→</a> <a id="2628" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="2633" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2646" href="decidability.html#2646" class="Bound">A</a> <a id="2648" class="Symbol">=</a> <a id="2650" href="decidability.html#2646" class="Bound">A</a> <a id="2652" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2654" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="2656" href="decidability.html#2646" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="2881" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2889" class="Symbol">:</a> <a id="2891" class="Symbol">{</a><a id="2892" href="decidability.html#2892" class="Bound">A</a> <a id="2894" class="Symbol">:</a> <a id="2896" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2900" class="Symbol">}</a> <a id="2902" class="Symbol">→</a> <a id="2904" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="2917" href="decidability.html#2892" class="Bound">A</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2924" href="decidability.html#2892" class="Bound">A</a> <a id="2926" class="Symbol">→</a> <a id="2928" href="decidability.html#2892" class="Bound">A</a>
<a id="2930" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2938" class="Symbol">(</a><a id="2939" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2943" href="decidability.html#2943" class="Bound">x</a><a id="2944" class="Symbol">)</a> <a id="2946" href="decidability.html#2946" class="Bound">f</a> <a id="2948" class="Symbol">=</a> <a id="2950" href="decidability.html#2943" class="Bound">x</a>
<a id="2952" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2960" class="Symbol">(</a><a id="2961" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2965" href="decidability.html#2965" class="Bound">g</a><a id="2966" class="Symbol">)</a> <a id="2968" href="decidability.html#2968" class="Bound">f</a> <a id="2970" class="Symbol">=</a> <a id="2972" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="2979" class="Symbol">(</a><a id="2980" href="decidability.html#2968" class="Bound">f</a> <a id="2982" href="decidability.html#2965" class="Bound">g</a><a id="2983" class="Symbol">)</a>
</pre>
<h3 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h3>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3411" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3438" class="Symbol">:</a> <a id="3440" class="Symbol">(</a><a id="3441" href="decidability.html#3441" class="Bound">A</a> <a id="3443" class="Symbol">:</a> <a id="3445" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3449" class="Symbol">)</a> <a id="3451" class="Symbol">→</a> <a id="3453" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3466" href="decidability.html#3441" class="Bound">A</a> <a id="3468" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3470" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3472" href="decidability.html#3472" class="Bound">b</a> <a id="3474" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3476" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3481" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3483" class="Symbol">(</a><a id="3484" href="decidability.html#3441" class="Bound">A</a> <a id="3486" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3488" href="decidability.html#3472" class="Bound">b</a> <a id="3490" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3492" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3496" class="Symbol">)</a>
<a id="3498" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3525" href="decidability.html#3525" class="Bound">A</a> <a id="3527" class="Symbol">=</a> <a id="3529" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3531" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3533" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3536" class="Keyword">where</a>
  <a id="3544" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3546" class="Symbol">:</a> <a id="3548" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3561" href="decidability.html#3525" class="Bound">A</a> <a id="3563" class="Symbol">→</a> <a id="3565" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3567" href="decidability.html#3567" class="Bound">b</a> <a id="3569" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3571" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3576" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3578" class="Symbol">(</a><a id="3579" href="decidability.html#3525" class="Bound">A</a> <a id="3581" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3583" href="decidability.html#3567" class="Bound">b</a> <a id="3585" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3587" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3591" class="Symbol">)</a>
  <a id="3595" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3597" class="Symbol">(</a><a id="3598" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3602" href="decidability.html#3602" class="Bound">x</a><a id="3603" class="Symbol">)</a> <a id="3605" class="Symbol">=</a> <a id="3607" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3612" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3614" class="Symbol">(</a><a id="3615" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3617" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3619" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="3620" class="Symbol">)</a>
   <a id="3625" class="Keyword">where</a>
    <a id="3635" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="decidability.html#3525" class="Bound">A</a> <a id="3641" class="Symbol">→</a> <a id="3643" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3648" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3650" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3659" href="decidability.html#3635" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3661" class="Symbol">_</a> <a id="3663" class="Symbol">=</a> <a id="3665" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3670" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="3680" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3682" class="Symbol">:</a> <a id="3684" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3689" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3691" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3696" class="Symbol">→</a> <a id="3698" href="decidability.html#3525" class="Bound">A</a>
    <a id="3704" href="decidability.html#3680" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3706" class="Symbol">_</a> <a id="3708" class="Symbol">=</a> <a id="3710" href="decidability.html#3602" class="Bound">x</a>

  <a id="3715" href="decidability.html#3544" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3717" class="Symbol">(</a><a id="3718" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3722" href="decidability.html#3722" class="Bound">ν</a><a id="3723" class="Symbol">)</a> <a id="3725" class="Symbol">=</a> <a id="3727" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3733" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3735" class="Symbol">(</a><a id="3736" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3738" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3740" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="3741" class="Symbol">)</a>
   <a id="3746" class="Keyword">where</a>
    <a id="3756" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="decidability.html#3525" class="Bound">A</a> <a id="3762" class="Symbol">→</a> <a id="3764" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3770" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3772" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3781" href="decidability.html#3756" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3783" href="decidability.html#3783" class="Bound">x</a> <a id="3785" class="Symbol">=</a> <a id="3787" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3794" class="Symbol">(</a><a id="3795" href="decidability.html#3722" class="Bound">ν</a> <a id="3797" href="decidability.html#3783" class="Bound">x</a><a id="3798" class="Symbol">)</a>

    <a id="3805" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3807" class="Symbol">:</a> <a id="3809" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3815" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3817" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3822" class="Symbol">→</a> <a id="3824" href="decidability.html#3525" class="Bound">A</a>
    <a id="3830" href="decidability.html#3805" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3832" class="Symbol">()</a>

  <a id="3838" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3840" class="Symbol">:</a> <a id="3842" class="Symbol">(</a><a id="3843" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3845" href="decidability.html#3845" class="Bound">b</a> <a id="3847" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3849" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3854" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3856" class="Symbol">(</a><a id="3857" href="decidability.html#3525" class="Bound">A</a> <a id="3859" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3861" href="decidability.html#3845" class="Bound">b</a> <a id="3863" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3865" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3869" class="Symbol">))</a> <a id="3872" class="Symbol">→</a> <a id="3874" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="3887" href="decidability.html#3525" class="Bound">A</a>
  <a id="3891" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3893" class="Symbol">(</a><a id="3894" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="3899" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="3902" href="decidability.html#3902" class="Bound">α</a> <a id="3904" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3906" href="decidability.html#3906" class="Bound">β</a><a id="3907" class="Symbol">)</a> <a id="3909" class="Symbol">=</a> <a id="3911" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3915" class="Symbol">(</a><a id="3916" href="decidability.html#3906" class="Bound">β</a> <a id="3918" class="Symbol">(</a><a id="3919" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3924" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="3928" class="Symbol">))</a>
  <a id="3933" href="decidability.html#3838" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3935" class="Symbol">(</a><a id="3936" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="3942" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3944" href="decidability.html#3944" class="Bound">α</a> <a id="3946" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3948" href="decidability.html#3948" class="Bound">β</a><a id="3949" class="Symbol">)</a> <a id="3951" class="Symbol">=</a> <a id="3953" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3957" class="Symbol">(λ</a> <a id="3960" href="decidability.html#3960" class="Bound">x</a> <a id="3962" class="Symbol">→</a> <a id="3964" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3982" class="Symbol">(</a><a id="3983" href="decidability.html#3944" class="Bound">α</a> <a id="3985" href="decidability.html#3960" class="Bound">x</a><a id="3986" class="Symbol">))</a>
</pre>
<h3 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h3>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is even. <!--
<pre class="Agda"><a id="4510" class="Keyword">module</a> <a id="4517" href="decidability.html#4517" class="Module">_</a> <a id="4519" class="Keyword">where</a>
 <a id="4526" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4552" href="decidability.html#4552" class="Function">is-even</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4564" class="Symbol">→</a> <a id="4566" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
  <a id="4573" href="decidability.html#4552" class="Function">is-even</a> <a id="4581" href="decidability.html#4581" class="Bound">x</a> <a id="4583" class="Symbol">=</a> <a id="4585" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4587" href="decidability.html#4587" class="Bound">y</a> <a id="4589" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4591" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4593" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4595" href="decidability.html#4581" class="Bound">x</a> <a id="4597" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4599" class="Number">2</a> <a id="4601" href="natural-numbers-type.html#2890" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4603" href="decidability.html#4587" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="4805" href="decidability.html#4805" class="Function">check-even</a> <a id="4816" class="Symbol">:</a> <a id="4818" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="4820" class="Symbol">→</a> <a id="4822" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
  <a id="4829" href="decidability.html#4805" class="Function">check-even</a> <a id="4840" class="Number">0</a>       <a id="4848" class="Symbol">=</a> <a id="4850" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4857" href="decidability.html#4805" class="Function">check-even</a> <a id="4868" class="Symbol">(</a><a id="4869" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="4873" href="decidability.html#4873" class="Bound">x</a><a id="4874" class="Symbol">)</a> <a id="4876" class="Symbol">=</a> <a id="4878" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4882" class="Symbol">(</a><a id="4883" href="decidability.html#4805" class="Function">check-even</a> <a id="4894" href="decidability.html#4873" class="Bound">x</a><a id="4895" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5305" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5328" class="Symbol">:</a> <a id="5330" class="Symbol">{</a><a id="5331" href="decidability.html#5331" class="Bound">X</a> <a id="5333" class="Symbol">:</a> <a id="5335" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5339" class="Symbol">}</a> <a id="5341" class="Symbol">→</a> <a id="5343" class="Symbol">(</a><a id="5344" href="decidability.html#5331" class="Bound">X</a> <a id="5346" class="Symbol">→</a> <a id="5348" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5352" class="Symbol">)</a> <a id="5354" class="Symbol">→</a> <a id="5356" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="5361" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5384" class="Symbol">{</a><a id="5385" href="decidability.html#5385" class="Bound">X</a><a id="5386" class="Symbol">}</a> <a id="5388" href="decidability.html#5388" class="Bound">A</a> <a id="5390" class="Symbol">=</a> <a id="5392" class="Symbol">(</a><a id="5393" href="decidability.html#5393" class="Bound">x</a> <a id="5395" class="Symbol">:</a> <a id="5397" href="decidability.html#5385" class="Bound">X</a><a id="5398" class="Symbol">)</a> <a id="5400" class="Symbol">→</a> <a id="5402" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="5415" class="Symbol">(</a><a id="5416" href="decidability.html#5388" class="Bound">A</a> <a id="5418" href="decidability.html#5393" class="Bound">x</a><a id="5419" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="5943" href="decidability.html#5943" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="5980" class="Symbol">:</a> <a id="5982" class="Symbol">{</a><a id="5983" href="decidability.html#5983" class="Bound">X</a> <a id="5985" class="Symbol">:</a> <a id="5987" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5991" class="Symbol">}</a> <a id="5993" class="Symbol">(</a><a id="5994" href="decidability.html#5994" class="Bound">A</a> <a id="5996" class="Symbol">:</a> <a id="5998" href="decidability.html#5983" class="Bound">X</a> <a id="6000" class="Symbol">→</a> <a id="6002" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="6006" class="Symbol">)</a>
                                     <a id="6045" class="Symbol">→</a> <a id="6047" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6070" href="decidability.html#5994" class="Bound">A</a>
                                     <a id="6109" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6111" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6113" href="decidability.html#6113" class="Bound">α</a> <a id="6115" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6117" class="Symbol">(</a><a id="6118" href="decidability.html#5983" class="Bound">X</a> <a id="6120" class="Symbol">→</a> <a id="6122" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6126" class="Symbol">)</a> <a id="6128" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6130" class="Symbol">((</a><a id="6132" href="decidability.html#6132" class="Bound">x</a> <a id="6134" class="Symbol">:</a> <a id="6136" href="decidability.html#5983" class="Bound">X</a><a id="6137" class="Symbol">)</a> <a id="6139" class="Symbol">→</a> <a id="6141" href="decidability.html#5994" class="Bound">A</a> <a id="6143" href="decidability.html#6132" class="Bound">x</a> <a id="6145" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6147" href="decidability.html#6113" class="Bound">α</a> <a id="6149" href="decidability.html#6132" class="Bound">x</a> <a id="6151" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6153" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6157" class="Symbol">)</a>
<a id="6159" href="decidability.html#5943" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6196" class="Symbol">{</a><a id="6197" href="decidability.html#6197" class="Bound">X</a><a id="6198" class="Symbol">}</a> <a id="6200" href="decidability.html#6200" class="Bound">A</a> <a id="6202" class="Symbol">=</a> <a id="6204" href="decidability.html#6219" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6206" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6208" href="decidability.html#6864" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6211" class="Keyword">where</a>
  <a id="6219" href="decidability.html#6219" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6221" class="Symbol">:</a> <a id="6223" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6246" href="decidability.html#6200" class="Bound">A</a> <a id="6248" class="Symbol">→</a> <a id="6250" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6252" href="decidability.html#6252" class="Bound">α</a> <a id="6254" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6256" class="Symbol">(</a><a id="6257" href="decidability.html#6197" class="Bound">X</a> <a id="6259" class="Symbol">→</a> <a id="6261" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6265" class="Symbol">)</a> <a id="6267" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6269" class="Symbol">((</a><a id="6271" href="decidability.html#6271" class="Bound">x</a> <a id="6273" class="Symbol">:</a> <a id="6275" href="decidability.html#6197" class="Bound">X</a><a id="6276" class="Symbol">)</a> <a id="6278" class="Symbol">→</a> <a id="6280" href="decidability.html#6200" class="Bound">A</a> <a id="6282" href="decidability.html#6271" class="Bound">x</a> <a id="6284" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6286" href="decidability.html#6252" class="Bound">α</a> <a id="6288" href="decidability.html#6271" class="Bound">x</a> <a id="6290" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6292" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6296" class="Symbol">)</a>
  <a id="6300" href="decidability.html#6219" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6302" href="decidability.html#6302" class="Bound">d</a> <a id="6304" class="Symbol">=</a> <a id="6306" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6308" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6310" href="decidability.html#6497" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6315" class="Keyword">where</a>
    <a id="6325" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6327" class="Symbol">:</a> <a id="6329" href="decidability.html#6197" class="Bound">X</a> <a id="6331" class="Symbol">→</a> <a id="6333" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
    <a id="6342" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6344" href="decidability.html#6344" class="Bound">x</a> <a id="6346" class="Symbol">=</a> <a id="6348" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a> <a id="6352" class="Symbol">(</a><a id="6353" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6368" href="decidability.html#6394" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6370" class="Symbol">(</a><a id="6371" href="decidability.html#6302" class="Bound">d</a> <a id="6373" href="decidability.html#6344" class="Bound">x</a><a id="6374" class="Symbol">))</a>
     <a id="6382" class="Keyword">where</a>
      <a id="6394" href="decidability.html#6394" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6396" class="Symbol">:</a> <a id="6398" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="6411" class="Symbol">(</a><a id="6412" href="decidability.html#6200" class="Bound">A</a> <a id="6414" href="decidability.html#6344" class="Bound">x</a><a id="6415" class="Symbol">)</a> <a id="6417" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6419" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6421" href="decidability.html#6421" class="Bound">b</a> <a id="6423" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6425" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6430" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6432" class="Symbol">(</a><a id="6433" href="decidability.html#6200" class="Bound">A</a> <a id="6435" href="decidability.html#6344" class="Bound">x</a> <a id="6437" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6439" href="decidability.html#6421" class="Bound">b</a> <a id="6441" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6443" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6447" class="Symbol">)</a>
      <a id="6455" href="decidability.html#6394" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6457" class="Symbol">=</a> <a id="6459" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6486" class="Symbol">(</a><a id="6487" href="decidability.html#6200" class="Bound">A</a> <a id="6489" href="decidability.html#6344" class="Bound">x</a><a id="6490" class="Symbol">)</a>

    <a id="6497" href="decidability.html#6497" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6499" class="Symbol">:</a> <a id="6501" class="Symbol">(</a><a id="6502" href="decidability.html#6502" class="Bound">x</a> <a id="6504" class="Symbol">:</a> <a id="6506" href="decidability.html#6197" class="Bound">X</a><a id="6507" class="Symbol">)</a> <a id="6509" class="Symbol">→</a> <a id="6511" href="decidability.html#6200" class="Bound">A</a> <a id="6513" href="decidability.html#6502" class="Bound">x</a> <a id="6515" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6517" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6519" href="decidability.html#6502" class="Bound">x</a> <a id="6521" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6523" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6532" href="decidability.html#6497" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6534" href="decidability.html#6534" class="Bound">x</a> <a id="6536" class="Symbol">=</a> <a id="6538" href="decidability.html#6744" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6540" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6542" href="decidability.html#6806" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6549" class="Keyword">where</a>
      <a id="6561" href="decidability.html#6561" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6563" class="Symbol">:</a> <a id="6565" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="6578" class="Symbol">(</a><a id="6579" href="decidability.html#6200" class="Bound">A</a> <a id="6581" href="decidability.html#6534" class="Bound">x</a><a id="6582" class="Symbol">)</a> <a id="6584" class="Symbol">→</a> <a id="6586" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6588" href="decidability.html#6588" class="Bound">b</a> <a id="6590" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6592" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6597" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6599" class="Symbol">(</a><a id="6600" href="decidability.html#6200" class="Bound">A</a> <a id="6602" href="decidability.html#6534" class="Bound">x</a> <a id="6604" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6606" href="decidability.html#6588" class="Bound">b</a> <a id="6608" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6610" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6614" class="Symbol">)</a>
      <a id="6622" href="decidability.html#6561" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6624" class="Symbol">=</a> <a id="6626" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6641" class="Symbol">(</a><a id="6642" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6669" class="Symbol">(</a><a id="6670" href="decidability.html#6200" class="Bound">A</a> <a id="6672" href="decidability.html#6534" class="Bound">x</a><a id="6673" class="Symbol">))</a>

      <a id="6683" href="decidability.html#6683" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6686" class="Symbol">:</a> <a id="6688" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6690" href="decidability.html#6690" class="Bound">b</a> <a id="6692" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6694" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="6699" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6701" class="Symbol">(</a><a id="6702" href="decidability.html#6200" class="Bound">A</a> <a id="6704" href="decidability.html#6534" class="Bound">x</a> <a id="6706" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6708" href="decidability.html#6690" class="Bound">b</a> <a id="6710" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6712" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6716" class="Symbol">)</a>
      <a id="6724" href="decidability.html#6683" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6727" class="Symbol">=</a> <a id="6729" href="decidability.html#6561" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6731" class="Symbol">(</a><a id="6732" href="decidability.html#6302" class="Bound">d</a> <a id="6734" href="decidability.html#6534" class="Bound">x</a><a id="6735" class="Symbol">)</a>

      <a id="6744" href="decidability.html#6744" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6746" class="Symbol">:</a> <a id="6748" href="decidability.html#6200" class="Bound">A</a> <a id="6750" href="decidability.html#6534" class="Bound">x</a> <a id="6752" class="Symbol">→</a> <a id="6754" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6756" href="decidability.html#6534" class="Bound">x</a> <a id="6758" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6760" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="6771" href="decidability.html#6744" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6773" class="Symbol">=</a> <a id="6775" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6790" class="Symbol">(</a><a id="6791" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6795" href="decidability.html#6683" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6797" class="Symbol">)</a>

      <a id="6806" href="decidability.html#6806" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6808" class="Symbol">:</a> <a id="6810" href="decidability.html#6325" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6812" href="decidability.html#6534" class="Bound">x</a> <a id="6814" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6816" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="6821" class="Symbol">→</a> <a id="6823" href="decidability.html#6200" class="Bound">A</a> <a id="6825" href="decidability.html#6534" class="Bound">x</a>
      <a id="6833" href="decidability.html#6806" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6835" class="Symbol">=</a> <a id="6837" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="6852" class="Symbol">(</a><a id="6853" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6857" href="decidability.html#6683" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6859" class="Symbol">)</a>

  <a id="6864" href="decidability.html#6864" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6866" class="Symbol">:</a> <a id="6868" class="Symbol">(</a><a id="6869" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6871" href="decidability.html#6871" class="Bound">α</a> <a id="6873" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6875" class="Symbol">(</a><a id="6876" href="decidability.html#6197" class="Bound">X</a> <a id="6878" class="Symbol">→</a> <a id="6880" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6884" class="Symbol">)</a> <a id="6886" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6888" class="Symbol">((</a><a id="6890" href="decidability.html#6890" class="Bound">x</a> <a id="6892" class="Symbol">:</a> <a id="6894" href="decidability.html#6197" class="Bound">X</a><a id="6895" class="Symbol">)</a> <a id="6897" class="Symbol">→</a> <a id="6899" href="decidability.html#6200" class="Bound">A</a> <a id="6901" href="decidability.html#6890" class="Bound">x</a> <a id="6903" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6905" href="decidability.html#6871" class="Bound">α</a> <a id="6907" href="decidability.html#6890" class="Bound">x</a> <a id="6909" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6911" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6915" class="Symbol">))</a> <a id="6918" class="Symbol">→</a> <a id="6920" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6943" href="decidability.html#6200" class="Bound">A</a>
  <a id="6947" href="decidability.html#6864" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6949" class="Symbol">(</a><a id="6950" href="decidability.html#6950" class="Bound">α</a> <a id="6952" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6954" href="decidability.html#6954" class="Bound">ϕ</a><a id="6955" class="Symbol">)</a> <a id="6957" class="Symbol">=</a> <a id="6959" href="decidability.html#6974" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="6964" class="Keyword">where</a>
    <a id="6974" href="decidability.html#6974" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="6976" class="Symbol">:</a> <a id="6978" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="7001" href="decidability.html#6200" class="Bound">A</a>
    <a id="7007" href="decidability.html#6974" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="7009" href="decidability.html#7009" class="Bound">x</a> <a id="7011" class="Symbol">=</a> <a id="7013" href="decidability.html#7223" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7022" class="Keyword">where</a>
      <a id="7034" href="decidability.html#7034" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7036" class="Symbol">:</a> <a id="7038" class="Symbol">(</a><a id="7039" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7041" href="decidability.html#7041" class="Bound">b</a> <a id="7043" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7045" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7050" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7052" class="Symbol">(</a><a id="7053" href="decidability.html#6200" class="Bound">A</a> <a id="7055" href="decidability.html#7009" class="Bound">x</a> <a id="7057" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7059" href="decidability.html#7041" class="Bound">b</a> <a id="7061" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7063" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7067" class="Symbol">))</a> <a id="7070" class="Symbol">→</a> <a id="7072" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7085" class="Symbol">(</a><a id="7086" href="decidability.html#6200" class="Bound">A</a> <a id="7088" href="decidability.html#7009" class="Bound">x</a><a id="7089" class="Symbol">)</a>
      <a id="7097" href="decidability.html#7034" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7099" class="Symbol">=</a> <a id="7101" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7116" class="Symbol">(</a><a id="7117" href="decidability.html#3411" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7144" class="Symbol">(</a><a id="7145" href="decidability.html#6200" class="Bound">A</a> <a id="7147" href="decidability.html#7009" class="Bound">x</a><a id="7148" class="Symbol">))</a>

      <a id="7158" href="decidability.html#7158" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7161" class="Symbol">:</a> <a id="7163" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7165" href="decidability.html#7165" class="Bound">b</a> <a id="7167" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7169" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7174" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7176" class="Symbol">(</a><a id="7177" href="decidability.html#6200" class="Bound">A</a> <a id="7179" href="decidability.html#7009" class="Bound">x</a> <a id="7181" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7183" href="decidability.html#7165" class="Bound">b</a> <a id="7185" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7187" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="7191" class="Symbol">)</a>
      <a id="7199" href="decidability.html#7158" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7202" class="Symbol">=</a> <a id="7204" class="Symbol">(</a><a id="7205" href="decidability.html#6950" class="Bound">α</a> <a id="7207" href="decidability.html#7009" class="Bound">x</a> <a id="7209" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7211" href="decidability.html#6954" class="Bound">ϕ</a> <a id="7213" href="decidability.html#7009" class="Bound">x</a><a id="7214" class="Symbol">)</a>

      <a id="7223" href="decidability.html#7223" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7227" class="Symbol">:</a> <a id="7229" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7242" class="Symbol">(</a><a id="7243" href="decidability.html#6200" class="Bound">A</a> <a id="7245" href="decidability.html#7009" class="Bound">x</a><a id="7246" class="Symbol">)</a>
      <a id="7254" href="decidability.html#7223" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7258" class="Symbol">=</a> <a id="7260" href="decidability.html#7034" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7262" href="decidability.html#7158" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h3 id="preservation-of-decidability">Preservation of decidability</h3>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="7803" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7817" class="Symbol">:</a> <a id="7819" class="Symbol">{</a><a id="7820" href="decidability.html#7820" class="Bound">A</a> <a id="7822" href="decidability.html#7822" class="Bound">B</a> <a id="7824" class="Symbol">:</a> <a id="7826" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7830" class="Symbol">}</a> <a id="7832" class="Symbol">→</a> <a id="7834" class="Symbol">(</a><a id="7835" href="decidability.html#7820" class="Bound">A</a> <a id="7837" class="Symbol">→</a> <a id="7839" href="decidability.html#7822" class="Bound">B</a><a id="7840" class="Symbol">)</a> <a id="7842" class="Symbol">→</a> <a id="7844" class="Symbol">(</a><a id="7845" href="decidability.html#7822" class="Bound">B</a> <a id="7847" class="Symbol">→</a> <a id="7849" href="decidability.html#7820" class="Bound">A</a><a id="7850" class="Symbol">)</a> <a id="7852" class="Symbol">→</a> <a id="7854" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7867" href="decidability.html#7820" class="Bound">A</a> <a id="7869" class="Symbol">→</a> <a id="7871" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="7884" href="decidability.html#7822" class="Bound">B</a>
<a id="7886" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7900" href="decidability.html#7900" class="Bound">f</a> <a id="7902" href="decidability.html#7902" class="Bound">g</a> <a id="7904" class="Symbol">(</a><a id="7905" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7909" href="decidability.html#7909" class="Bound">x</a><a id="7910" class="Symbol">)</a> <a id="7912" class="Symbol">=</a> <a id="7914" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7918" class="Symbol">(</a><a id="7919" href="decidability.html#7900" class="Bound">f</a> <a id="7921" href="decidability.html#7909" class="Bound">x</a><a id="7922" class="Symbol">)</a>
<a id="7924" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7938" href="decidability.html#7938" class="Bound">f</a> <a id="7940" href="decidability.html#7940" class="Bound">g</a> <a id="7942" class="Symbol">(</a><a id="7943" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7947" href="decidability.html#7947" class="Bound">h</a><a id="7948" class="Symbol">)</a> <a id="7950" class="Symbol">=</a> <a id="7952" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7956" class="Symbol">(λ</a> <a id="7959" href="decidability.html#7959" class="Bound">y</a> <a id="7961" class="Symbol">→</a> <a id="7963" href="decidability.html#7947" class="Bound">h</a> <a id="7965" class="Symbol">(</a><a id="7966" href="decidability.html#7940" class="Bound">g</a> <a id="7968" href="decidability.html#7959" class="Bound">y</a><a id="7969" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="7973" href="decidability.html#7973" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="7997" class="Symbol">:</a> <a id="7999" class="Symbol">{</a><a id="8000" href="decidability.html#8000" class="Bound">A</a> <a id="8002" href="decidability.html#8002" class="Bound">B</a> <a id="8004" class="Symbol">:</a> <a id="8006" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8010" class="Symbol">}</a> <a id="8012" class="Symbol">→</a> <a id="8014" class="Symbol">(</a><a id="8015" href="decidability.html#8000" class="Bound">A</a> <a id="8017" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8019" href="decidability.html#8002" class="Bound">B</a><a id="8020" class="Symbol">)</a> <a id="8022" class="Symbol">→</a> <a id="8024" class="Symbol">(</a><a id="8025" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8038" href="decidability.html#8000" class="Bound">A</a> <a id="8040" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8042" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8055" href="decidability.html#8002" class="Bound">B</a><a id="8056" class="Symbol">)</a>
<a id="8058" href="decidability.html#7973" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8082" class="Symbol">(</a><a id="8083" href="decidability.html#8083" class="Bound">f</a> <a id="8085" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8087" href="decidability.html#8087" class="Bound">g</a><a id="8088" class="Symbol">)</a> <a id="8090" class="Symbol">=</a> <a id="8092" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8106" href="decidability.html#8083" class="Bound">f</a> <a id="8108" href="decidability.html#8087" class="Bound">g</a> <a id="8110" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8112" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8126" href="decidability.html#8087" class="Bound">g</a> <a id="8128" href="decidability.html#8083" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8153" href="decidability.html#8153" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8168" class="Symbol">:</a> <a id="8170" class="Symbol">{</a><a id="8171" href="decidability.html#8171" class="Bound">A</a> <a id="8173" href="decidability.html#8173" class="Bound">B</a> <a id="8175" class="Symbol">:</a> <a id="8177" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8181" class="Symbol">}</a> <a id="8183" class="Symbol">→</a> <a id="8185" class="Symbol">(</a><a id="8186" href="decidability.html#8171" class="Bound">A</a> <a id="8188" class="Symbol">→</a> <a id="8190" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8192" href="decidability.html#8173" class="Bound">B</a><a id="8193" class="Symbol">)</a> <a id="8195" class="Symbol">→</a> <a id="8197" class="Symbol">(</a><a id="8198" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8200" href="decidability.html#8171" class="Bound">A</a> <a id="8202" class="Symbol">→</a> <a id="8204" href="decidability.html#8173" class="Bound">B</a><a id="8205" class="Symbol">)</a> <a id="8207" class="Symbol">→</a> <a id="8209" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8222" href="decidability.html#8171" class="Bound">A</a> <a id="8224" class="Symbol">→</a> <a id="8226" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8239" href="decidability.html#8173" class="Bound">B</a>
<a id="8241" href="decidability.html#8153" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8256" href="decidability.html#8256" class="Bound">f</a> <a id="8258" href="decidability.html#8258" class="Bound">g</a> <a id="8260" class="Symbol">(</a><a id="8261" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8265" href="decidability.html#8265" class="Bound">x</a><a id="8266" class="Symbol">)</a> <a id="8268" class="Symbol">=</a> <a id="8270" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8274" class="Symbol">(</a><a id="8275" href="decidability.html#8256" class="Bound">f</a> <a id="8277" href="decidability.html#8265" class="Bound">x</a><a id="8278" class="Symbol">)</a>
<a id="8280" href="decidability.html#8153" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8295" href="decidability.html#8295" class="Bound">f</a> <a id="8297" href="decidability.html#8297" class="Bound">g</a> <a id="8299" class="Symbol">(</a><a id="8300" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8304" href="decidability.html#8304" class="Bound">h</a><a id="8305" class="Symbol">)</a> <a id="8307" class="Symbol">=</a> <a id="8309" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8313" class="Symbol">(</a><a id="8314" href="decidability.html#8297" class="Bound">g</a> <a id="8316" href="decidability.html#8304" class="Bound">h</a><a id="8317" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8332" href="decidability.html#8332" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8360" class="Symbol">:</a> <a id="8362" class="Symbol">{</a><a id="8363" href="decidability.html#8363" class="Bound">A</a> <a id="8365" class="Symbol">:</a> <a id="8367" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8371" class="Symbol">}</a> <a id="8373" class="Symbol">→</a> <a id="8375" href="decidability.html#8363" class="Bound">A</a> <a id="8377" class="Symbol">→</a> <a id="8379" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8392" href="decidability.html#8363" class="Bound">A</a>
<a id="8394" href="decidability.html#8332" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8422" class="Symbol">=</a> <a id="8424" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8429" href="decidability.html#8429" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8455" class="Symbol">:</a> <a id="8457" class="Symbol">{</a><a id="8458" href="decidability.html#8458" class="Bound">A</a> <a id="8460" class="Symbol">:</a> <a id="8462" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8466" class="Symbol">}</a> <a id="8468" class="Symbol">→</a> <a id="8470" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8472" href="decidability.html#8458" class="Bound">A</a> <a id="8474" class="Symbol">→</a> <a id="8476" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8489" href="decidability.html#8458" class="Bound">A</a>
<a id="8491" href="decidability.html#8429" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8517" class="Symbol">=</a> <a id="8519" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8524" href="decidability.html#8524" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8539" class="Symbol">:</a> <a id="8541" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8554" href="unit-type.html#352" data-type="Type" class="Record">𝟙</a>
<a id="8556" href="decidability.html#8524" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8571" class="Symbol">=</a> <a id="8573" href="decidability.html#8332" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8601" href="unit-type.html#382" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8604" href="decidability.html#8604" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8619" class="Symbol">:</a> <a id="8621" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8634" href="empty-type.html#479" data-type="Set" class="Datatype">𝟘</a>
<a id="8636" href="decidability.html#8604" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8651" class="Symbol">=</a> <a id="8653" href="decidability.html#8429" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8679" href="empty-type.html#3580" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="8691" href="decidability.html#8691" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8716" class="Symbol">:</a> <a id="8718" class="Symbol">{</a><a id="8719" href="decidability.html#8719" class="Bound">A</a> <a id="8721" href="decidability.html#8721" class="Bound">B</a> <a id="8723" class="Symbol">:</a> <a id="8725" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8729" class="Symbol">}</a>
                         <a id="8756" class="Symbol">→</a> <a id="8758" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8771" href="decidability.html#8719" class="Bound">A</a>
                         <a id="8798" class="Symbol">→</a> <a id="8800" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8813" href="decidability.html#8721" class="Bound">B</a>
                         <a id="8840" class="Symbol">→</a> <a id="8842" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="8855" class="Symbol">(</a><a id="8856" href="decidability.html#8719" class="Bound">A</a> <a id="8858" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="8860" href="decidability.html#8721" class="Bound">B</a><a id="8861" class="Symbol">)</a>
<a id="8863" href="decidability.html#8691" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8888" class="Symbol">(</a><a id="8889" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8893" href="decidability.html#8893" class="Bound">x</a><a id="8894" class="Symbol">)</a> <a id="8896" class="Symbol">_</a>       <a id="8904" class="Symbol">=</a> <a id="8906" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8910" class="Symbol">(</a><a id="8911" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8915" href="decidability.html#8893" class="Bound">x</a><a id="8916" class="Symbol">)</a>
<a id="8918" href="decidability.html#8691" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8943" class="Symbol">(</a><a id="8944" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8948" class="Symbol">_)</a> <a id="8951" class="Symbol">(</a><a id="8952" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8956" href="decidability.html#8956" class="Bound">y</a><a id="8957" class="Symbol">)</a> <a id="8959" class="Symbol">=</a> <a id="8961" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8965" class="Symbol">(</a><a id="8966" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8970" href="decidability.html#8956" class="Bound">y</a><a id="8971" class="Symbol">)</a>
<a id="8973" href="decidability.html#8691" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8998" class="Symbol">(</a><a id="8999" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9003" href="decidability.html#9003" class="Bound">h</a><a id="9004" class="Symbol">)</a> <a id="9006" class="Symbol">(</a><a id="9007" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9011" href="decidability.html#9011" class="Bound">k</a><a id="9012" class="Symbol">)</a> <a id="9014" class="Symbol">=</a> <a id="9016" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9020" class="Symbol">(</a><a id="9021" href="binary-sums.html#3750" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9035" href="decidability.html#9003" class="Bound">h</a> <a id="9037" href="decidability.html#9011" class="Bound">k</a><a id="9038" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9041" href="decidability.html#9041" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9066" class="Symbol">:</a> <a id="9068" class="Symbol">{</a><a id="9069" href="decidability.html#9069" class="Bound">A</a> <a id="9071" href="decidability.html#9071" class="Bound">B</a> <a id="9073" class="Symbol">:</a> <a id="9075" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9079" class="Symbol">}</a>
                         <a id="9106" class="Symbol">→</a> <a id="9108" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9121" href="decidability.html#9069" class="Bound">A</a>
                         <a id="9148" class="Symbol">→</a> <a id="9150" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9163" href="decidability.html#9071" class="Bound">B</a>
                         <a id="9190" class="Symbol">→</a> <a id="9192" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9205" class="Symbol">(</a><a id="9206" href="decidability.html#9069" class="Bound">A</a> <a id="9208" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9210" href="decidability.html#9071" class="Bound">B</a><a id="9211" class="Symbol">)</a>
<a id="9213" href="decidability.html#9041" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9238" class="Symbol">(</a><a id="9239" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9243" href="decidability.html#9243" class="Bound">x</a><a id="9244" class="Symbol">)</a> <a id="9246" class="Symbol">(</a><a id="9247" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9251" href="decidability.html#9251" class="Bound">y</a><a id="9252" class="Symbol">)</a> <a id="9254" class="Symbol">=</a> <a id="9256" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9260" class="Symbol">(</a><a id="9261" href="decidability.html#9243" class="Bound">x</a> <a id="9263" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9265" href="decidability.html#9251" class="Bound">y</a><a id="9266" class="Symbol">)</a>
<a id="9268" href="decidability.html#9041" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9293" class="Symbol">(</a><a id="9294" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9298" class="Symbol">_)</a> <a id="9301" class="Symbol">(</a><a id="9302" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9306" href="decidability.html#9306" class="Bound">k</a><a id="9307" class="Symbol">)</a> <a id="9309" class="Symbol">=</a> <a id="9311" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9315" class="Symbol">(λ</a> <a id="9318" class="Symbol">(</a><a id="9319" href="decidability.html#9319" class="Bound">x</a> <a id="9321" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9323" href="decidability.html#9323" class="Bound">y</a><a id="9324" class="Symbol">)</a> <a id="9326" class="Symbol">→</a> <a id="9328" href="decidability.html#9306" class="Bound">k</a> <a id="9330" href="decidability.html#9323" class="Bound">y</a><a id="9331" class="Symbol">)</a>
<a id="9333" href="decidability.html#9041" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9358" class="Symbol">(</a><a id="9359" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9363" href="decidability.html#9363" class="Bound">h</a><a id="9364" class="Symbol">)</a> <a id="9366" class="Symbol">_</a>       <a id="9374" class="Symbol">=</a> <a id="9376" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9380" class="Symbol">(λ</a> <a id="9383" class="Symbol">(</a><a id="9384" href="decidability.html#9384" class="Bound">x</a> <a id="9386" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9388" href="decidability.html#9388" class="Bound">y</a><a id="9389" class="Symbol">)</a> <a id="9391" class="Symbol">→</a> <a id="9393" href="decidability.html#9363" class="Bound">h</a> <a id="9395" href="decidability.html#9384" class="Bound">x</a><a id="9396" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9399" href="decidability.html#9399" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9424" class="Symbol">:</a> <a id="9426" class="Symbol">{</a><a id="9427" href="decidability.html#9427" class="Bound">A</a> <a id="9429" href="decidability.html#9429" class="Bound">B</a> <a id="9431" class="Symbol">:</a> <a id="9433" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9437" class="Symbol">}</a>
                         <a id="9464" class="Symbol">→</a> <a id="9466" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9479" href="decidability.html#9427" class="Bound">A</a>
                         <a id="9506" class="Symbol">→</a> <a id="9508" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9521" href="decidability.html#9429" class="Bound">B</a>
                         <a id="9548" class="Symbol">→</a> <a id="9550" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9563" class="Symbol">(</a><a id="9564" href="decidability.html#9427" class="Bound">A</a> <a id="9566" class="Symbol">→</a> <a id="9568" href="decidability.html#9429" class="Bound">B</a><a id="9569" class="Symbol">)</a>
<a id="9571" href="decidability.html#9399" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9596" class="Symbol">_</a>       <a id="9604" class="Symbol">(</a><a id="9605" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9609" href="decidability.html#9609" class="Bound">y</a><a id="9610" class="Symbol">)</a> <a id="9612" class="Symbol">=</a> <a id="9614" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9618" class="Symbol">(λ</a> <a id="9621" href="decidability.html#9621" class="Bound">_</a> <a id="9623" class="Symbol">→</a> <a id="9625" href="decidability.html#9609" class="Bound">y</a><a id="9626" class="Symbol">)</a>
<a id="9628" href="decidability.html#9399" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9653" class="Symbol">(</a><a id="9654" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9658" href="decidability.html#9658" class="Bound">x</a><a id="9659" class="Symbol">)</a> <a id="9661" class="Symbol">(</a><a id="9662" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9666" href="decidability.html#9666" class="Bound">k</a><a id="9667" class="Symbol">)</a> <a id="9669" class="Symbol">=</a> <a id="9671" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9675" class="Symbol">(λ</a> <a id="9678" href="decidability.html#9678" class="Bound">f</a> <a id="9680" class="Symbol">→</a> <a id="9682" href="decidability.html#9666" class="Bound">k</a> <a id="9684" class="Symbol">(</a><a id="9685" href="decidability.html#9678" class="Bound">f</a> <a id="9687" href="decidability.html#9658" class="Bound">x</a><a id="9688" class="Symbol">))</a>
<a id="9691" href="decidability.html#9399" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9716" class="Symbol">(</a><a id="9717" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9721" href="decidability.html#9721" class="Bound">h</a><a id="9722" class="Symbol">)</a> <a id="9724" class="Symbol">(</a><a id="9725" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9729" href="decidability.html#9729" class="Bound">k</a><a id="9730" class="Symbol">)</a> <a id="9732" class="Symbol">=</a> <a id="9734" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9738" class="Symbol">(λ</a> <a id="9741" href="decidability.html#9741" class="Bound">x</a> <a id="9743" class="Symbol">→</a> <a id="9745" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="9752" class="Symbol">(</a><a id="9753" href="decidability.html#9721" class="Bound">h</a> <a id="9755" href="decidability.html#9741" class="Bound">x</a><a id="9756" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="9760" href="decidability.html#9760" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9785" class="Symbol">:</a> <a id="9787" class="Symbol">{</a><a id="9788" href="decidability.html#9788" class="Bound">A</a> <a id="9790" class="Symbol">:</a> <a id="9792" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9796" class="Symbol">}</a>
                         <a id="9823" class="Symbol">→</a> <a id="9825" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9838" href="decidability.html#9788" class="Bound">A</a>
                         <a id="9865" class="Symbol">→</a> <a id="9867" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="9880" class="Symbol">(</a><a id="9881" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="9883" href="decidability.html#9788" class="Bound">A</a><a id="9884" class="Symbol">)</a>
<a id="9886" href="decidability.html#9760" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9911" href="decidability.html#9911" class="Bound">d</a> <a id="9913" class="Symbol">=</a> <a id="9915" href="decidability.html#9399" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9940" href="decidability.html#9911" class="Bound">d</a> <a id="9942" href="decidability.html#8604" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h3 id="exhaustively-searchable-types">Exhaustively searchable
types</h3>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10469" href="decidability.html#10469" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10496" class="Symbol">:</a> <a id="10498" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="10503" class="Symbol">→</a> <a id="10505" href="general-notation.html#683" data-type="Set₂" class="Function">Type₁</a>
<a id="10511" href="decidability.html#10469" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10538" href="decidability.html#10538" class="Bound">X</a> <a id="10540" class="Symbol">=</a> <a id="10542" class="Symbol">(</a><a id="10543" href="decidability.html#10543" class="Bound">A</a> <a id="10545" class="Symbol">:</a> <a id="10547" href="decidability.html#10538" class="Bound">X</a> <a id="10549" class="Symbol">→</a> <a id="10551" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="10555" class="Symbol">)</a>
                             <a id="10586" class="Symbol">→</a> <a id="10588" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10611" href="decidability.html#10543" class="Bound">A</a>
                             <a id="10642" class="Symbol">→</a> <a id="10644" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="10657" class="Symbol">(</a><a id="10658" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="10660" href="decidability.html#10660" class="Bound">x</a> <a id="10662" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="10664" href="decidability.html#10538" class="Bound">X</a> <a id="10666" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="10668" href="decidability.html#10543" class="Bound">A</a> <a id="10670" href="decidability.html#10660" class="Bound">x</a><a id="10671" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12090" href="decidability.html#12090" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12107" class="Symbol">:</a> <a id="12109" class="Symbol">(</a><a id="12110" href="decidability.html#12110" class="Bound">X</a> <a id="12112" class="Symbol">:</a> <a id="12114" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12118" class="Symbol">)</a>
                 <a id="12137" class="Symbol">→</a> <a id="12139" href="decidability.html#10469" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12166" href="decidability.html#12110" class="Bound">X</a>
                 <a id="12185" class="Symbol">→</a> <a id="12187" class="Symbol">(</a><a id="12188" href="decidability.html#12188" class="Bound">A</a> <a id="12190" class="Symbol">:</a> <a id="12192" href="decidability.html#12110" class="Bound">X</a> <a id="12194" class="Symbol">→</a> <a id="12196" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12200" class="Symbol">)</a>
                 <a id="12219" class="Symbol">→</a> <a id="12221" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12244" href="decidability.html#12188" class="Bound">A</a>
                 <a id="12263" class="Symbol">→</a> <a id="12265" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12278" class="Symbol">(</a><a id="12279" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12281" href="decidability.html#12281" class="Bound">x</a> <a id="12283" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12285" href="decidability.html#12110" class="Bound">X</a> <a id="12287" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12289" href="decidability.html#12188" class="Bound">A</a> <a id="12291" href="decidability.html#12281" class="Bound">x</a><a id="12292" class="Symbol">)</a>
<a id="12294" href="decidability.html#12090" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12311" href="decidability.html#12311" class="Bound">X</a> <a id="12313" href="decidability.html#12313" class="Bound">s</a> <a id="12315" href="decidability.html#12315" class="Bound">A</a> <a id="12317" href="decidability.html#12317" class="Bound">d</a> <a id="12319" class="Symbol">=</a> <a id="12321" href="decidability.html#12805" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12325" class="Keyword">where</a>
  <a id="12333" href="decidability.html#12333" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12335" class="Symbol">:</a> <a id="12337" href="decidability.html#5305" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12360" class="Symbol">(λ</a> <a id="12363" href="decidability.html#12363" class="Bound">x</a> <a id="12365" class="Symbol">→</a> <a id="12367" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12369" class="Symbol">(</a><a id="12370" href="decidability.html#12315" class="Bound">A</a> <a id="12372" href="decidability.html#12363" class="Bound">x</a><a id="12373" class="Symbol">))</a>
  <a id="12378" href="decidability.html#12333" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12380" href="decidability.html#12380" class="Bound">x</a> <a id="12382" class="Symbol">=</a> <a id="12384" href="decidability.html#9760" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12409" class="Symbol">(</a><a id="12410" href="decidability.html#12317" class="Bound">d</a> <a id="12412" href="decidability.html#12380" class="Bound">x</a><a id="12413" class="Symbol">)</a>

  <a id="12418" href="decidability.html#12418" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12421" class="Symbol">:</a> <a id="12423" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12436" class="Symbol">(</a><a id="12437" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12439" href="decidability.html#12439" class="Bound">x</a> <a id="12441" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12443" href="decidability.html#12311" class="Bound">X</a> <a id="12445" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12447" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12449" class="Symbol">(</a><a id="12450" href="decidability.html#12315" class="Bound">A</a> <a id="12452" href="decidability.html#12439" class="Bound">x</a><a id="12453" class="Symbol">))</a>
  <a id="12458" href="decidability.html#12418" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12461" class="Symbol">=</a> <a id="12463" href="decidability.html#12313" class="Bound">s</a> <a id="12465" class="Symbol">(λ</a> <a id="12468" href="decidability.html#12468" class="Bound">x</a> <a id="12470" class="Symbol">→</a> <a id="12472" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12474" class="Symbol">(</a><a id="12475" href="decidability.html#12315" class="Bound">A</a> <a id="12477" href="decidability.html#12468" class="Bound">x</a><a id="12478" class="Symbol">))</a> <a id="12481" href="decidability.html#12333" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12486" href="decidability.html#12486" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12490" class="Symbol">:</a> <a id="12492" class="Symbol">(</a><a id="12493" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12495" href="decidability.html#12495" class="Bound">x</a> <a id="12497" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12499" href="decidability.html#12311" class="Bound">X</a> <a id="12501" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12503" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12505" class="Symbol">(</a><a id="12506" href="decidability.html#12315" class="Bound">A</a> <a id="12508" href="decidability.html#12495" class="Bound">x</a><a id="12509" class="Symbol">))</a> <a id="12512" class="Symbol">→</a> <a id="12514" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12516" class="Symbol">(</a><a id="12517" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12519" href="decidability.html#12519" class="Bound">x</a> <a id="12521" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12523" href="decidability.html#12311" class="Bound">X</a> <a id="12525" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12527" href="decidability.html#12315" class="Bound">A</a> <a id="12529" href="decidability.html#12519" class="Bound">x</a><a id="12530" class="Symbol">)</a>
  <a id="12534" href="decidability.html#12486" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12538" class="Symbol">(</a><a id="12539" href="decidability.html#12539" class="Bound">x</a> <a id="12541" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12543" href="decidability.html#12543" class="Bound">f</a><a id="12544" class="Symbol">)</a> <a id="12546" href="decidability.html#12546" class="Bound">g</a> <a id="12548" class="Symbol">=</a> <a id="12550" href="decidability.html#12543" class="Bound">f</a> <a id="12552" class="Symbol">(</a><a id="12553" href="decidability.html#12546" class="Bound">g</a> <a id="12555" href="decidability.html#12539" class="Bound">x</a><a id="12556" class="Symbol">)</a>

  <a id="12561" href="decidability.html#12561" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12564" class="Symbol">:</a> <a id="12566" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12568" class="Symbol">(</a><a id="12569" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12571" href="decidability.html#12571" class="Bound">x</a> <a id="12573" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12575" href="decidability.html#12311" class="Bound">X</a> <a id="12577" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12579" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12581" class="Symbol">(</a><a id="12582" href="decidability.html#12315" class="Bound">A</a> <a id="12584" href="decidability.html#12571" class="Bound">x</a><a id="12585" class="Symbol">))</a> <a id="12588" class="Symbol">→</a> <a id="12590" class="Symbol">(</a><a id="12591" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12593" href="decidability.html#12593" class="Bound">x</a> <a id="12595" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12597" href="decidability.html#12311" class="Bound">X</a> <a id="12599" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12601" href="decidability.html#12315" class="Bound">A</a> <a id="12603" href="decidability.html#12593" class="Bound">x</a><a id="12604" class="Symbol">)</a>
  <a id="12608" href="decidability.html#12561" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12611" href="decidability.html#12611" class="Bound">h</a> <a id="12613" href="decidability.html#12613" class="Bound">x</a> <a id="12615" class="Symbol">=</a> <a id="12617" href="decidability.html#12669" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="12623" class="Keyword">where</a>
    <a id="12633" href="decidability.html#12633" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12635" class="Symbol">:</a> <a id="12637" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="12640" href="decidability.html#12315" class="Bound">A</a> <a id="12642" href="decidability.html#12613" class="Bound">x</a>
    <a id="12648" href="decidability.html#12633" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12650" href="decidability.html#12650" class="Bound">f</a> <a id="12652" class="Symbol">=</a> <a id="12654" href="decidability.html#12611" class="Bound">h</a> <a id="12656" class="Symbol">(</a><a id="12657" href="decidability.html#12613" class="Bound">x</a> <a id="12659" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12661" href="decidability.html#12650" class="Bound">f</a><a id="12662" class="Symbol">)</a>

    <a id="12669" href="decidability.html#12669" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12672" class="Symbol">:</a> <a id="12674" href="decidability.html#12315" class="Bound">A</a> <a id="12676" href="decidability.html#12613" class="Bound">x</a>
    <a id="12682" href="decidability.html#12669" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12685" class="Symbol">=</a> <a id="12687" href="decidability.html#2881" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="12695" class="Symbol">(</a><a id="12696" href="decidability.html#12317" class="Bound">d</a> <a id="12698" href="decidability.html#12613" class="Bound">x</a><a id="12699" class="Symbol">)</a> <a id="12701" href="decidability.html#12633" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="12706" href="decidability.html#12706" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12708" class="Symbol">:</a> <a id="12710" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12723" class="Symbol">(</a><a id="12724" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12726" href="decidability.html#12726" class="Bound">x</a> <a id="12728" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12730" href="decidability.html#12311" class="Bound">X</a> <a id="12732" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12734" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12736" class="Symbol">(</a><a id="12737" href="decidability.html#12315" class="Bound">A</a> <a id="12739" href="decidability.html#12726" class="Bound">x</a><a id="12740" class="Symbol">))</a> <a id="12743" class="Symbol">→</a> <a id="12745" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12758" class="Symbol">(</a><a id="12759" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12761" href="decidability.html#12761" class="Bound">x</a> <a id="12763" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12765" href="decidability.html#12311" class="Bound">X</a> <a id="12767" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12769" href="decidability.html#12315" class="Bound">A</a> <a id="12771" href="decidability.html#12761" class="Bound">x</a><a id="12772" class="Symbol">)</a>
  <a id="12776" href="decidability.html#12706" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12778" class="Symbol">=</a> <a id="12780" href="decidability.html#8153" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="12795" href="decidability.html#12486" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12799" href="decidability.html#12561" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="12805" href="decidability.html#12805" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12808" class="Symbol">:</a> <a id="12810" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="12823" class="Symbol">(</a><a id="12824" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12826" href="decidability.html#12826" class="Bound">x</a> <a id="12828" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12830" href="decidability.html#12311" class="Bound">X</a> <a id="12832" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12834" href="decidability.html#12315" class="Bound">A</a> <a id="12836" href="decidability.html#12826" class="Bound">x</a><a id="12837" class="Symbol">)</a>
  <a id="12841" href="decidability.html#12805" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12844" class="Symbol">=</a> <a id="12846" href="decidability.html#12706" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12848" href="decidability.html#12418" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h3 id="decidable-equality">Decidable equality</h3>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13374" href="decidability.html#13374" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13397" class="Symbol">:</a> <a id="13399" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="13404" class="Symbol">→</a> <a id="13406" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="13411" href="decidability.html#13374" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13434" href="decidability.html#13434" class="Bound">X</a> <a id="13436" class="Symbol">=</a> <a id="13438" class="Symbol">(</a><a id="13439" href="decidability.html#13439" class="Bound">x</a> <a id="13441" href="decidability.html#13441" class="Bound">y</a> <a id="13443" class="Symbol">:</a> <a id="13445" href="decidability.html#13434" class="Bound">X</a><a id="13446" class="Symbol">)</a> <a id="13448" class="Symbol">→</a> <a id="13450" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="13463" class="Symbol">(</a><a id="13464" href="decidability.html#13439" class="Bound">x</a> <a id="13466" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13468" href="decidability.html#13441" class="Bound">y</a><a id="13469" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="13675" href="decidability.html#13675" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13703" class="Symbol">:</a> <a id="13705" href="decidability.html#13374" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13728" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="13733" href="decidability.html#13675" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13761" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13767" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13773" class="Symbol">=</a> <a id="13775" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13779" class="Symbol">(</a><a id="13780" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13785" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="13789" class="Symbol">)</a>
<a id="13791" href="decidability.html#13675" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13819" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13825" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13831" class="Symbol">=</a> <a id="13833" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13837" href="negation.html#3353" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="13855" href="decidability.html#13675" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13883" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13889" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13895" class="Symbol">=</a> <a id="13897" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13901" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="13919" href="decidability.html#13675" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13947" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13953" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="13959" class="Symbol">=</a> <a id="13961" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13965" class="Symbol">(</a><a id="13966" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13971" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="13976" class="Symbol">)</a>

<a id="13979" class="Keyword">open</a> <a id="13984" class="Keyword">import</a> <a id="13991" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14018" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14043" class="Symbol">:</a> <a id="14045" href="decidability.html#13374" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14068" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>
<a id="14070" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14095" class="Number">0</a>       <a id="14103" class="Number">0</a>       <a id="14111" class="Symbol">=</a> <a id="14113" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14117" class="Symbol">(</a><a id="14118" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14123" href="introduction.html#551" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14127" class="Symbol">)</a>
<a id="14129" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14154" class="Number">0</a>       <a id="14162" class="Symbol">(</a><a id="14163" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14167" href="decidability.html#14167" class="Bound">y</a><a id="14168" class="Symbol">)</a> <a id="14170" class="Symbol">=</a> <a id="14172" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14176" href="natural-numbers-functions.html#501" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14192" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14217" class="Symbol">(</a><a id="14218" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14222" href="decidability.html#14222" class="Bound">x</a><a id="14223" class="Symbol">)</a> <a id="14225" class="Number">0</a>       <a id="14233" class="Symbol">=</a> <a id="14235" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14239" href="natural-numbers-functions.html#443" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14255" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14280" class="Symbol">(</a><a id="14281" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14285" href="decidability.html#14285" class="Bound">x</a><a id="14286" class="Symbol">)</a> <a id="14288" class="Symbol">(</a><a id="14289" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14293" href="decidability.html#14293" class="Bound">y</a><a id="14294" class="Symbol">)</a> <a id="14296" class="Symbol">=</a> <a id="14298" href="decidability.html#14472" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14303" class="Keyword">where</a>
  <a id="14311" href="decidability.html#14311" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14314" class="Symbol">:</a> <a id="14316" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="14329" class="Symbol">(</a><a id="14330" href="decidability.html#14285" class="Bound">x</a> <a id="14332" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14334" href="decidability.html#14293" class="Bound">y</a><a id="14335" class="Symbol">)</a>
  <a id="14339" href="decidability.html#14311" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14342" class="Symbol">=</a> <a id="14344" href="decidability.html#14018" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14369" href="decidability.html#14285" class="Bound">x</a> <a id="14371" href="decidability.html#14293" class="Bound">y</a>

  <a id="14376" href="decidability.html#14376" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14378" class="Symbol">:</a> <a id="14380" href="decidability.html#14285" class="Bound">x</a> <a id="14382" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14384" href="decidability.html#14293" class="Bound">y</a> <a id="14386" class="Symbol">→</a> <a id="14388" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14392" href="decidability.html#14285" class="Bound">x</a> <a id="14394" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14396" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14400" href="decidability.html#14293" class="Bound">y</a>
  <a id="14404" href="decidability.html#14376" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14406" class="Symbol">=</a> <a id="14408" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14411" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14418" href="decidability.html#14418" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14421" class="Symbol">:</a> <a id="14423" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14427" href="decidability.html#14285" class="Bound">x</a> <a id="14429" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14431" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14435" href="decidability.html#14293" class="Bound">y</a> <a id="14437" class="Symbol">→</a> <a id="14439" href="decidability.html#14285" class="Bound">x</a> <a id="14441" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14443" href="decidability.html#14293" class="Bound">y</a>
  <a id="14447" href="decidability.html#14418" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14450" class="Symbol">=</a> <a id="14452" href="natural-numbers-functions.html#607" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14472" href="decidability.html#14472" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14476" class="Symbol">:</a> <a id="14478" href="decidability.html#2606" data-type="Type → Type" class="Function">is-decidable</a> <a id="14491" class="Symbol">(</a><a id="14492" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14496" href="decidability.html#14285" class="Bound">x</a> <a id="14498" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14500" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14504" href="decidability.html#14293" class="Bound">y</a><a id="14505" class="Symbol">)</a>
  <a id="14509" href="decidability.html#14472" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14513" class="Symbol">=</a> <a id="14515" href="decidability.html#7803" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14529" href="decidability.html#14376" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14531" href="decidability.html#14418" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14534" href="decidability.html#14311" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h3 id="equality-of-functions">Equality of functions</h3>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="14822" class="Keyword">private</a>
 <a id="f"></a><a id="14831" href="decidability.html#14831" class="Function">f</a> <a id="g"></a><a id="14833" href="decidability.html#14833" class="Function">g</a> <a id="h"></a><a id="14835" href="decidability.html#14835" class="Function">h</a> <a id="14837" class="Symbol">:</a> <a id="14839" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a> <a id="14841" class="Symbol">→</a> <a id="14843" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>

 <a id="14847" href="decidability.html#14831" class="Function">f</a> <a id="14849" href="decidability.html#14849" class="Bound">x</a> <a id="14851" class="Symbol">=</a> <a id="14853" href="decidability.html#14849" class="Bound">x</a>

 <a id="14857" href="decidability.html#14833" class="Function">g</a> <a id="14859" class="Number">0</a>       <a id="14867" class="Symbol">=</a> <a id="14869" class="Number">0</a>
 <a id="14872" href="decidability.html#14833" class="Function">g</a> <a id="14874" class="Symbol">(</a><a id="14875" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14879" href="decidability.html#14879" class="Bound">x</a><a id="14880" class="Symbol">)</a> <a id="14882" class="Symbol">=</a> <a id="14884" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14888" class="Symbol">(</a><a id="14889" href="decidability.html#14833" class="Function">g</a> <a id="14891" href="decidability.html#14879" class="Bound">x</a><a id="14892" class="Symbol">)</a>

 <a id="14896" href="decidability.html#14835" class="Function">h</a> <a id="14898" href="decidability.html#14898" class="Bound">x</a> <a id="14900" class="Symbol">=</a> <a id="14902" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14906" href="decidability.html#14898" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="14910" href="decidability.html#14910" class="Function">f-equals-g</a> <a id="14921" class="Symbol">:</a> <a id="14923" href="decidability.html#14831" class="Function">f</a> <a id="14925" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="14927" href="decidability.html#14833" class="Function">g</a>
 <a id="14930" href="decidability.html#14910" class="Function">f-equals-g</a> <a id="14941" class="Number">0</a>       <a id="14949" class="Symbol">=</a> <a id="14951" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14956" class="Symbol">(</a><a id="14957" href="decidability.html#14831" class="Function">f</a> <a id="14959" class="Number">0</a><a id="14960" class="Symbol">)</a>
 <a id="14963" href="decidability.html#14910" class="Function">f-equals-g</a> <a id="14974" class="Symbol">(</a><a id="14975" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14979" href="decidability.html#14979" class="Bound">x</a><a id="14980" class="Symbol">)</a> <a id="14982" class="Symbol">=</a> <a id="14984" href="decidability.html#15037" class="Function">γ</a>
  <a id="14988" class="Keyword">where</a>
   <a id="14997" href="decidability.html#14997" class="Function">IH</a> <a id="15000" class="Symbol">:</a> <a id="15002" href="decidability.html#14831" class="Function">f</a> <a id="15004" href="decidability.html#14979" class="Bound">x</a> <a id="15006" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15008" href="decidability.html#14833" class="Function">g</a> <a id="15010" href="decidability.html#14979" class="Bound">x</a>
   <a id="15015" href="decidability.html#14997" class="Function">IH</a> <a id="15018" class="Symbol">=</a> <a id="15020" href="decidability.html#14910" class="Function">f-equals-g</a> <a id="15031" href="decidability.html#14979" class="Bound">x</a>

   <a id="15037" href="decidability.html#15037" class="Function">γ</a> <a id="15039" class="Symbol">:</a> <a id="15041" href="decidability.html#14831" class="Function">f</a> <a id="15043" class="Symbol">(</a><a id="15044" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15048" href="decidability.html#14979" class="Bound">x</a><a id="15049" class="Symbol">)</a> <a id="15051" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15053" href="decidability.html#14833" class="Function">g</a> <a id="15055" class="Symbol">(</a><a id="15056" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15060" href="decidability.html#14979" class="Bound">x</a><a id="15061" class="Symbol">)</a>
   <a id="15066" href="decidability.html#15037" class="Function">γ</a> <a id="15068" class="Symbol">=</a> <a id="15070" href="decidability.html#14831" class="Function">f</a> <a id="15072" class="Symbol">(</a><a id="15073" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15077" href="decidability.html#14979" class="Bound">x</a><a id="15078" class="Symbol">)</a> <a id="15080" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15083" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15088" class="Symbol">_</a> <a id="15090" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15099" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15103" href="decidability.html#14979" class="Bound">x</a>     <a id="15109" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15112" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15117" class="Symbol">_</a> <a id="15119" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15128" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15132" class="Symbol">(</a><a id="15133" href="decidability.html#14831" class="Function">f</a> <a id="15135" href="decidability.html#14979" class="Bound">x</a><a id="15136" class="Symbol">)</a> <a id="15138" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15141" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15144" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15148" href="decidability.html#14997" class="Function">IH</a> <a id="15151" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15160" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15164" class="Symbol">(</a><a id="15165" href="decidability.html#14833" class="Function">g</a> <a id="15167" href="decidability.html#14979" class="Bound">x</a><a id="15168" class="Symbol">)</a> <a id="15170" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15173" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15178" class="Symbol">_</a> <a id="15180" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15189" href="decidability.html#14833" class="Function">g</a> <a id="15191" class="Symbol">(</a><a id="15192" href="introduction.html#561" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15196" href="decidability.html#14979" class="Bound">x</a><a id="15197" class="Symbol">)</a> <a id="15199" href="identity-type.html#4194" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15203" href="decidability.html#15203" class="Function">f-not-equals-h</a> <a id="15218" class="Symbol">:</a> <a id="15220" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15222" class="Symbol">(</a><a id="15223" href="decidability.html#14831" class="Function">f</a> <a id="15225" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15227" href="decidability.html#14835" class="Function">h</a><a id="15228" class="Symbol">)</a>
 <a id="15231" href="decidability.html#15203" class="Function">f-not-equals-h</a> <a id="15246" href="decidability.html#15246" class="Bound">e</a> <a id="15248" class="Symbol">=</a> <a id="15250" href="decidability.html#15302" class="Function">contradiction</a> <a id="15264" href="decidability.html#15277" class="Function">d</a>
  <a id="15268" class="Keyword">where</a>
   <a id="15277" href="decidability.html#15277" class="Function">d</a> <a id="15279" class="Symbol">:</a> <a id="15281" class="Number">0</a> <a id="15283" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15285" class="Number">1</a>
   <a id="15290" href="decidability.html#15277" class="Function">d</a> <a id="15292" class="Symbol">=</a> <a id="15294" href="decidability.html#15246" class="Bound">e</a> <a id="15296" class="Number">0</a>

   <a id="15302" href="decidability.html#15302" class="Function">contradiction</a> <a id="15316" class="Symbol">:</a> <a id="15318" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15320" class="Symbol">(</a><a id="15321" class="Number">0</a> <a id="15323" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15325" class="Number">1</a><a id="15326" class="Symbol">)</a>
   <a id="15331" href="decidability.html#15302" class="Function">contradiction</a> <a id="15345" class="Symbol">()</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
