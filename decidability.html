<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p>Martin Escardo. Notes originally written for the module “Advanced
Functional Programming” at the School of Computer Science of the
University of Birmingham, UK.</p>
<!--
<pre class="Agda"><a id="178" class="Symbol">{-#</a> <a id="182" class="Keyword">OPTIONS</a> <a id="190" class="Pragma">--without-K</a> <a id="202" class="Pragma">--safe</a> <a id="209" class="Symbol">#-}</a>

<a id="214" class="Keyword">module</a> <a id="221" href="decidability.html" class="Module">decidability</a> <a id="234" class="Keyword">where</a>

<a id="241" class="Keyword">open</a> <a id="246" class="Keyword">import</a> <a id="253" href="prelude.html" class="Module">prelude</a>
<a id="261" class="Keyword">open</a> <a id="266" class="Keyword">import</a> <a id="273" href="negation.html" class="Module">negation</a>
<a id="282" class="Keyword">open</a> <a id="287" class="Keyword">import</a> <a id="294" href="natural-numbers-type.html" class="Module">natural-numbers-type</a>
</pre>-->
<h1
id="propositions-as-types-versus-propositions-as-booleans">Propositions
as types versus propositions as booleans</h1>
<p>When programming in conventional programming languages such as
Haskell, C, Java, Python, etc., we use <em>booleans</em> rather than
<em>types</em> to encode logical propositions. But this works only
because we restrict ourselves to <em>decidable</em> propositions, as
we’ll see below.</p>
<p>We now discuss <em>why</em> we use <em>types</em> to encode logical
propositions, and <em>when</em> we can use <em>booleans</em> instead. It
is not always.</p>
<h2 id="discussion-and-motivation">Discussion and motivation</h2>
<p><strong>Examples.</strong> We <em>can automatically check</em>
equality of booleans, integers, strings and much more, using
algorithms.</p>
<p><strong>Counter-example.</strong> We <em>can’t check</em> equality of
functions of type <code>ℕ → ℕ</code>, for instance. Intuitively, to
check that two functions <code>f</code> and <code>g</code> of this type
are equal, we need to check infinitely many cases, namely
<code>f x = g x</code> for all <code>x : ℕ</code>. But, we are afraid,
intuition is not enough. This has to be proved. Luckily in our case, <a
href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>
provided the basis to prove that. He showed that the <a
href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>
can’t be solved by an algorithm in any programming language. It follows
from this that we can’t check whether two such functions <code>f</code>
and <code>g</code> are equal or not using an algorithm.</p>
<p>The above examples and counter-examples show that sometimes we can
decide equality with an algorithm, and sometimes we can’t. However, for
example, the identity type <code>_≡_</code> applies to <em>all</em>
types, whether they have decidable equality or not, and this is why it
is useful. We can think about equality, not only in our heads but also
in Agda, without worrying whether it can be <em>checked</em> to be true
or not by a computer. The identity type is not about <em>checking</em>
equality. It is about asserting that two things are equal, and then
proving this ourselves. In fact, equality is very often not checkable by
the computer. It is instead about <em>stating</em> and <em>proving</em>
or <em>disproving</em> equalities, where the proving and disproving is
done by people (the lecturers and the students in this case), by hard,
intelligent work.</p>
<h2 id="decidable-propositions">Decidable propositions</h2>
Motivated by the above discussion, we define when a logical proposition
is decidable under the understanding of propositions as types:
<pre class="Agda"><a id="is-decidable"></a><a id="2591" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="2604" class="Symbol">:</a> <a id="2606" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="2611" class="Symbol">→</a> <a id="2613" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="2618" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="2631" href="decidability.html#2631" class="Bound">A</a> <a id="2633" class="Symbol">=</a> <a id="2635" href="decidability.html#2631" class="Bound">A</a> <a id="2637" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2639" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="2641" href="decidability.html#2631" class="Bound">A</a>
</pre>
<p>This means that we can produce an element of <code>A</code> or show
that no such element can be found.</p>
Although it is not possible in general to write a program of type
<code>¬¬ A → A</code>, this is possible when <code>A</code> is
decidable:
<pre class="Agda"><a id="¬¬-elim"></a><a id="2866" href="decidability.html#2866" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2874" class="Symbol">:</a> <a id="2876" class="Symbol">{</a><a id="2877" href="decidability.html#2877" class="Bound">A</a> <a id="2879" class="Symbol">:</a> <a id="2881" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2885" class="Symbol">}</a> <a id="2887" class="Symbol">→</a> <a id="2889" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="2902" href="decidability.html#2877" class="Bound">A</a> <a id="2904" class="Symbol">→</a> <a id="2906" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2909" href="decidability.html#2877" class="Bound">A</a> <a id="2911" class="Symbol">→</a> <a id="2913" href="decidability.html#2877" class="Bound">A</a>
<a id="2915" href="decidability.html#2866" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2923" class="Symbol">(</a><a id="2924" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2928" href="decidability.html#2928" class="Bound">x</a><a id="2929" class="Symbol">)</a> <a id="2931" href="decidability.html#2931" class="Bound">f</a> <a id="2933" class="Symbol">=</a> <a id="2935" href="decidability.html#2928" class="Bound">x</a>
<a id="2937" href="decidability.html#2866" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="2945" class="Symbol">(</a><a id="2946" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2950" href="decidability.html#2950" class="Bound">g</a><a id="2951" class="Symbol">)</a> <a id="2953" href="decidability.html#2953" class="Bound">f</a> <a id="2955" class="Symbol">=</a> <a id="2957" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="2964" class="Symbol">(</a><a id="2965" href="decidability.html#2953" class="Bound">f</a> <a id="2967" href="decidability.html#2950" class="Bound">g</a><a id="2968" class="Symbol">)</a>
</pre>
<h2 id="decidable-propositions-as-booleans">Decidable propositions as
booleans</h2>
<p>The following shows that a type <code>A</code> is decidable if and
only if there is <code>b : Bool</code> such that <code>A</code> holds if
and only if the boolean <code>b</code> is <code>true</code>.</p>
For the purposes of this handout, understanding the following proof is
not important at a first reading. What is important is to understand
<em>what</em> the type of the following function is saying, which is
what we explained above.
<pre class="Agda"><a id="decidability-with-booleans"></a><a id="3396" href="decidability.html#3396" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3423" class="Symbol">:</a> <a id="3425" class="Symbol">(</a><a id="3426" href="decidability.html#3426" class="Bound">A</a> <a id="3428" class="Symbol">:</a> <a id="3430" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3434" class="Symbol">)</a> <a id="3436" class="Symbol">→</a> <a id="3438" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="3451" href="decidability.html#3426" class="Bound">A</a> <a id="3453" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3455" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3457" href="decidability.html#3457" class="Bound">b</a> <a id="3459" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3461" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="3466" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3468" class="Symbol">(</a><a id="3469" href="decidability.html#3426" class="Bound">A</a> <a id="3471" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3473" href="decidability.html#3457" class="Bound">b</a> <a id="3475" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3477" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="3481" class="Symbol">)</a>
<a id="3483" href="decidability.html#3396" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="3510" href="decidability.html#3510" class="Bound">A</a> <a id="3512" class="Symbol">=</a> <a id="3514" href="decidability.html#3529" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3516" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3518" href="decidability.html#3823" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a>
 <a id="3521" class="Keyword">where</a>
  <a id="3529" href="decidability.html#3529" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3531" class="Symbol">:</a> <a id="3533" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="3546" href="decidability.html#3510" class="Bound">A</a> <a id="3548" class="Symbol">→</a> <a id="3550" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3552" href="decidability.html#3552" class="Bound">b</a> <a id="3554" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3556" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="3561" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3563" class="Symbol">(</a><a id="3564" href="decidability.html#3510" class="Bound">A</a> <a id="3566" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3568" href="decidability.html#3552" class="Bound">b</a> <a id="3570" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3572" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="3576" class="Symbol">)</a>
  <a id="3580" href="decidability.html#3529" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3582" class="Symbol">(</a><a id="3583" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3587" href="decidability.html#3587" class="Bound">x</a><a id="3588" class="Symbol">)</a> <a id="3590" class="Symbol">=</a> <a id="3592" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3597" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3599" class="Symbol">(</a><a id="3600" href="decidability.html#3620" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3602" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3604" href="decidability.html#3665" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a><a id="3605" class="Symbol">)</a>
   <a id="3610" class="Keyword">where</a>
    <a id="3620" href="decidability.html#3620" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3622" class="Symbol">:</a> <a id="3624" href="decidability.html#3510" class="Bound">A</a> <a id="3626" class="Symbol">→</a> <a id="3628" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3633" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3635" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3644" href="decidability.html#3620" data-type="(A : Type) (x : A) → A → true ≡ true" class="Function">α</a> <a id="3646" class="Symbol">_</a> <a id="3648" class="Symbol">=</a> <a id="3650" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3655" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>

    <a id="3665" href="decidability.html#3665" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3667" class="Symbol">:</a> <a id="3669" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3674" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3676" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3681" class="Symbol">→</a> <a id="3683" href="decidability.html#3510" class="Bound">A</a>
    <a id="3689" href="decidability.html#3665" data-type="(A : Type) (x : A) → true ≡ true → A" class="Function">β</a> <a id="3691" class="Symbol">_</a> <a id="3693" class="Symbol">=</a> <a id="3695" href="decidability.html#3587" class="Bound">x</a>

  <a id="3700" href="decidability.html#3529" data-type="(A : Type) → is-decidable A → Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">f</a> <a id="3702" class="Symbol">(</a><a id="3703" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3707" href="decidability.html#3707" class="Bound">ν</a><a id="3708" class="Symbol">)</a> <a id="3710" class="Symbol">=</a> <a id="3712" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="3718" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3720" class="Symbol">(</a><a id="3721" href="decidability.html#3741" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3723" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3725" href="decidability.html#3790" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a><a id="3726" class="Symbol">)</a>
   <a id="3731" class="Keyword">where</a>
    <a id="3741" href="decidability.html#3741" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3743" class="Symbol">:</a> <a id="3745" href="decidability.html#3510" class="Bound">A</a> <a id="3747" class="Symbol">→</a> <a id="3749" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="3755" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3757" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="3766" href="decidability.html#3741" data-type="(A : Type) (ν : ¬ A) → A → false ≡ true" class="Function">α</a> <a id="3768" href="decidability.html#3768" class="Bound">x</a> <a id="3770" class="Symbol">=</a> <a id="3772" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3779" class="Symbol">(</a><a id="3780" href="decidability.html#3707" class="Bound">ν</a> <a id="3782" href="decidability.html#3768" class="Bound">x</a><a id="3783" class="Symbol">)</a>

    <a id="3790" href="decidability.html#3790" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3792" class="Symbol">:</a> <a id="3794" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="3800" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3802" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3807" class="Symbol">→</a> <a id="3809" href="decidability.html#3510" class="Bound">A</a>
    <a id="3815" href="decidability.html#3790" data-type="(A : Type) (ν : ¬ A) → false ≡ true → A" class="Function">β</a> <a id="3817" class="Symbol">()</a>

  <a id="3823" href="decidability.html#3823" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3825" class="Symbol">:</a> <a id="3827" class="Symbol">(</a><a id="3828" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="3830" href="decidability.html#3830" class="Bound">b</a> <a id="3832" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="3834" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="3839" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="3841" class="Symbol">(</a><a id="3842" href="decidability.html#3510" class="Bound">A</a> <a id="3844" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="3846" href="decidability.html#3830" class="Bound">b</a> <a id="3848" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3850" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="3854" class="Symbol">))</a> <a id="3857" class="Symbol">→</a> <a id="3859" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="3872" href="decidability.html#3510" class="Bound">A</a>
  <a id="3876" href="decidability.html#3823" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3878" class="Symbol">(</a><a id="3879" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="3884" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a>  <a id="3887" href="decidability.html#3887" class="Bound">α</a> <a id="3889" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3891" href="decidability.html#3891" class="Bound">β</a><a id="3892" class="Symbol">)</a> <a id="3894" class="Symbol">=</a> <a id="3896" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3900" class="Symbol">(</a><a id="3901" href="decidability.html#3891" class="Bound">β</a> <a id="3903" class="Symbol">(</a><a id="3904" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3909" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="3913" class="Symbol">))</a>
  <a id="3918" href="decidability.html#3823" data-type="(A : Type) → Sigma Bool (λ b → A ⇔ b ≡ true) → is-decidable A" class="Function">g</a> <a id="3920" class="Symbol">(</a><a id="3921" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="3927" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3929" href="decidability.html#3929" class="Bound">α</a> <a id="3931" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3933" href="decidability.html#3933" class="Bound">β</a><a id="3934" class="Symbol">)</a> <a id="3936" class="Symbol">=</a> <a id="3938" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3942" class="Symbol">(λ</a> <a id="3945" href="decidability.html#3945" class="Bound">x</a> <a id="3947" class="Symbol">→</a> <a id="3949" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3967" class="Symbol">(</a><a id="3968" href="decidability.html#3929" class="Bound">α</a> <a id="3970" href="decidability.html#3945" class="Bound">x</a><a id="3971" class="Symbol">))</a>
</pre>
<h2 id="decidable-predicates-as-boolean-valued-functions">Decidable
predicates as boolean-valued functions</h2>
Consider the logical statement “x is even”. This is decidable, because
there is an easy algorithm that tells whether a natural number
<code>x</code> is even or not. In programming languages we write this
algorithm as a procedure that returns a boolean. But an equally valid
definition is to say that <code>x</code> is even if there is a natural
number <code>y</code> such that <code>x = 2 * y</code>. This definition
doesn’t automatically give an algorithm to check whether or not
<code>x</code> is even. <!--
<pre class="Agda"><a id="4495" class="Keyword">module</a> <a id="4502" href="decidability.html#4502" class="Module">_</a> <a id="4504" class="Keyword">where</a>
 <a id="4511" class="Keyword">private</a>
</pre>-->
<pre class="Agda">  <a id="4537" href="decidability.html#4537" class="Function">is-even</a> <a id="4545" class="Symbol">:</a> <a id="4547" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a> <a id="4549" class="Symbol">→</a> <a id="4551" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
  <a id="4558" href="decidability.html#4537" class="Function">is-even</a> <a id="4566" href="decidability.html#4566" class="Bound">x</a> <a id="4568" class="Symbol">=</a> <a id="4570" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4572" href="decidability.html#4572" class="Bound">y</a> <a id="4574" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4576" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a> <a id="4578" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4580" href="decidability.html#4566" class="Bound">x</a> <a id="4582" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4584" class="Number">2</a> <a id="4586" href="natural-numbers-type.html#2896" data-type="ℕ → ℕ → ℕ" class="Function Operator">*</a> <a id="4588" href="decidability.html#4572" class="Bound">y</a>
</pre>
This says what to be even <em>means</em>. But it doesn’t say how we
<em>check</em> with a computer program whether a number is even or not,
which would be given by a function <code>check-even : ℕ → Bool</code>.
<pre class="Agda">  <a id="4790" href="decidability.html#4790" class="Function">check-even</a> <a id="4801" class="Symbol">:</a> <a id="4803" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a> <a id="4805" class="Symbol">→</a> <a id="4807" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a>
  <a id="4814" href="decidability.html#4790" class="Function">check-even</a> <a id="4825" class="Number">0</a>       <a id="4833" class="Symbol">=</a> <a id="4835" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4842" href="decidability.html#4790" class="Function">check-even</a> <a id="4853" class="Symbol">(</a><a id="4854" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="4858" href="decidability.html#4858" class="Bound">x</a><a id="4859" class="Symbol">)</a> <a id="4861" class="Symbol">=</a> <a id="4863" href="Bool.html#4007" data-type="Bool → Bool" class="Function">not</a> <a id="4867" class="Symbol">(</a><a id="4868" href="decidability.html#4790" class="Function">check-even</a> <a id="4879" href="decidability.html#4858" class="Bound">x</a><a id="4880" class="Symbol">)</a>
</pre>
<p>For this function to be correct, it has to be the case that</p>
<blockquote>
<p><code>is-even x ⇔ check-even x ≡ true</code></p>
</blockquote>
<p><strong>Exercise.</strong> We believe you have learned enough Agda,
try this.</p>
<p>This is possible because</p>
<blockquote>
<p><code>(x : X) → is-decidable (is-even x)</code>.</p>
</blockquote>
<p>The following generalizes the above discussion and implements it in
Agda.</p>
First we define what it means for a predicate, such as
<code>A = is-even</code>, to be decidable:
<pre class="Agda"><a id="is-decidable-predicate"></a><a id="5290" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5313" class="Symbol">:</a> <a id="5315" class="Symbol">{</a><a id="5316" href="decidability.html#5316" class="Bound">X</a> <a id="5318" class="Symbol">:</a> <a id="5320" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5324" class="Symbol">}</a> <a id="5326" class="Symbol">→</a> <a id="5328" class="Symbol">(</a><a id="5329" href="decidability.html#5316" class="Bound">X</a> <a id="5331" class="Symbol">→</a> <a id="5333" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5337" class="Symbol">)</a> <a id="5339" class="Symbol">→</a> <a id="5341" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="5346" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="5369" class="Symbol">{</a><a id="5370" href="decidability.html#5370" class="Bound">X</a><a id="5371" class="Symbol">}</a> <a id="5373" href="decidability.html#5373" class="Bound">A</a> <a id="5375" class="Symbol">=</a> <a id="5377" class="Symbol">(</a><a id="5378" href="decidability.html#5378" class="Bound">x</a> <a id="5380" class="Symbol">:</a> <a id="5382" href="decidability.html#5370" class="Bound">X</a><a id="5383" class="Symbol">)</a> <a id="5385" class="Symbol">→</a> <a id="5387" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="5400" class="Symbol">(</a><a id="5401" href="decidability.html#5373" class="Bound">A</a> <a id="5403" href="decidability.html#5378" class="Bound">x</a><a id="5404" class="Symbol">)</a>

</pre>
<p>In our example, this means that we can tell whether a number is even
or not.</p>
<p>Next we show that a predicate <code>A</code> is decidable if and only
if there is a boolean valued function <code>α</code> such that
<code>A x</code> holds if and only if <code>α x ≡ true</code>. In the
above example, <code>A</code> plays the role of <code>is-even</code> and
<code>alpha</code> plays the role of <code>check-even</code>.</p>
<p>Again, what is important at a first reading of this handout is not to
understand the proof but what the type of the function is saying. But we
will discuss the proof in lectures.</p>
<pre class="Agda"><a id="predicate-decidability-with-booleans"></a><a id="5928" href="decidability.html#5928" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="5965" class="Symbol">:</a> <a id="5967" class="Symbol">{</a><a id="5968" href="decidability.html#5968" class="Bound">X</a> <a id="5970" class="Symbol">:</a> <a id="5972" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5976" class="Symbol">}</a> <a id="5978" class="Symbol">(</a><a id="5979" href="decidability.html#5979" class="Bound">A</a> <a id="5981" class="Symbol">:</a> <a id="5983" href="decidability.html#5968" class="Bound">X</a> <a id="5985" class="Symbol">→</a> <a id="5987" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5991" class="Symbol">)</a>
                                     <a id="6030" class="Symbol">→</a> <a id="6032" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6055" href="decidability.html#5979" class="Bound">A</a>
                                     <a id="6094" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6096" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6098" href="decidability.html#6098" class="Bound">α</a> <a id="6100" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6102" class="Symbol">(</a><a id="6103" href="decidability.html#5968" class="Bound">X</a> <a id="6105" class="Symbol">→</a> <a id="6107" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a><a id="6111" class="Symbol">)</a> <a id="6113" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6115" class="Symbol">((</a><a id="6117" href="decidability.html#6117" class="Bound">x</a> <a id="6119" class="Symbol">:</a> <a id="6121" href="decidability.html#5968" class="Bound">X</a><a id="6122" class="Symbol">)</a> <a id="6124" class="Symbol">→</a> <a id="6126" href="decidability.html#5979" class="Bound">A</a> <a id="6128" href="decidability.html#6117" class="Bound">x</a> <a id="6130" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6132" href="decidability.html#6098" class="Bound">α</a> <a id="6134" href="decidability.html#6117" class="Bound">x</a> <a id="6136" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6138" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6142" class="Symbol">)</a>
<a id="6144" href="decidability.html#5928" data-type="(A : X → Type) →
is-decidable-predicate A ⇔
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">predicate-decidability-with-booleans</a> <a id="6181" class="Symbol">{</a><a id="6182" href="decidability.html#6182" class="Bound">X</a><a id="6183" class="Symbol">}</a> <a id="6185" href="decidability.html#6185" class="Bound">A</a> <a id="6187" class="Symbol">=</a> <a id="6189" href="decidability.html#6204" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6191" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6193" href="decidability.html#6849" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a>
 <a id="6196" class="Keyword">where</a>
  <a id="6204" href="decidability.html#6204" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6206" class="Symbol">:</a> <a id="6208" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6231" href="decidability.html#6185" class="Bound">A</a> <a id="6233" class="Symbol">→</a> <a id="6235" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6237" href="decidability.html#6237" class="Bound">α</a> <a id="6239" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6241" class="Symbol">(</a><a id="6242" href="decidability.html#6182" class="Bound">X</a> <a id="6244" class="Symbol">→</a> <a id="6246" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a><a id="6250" class="Symbol">)</a> <a id="6252" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6254" class="Symbol">((</a><a id="6256" href="decidability.html#6256" class="Bound">x</a> <a id="6258" class="Symbol">:</a> <a id="6260" href="decidability.html#6182" class="Bound">X</a><a id="6261" class="Symbol">)</a> <a id="6263" class="Symbol">→</a> <a id="6265" href="decidability.html#6185" class="Bound">A</a> <a id="6267" href="decidability.html#6256" class="Bound">x</a> <a id="6269" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6271" href="decidability.html#6237" class="Bound">α</a> <a id="6273" href="decidability.html#6256" class="Bound">x</a> <a id="6275" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6277" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6281" class="Symbol">)</a>
  <a id="6285" href="decidability.html#6204" data-type="(A : X → Type) →
is-decidable-predicate A →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true)" class="Function">f</a> <a id="6287" href="decidability.html#6287" class="Bound">d</a> <a id="6289" class="Symbol">=</a> <a id="6291" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6293" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6295" href="decidability.html#6482" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a>
   <a id="6300" class="Keyword">where</a>
    <a id="6310" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6312" class="Symbol">:</a> <a id="6314" href="decidability.html#6182" class="Bound">X</a> <a id="6316" class="Symbol">→</a> <a id="6318" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a>
    <a id="6327" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6329" href="decidability.html#6329" class="Bound">x</a> <a id="6331" class="Symbol">=</a> <a id="6333" href="sums.html#2491" data-type="Σ B → A" class="Field">fst</a> <a id="6337" class="Symbol">(</a><a id="6338" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6353" href="decidability.html#6379" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6355" class="Symbol">(</a><a id="6356" href="decidability.html#6287" class="Bound">d</a> <a id="6358" href="decidability.html#6329" class="Bound">x</a><a id="6359" class="Symbol">))</a>
     <a id="6367" class="Keyword">where</a>
      <a id="6379" href="decidability.html#6379" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6381" class="Symbol">:</a> <a id="6383" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="6396" class="Symbol">(</a><a id="6397" href="decidability.html#6185" class="Bound">A</a> <a id="6399" href="decidability.html#6329" class="Bound">x</a><a id="6400" class="Symbol">)</a> <a id="6402" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6404" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6406" href="decidability.html#6406" class="Bound">b</a> <a id="6408" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6410" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="6415" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6417" class="Symbol">(</a><a id="6418" href="decidability.html#6185" class="Bound">A</a> <a id="6420" href="decidability.html#6329" class="Bound">x</a> <a id="6422" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6424" href="decidability.html#6406" class="Bound">b</a> <a id="6426" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6428" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6432" class="Symbol">)</a>
      <a id="6440" href="decidability.html#6379" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) ⇔ Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6442" class="Symbol">=</a> <a id="6444" href="decidability.html#3396" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6471" class="Symbol">(</a><a id="6472" href="decidability.html#6185" class="Bound">A</a> <a id="6474" href="decidability.html#6329" class="Bound">x</a><a id="6475" class="Symbol">)</a>

    <a id="6482" href="decidability.html#6482" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6484" class="Symbol">:</a> <a id="6486" class="Symbol">(</a><a id="6487" href="decidability.html#6487" class="Bound">x</a> <a id="6489" class="Symbol">:</a> <a id="6491" href="decidability.html#6182" class="Bound">X</a><a id="6492" class="Symbol">)</a> <a id="6494" class="Symbol">→</a> <a id="6496" href="decidability.html#6185" class="Bound">A</a> <a id="6498" href="decidability.html#6487" class="Bound">x</a> <a id="6500" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6502" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6504" href="decidability.html#6487" class="Bound">x</a> <a id="6506" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6508" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>
    <a id="6517" href="decidability.html#6482" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x ⇔ α A d x ≡ true" class="Function">β</a> <a id="6519" href="decidability.html#6519" class="Bound">x</a> <a id="6521" class="Symbol">=</a> <a id="6523" href="decidability.html#6729" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6525" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6527" href="decidability.html#6791" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a>
     <a id="6534" class="Keyword">where</a>
      <a id="6546" href="decidability.html#6546" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6548" class="Symbol">:</a> <a id="6550" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="6563" class="Symbol">(</a><a id="6564" href="decidability.html#6185" class="Bound">A</a> <a id="6566" href="decidability.html#6519" class="Bound">x</a><a id="6567" class="Symbol">)</a> <a id="6569" class="Symbol">→</a> <a id="6571" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6573" href="decidability.html#6573" class="Bound">b</a> <a id="6575" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6577" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="6582" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6584" class="Symbol">(</a><a id="6585" href="decidability.html#6185" class="Bound">A</a> <a id="6587" href="decidability.html#6519" class="Bound">x</a> <a id="6589" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6591" href="decidability.html#6573" class="Bound">b</a> <a id="6593" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6595" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6599" class="Symbol">)</a>
      <a id="6607" href="decidability.html#6546" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6609" class="Symbol">=</a> <a id="6611" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6626" class="Symbol">(</a><a id="6627" href="decidability.html#3396" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="6654" class="Symbol">(</a><a id="6655" href="decidability.html#6185" class="Bound">A</a> <a id="6657" href="decidability.html#6519" class="Bound">x</a><a id="6658" class="Symbol">))</a>

      <a id="6668" href="decidability.html#6668" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6671" class="Symbol">:</a> <a id="6673" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6675" href="decidability.html#6675" class="Bound">b</a> <a id="6677" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6679" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="6684" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6686" class="Symbol">(</a><a id="6687" href="decidability.html#6185" class="Bound">A</a> <a id="6689" href="decidability.html#6519" class="Bound">x</a> <a id="6691" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6693" href="decidability.html#6675" class="Bound">b</a> <a id="6695" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6697" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6701" class="Symbol">)</a>
      <a id="6709" href="decidability.html#6668" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="6712" class="Symbol">=</a> <a id="6714" href="decidability.html#6546" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
is-decidable (A x) → Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">I</a> <a id="6716" class="Symbol">(</a><a id="6717" href="decidability.html#6287" class="Bound">d</a> <a id="6719" href="decidability.html#6519" class="Bound">x</a><a id="6720" class="Symbol">)</a>

      <a id="6729" href="decidability.html#6729" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6731" class="Symbol">:</a> <a id="6733" href="decidability.html#6185" class="Bound">A</a> <a id="6735" href="decidability.html#6519" class="Bound">x</a> <a id="6737" class="Symbol">→</a> <a id="6739" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6741" href="decidability.html#6519" class="Bound">x</a> <a id="6743" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6745" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>
      <a id="6756" href="decidability.html#6729" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
A x → α A d x ≡ true" class="Function">ϕ</a> <a id="6758" class="Symbol">=</a> <a id="6760" href="binary-products.html#1517" data-type="A ⇔ B → A → B" class="Function">lr-implication</a> <a id="6775" class="Symbol">(</a><a id="6776" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6780" href="decidability.html#6668" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6782" class="Symbol">)</a>

      <a id="6791" href="decidability.html#6791" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6793" class="Symbol">:</a> <a id="6795" href="decidability.html#6310" data-type="(A : X → Type) (d : is-decidable-predicate A) → X → Bool" class="Function">α</a> <a id="6797" href="decidability.html#6519" class="Bound">x</a> <a id="6799" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6801" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a> <a id="6806" class="Symbol">→</a> <a id="6808" href="decidability.html#6185" class="Bound">A</a> <a id="6810" href="decidability.html#6519" class="Bound">x</a>
      <a id="6818" href="decidability.html#6791" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
α A d x ≡ true → A x" class="Function">γ</a> <a id="6820" class="Symbol">=</a> <a id="6822" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="6837" class="Symbol">(</a><a id="6838" href="sums.html#2501" data-type="(r : Σ B) → B (fst r)" class="Field">snd</a> <a id="6842" href="decidability.html#6668" data-type="(A : X → Type) (d : is-decidable-predicate A) (x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a><a id="6844" class="Symbol">)</a>

  <a id="6849" href="decidability.html#6849" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6851" class="Symbol">:</a> <a id="6853" class="Symbol">(</a><a id="6854" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="6856" href="decidability.html#6856" class="Bound">α</a> <a id="6858" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="6860" class="Symbol">(</a><a id="6861" href="decidability.html#6182" class="Bound">X</a> <a id="6863" class="Symbol">→</a> <a id="6865" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a><a id="6869" class="Symbol">)</a> <a id="6871" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="6873" class="Symbol">((</a><a id="6875" href="decidability.html#6875" class="Bound">x</a> <a id="6877" class="Symbol">:</a> <a id="6879" href="decidability.html#6182" class="Bound">X</a><a id="6880" class="Symbol">)</a> <a id="6882" class="Symbol">→</a> <a id="6884" href="decidability.html#6185" class="Bound">A</a> <a id="6886" href="decidability.html#6875" class="Bound">x</a> <a id="6888" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="6890" href="decidability.html#6856" class="Bound">α</a> <a id="6892" href="decidability.html#6875" class="Bound">x</a> <a id="6894" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6896" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="6900" class="Symbol">))</a> <a id="6903" class="Symbol">→</a> <a id="6905" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6928" href="decidability.html#6185" class="Bound">A</a>
  <a id="6932" href="decidability.html#6849" data-type="(A : X → Type) →
Sigma (X → Bool) (λ α → (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">g</a> <a id="6934" class="Symbol">(</a><a id="6935" href="decidability.html#6935" class="Bound">α</a> <a id="6937" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="6939" href="decidability.html#6939" class="Bound">ϕ</a><a id="6940" class="Symbol">)</a> <a id="6942" class="Symbol">=</a> <a id="6944" href="decidability.html#6959" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a>
   <a id="6949" class="Keyword">where</a>
    <a id="6959" href="decidability.html#6959" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="6961" class="Symbol">:</a> <a id="6963" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="6986" href="decidability.html#6185" class="Bound">A</a>
    <a id="6992" href="decidability.html#6959" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true) →
is-decidable-predicate A" class="Function">d</a> <a id="6994" href="decidability.html#6994" class="Bound">x</a> <a id="6996" class="Symbol">=</a> <a id="6998" href="decidability.html#7208" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a>
     <a id="7007" class="Keyword">where</a>
      <a id="7019" href="decidability.html#7019" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7021" class="Symbol">:</a> <a id="7023" class="Symbol">(</a><a id="7024" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7026" href="decidability.html#7026" class="Bound">b</a> <a id="7028" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7030" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="7035" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7037" class="Symbol">(</a><a id="7038" href="decidability.html#6185" class="Bound">A</a> <a id="7040" href="decidability.html#6994" class="Bound">x</a> <a id="7042" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7044" href="decidability.html#7026" class="Bound">b</a> <a id="7046" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7048" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="7052" class="Symbol">))</a> <a id="7055" class="Symbol">→</a> <a id="7057" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="7070" class="Symbol">(</a><a id="7071" href="decidability.html#6185" class="Bound">A</a> <a id="7073" href="decidability.html#6994" class="Bound">x</a><a id="7074" class="Symbol">)</a>
      <a id="7082" href="decidability.html#7019" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7084" class="Symbol">=</a> <a id="7086" href="binary-products.html#1589" data-type="A ⇔ B → B → A" class="Function">rl-implication</a> <a id="7101" class="Symbol">(</a><a id="7102" href="decidability.html#3396" data-type="(A : Type) → is-decidable A ⇔ Sigma Bool (λ b → A ⇔ b ≡ true)" class="Function">decidability-with-booleans</a> <a id="7129" class="Symbol">(</a><a id="7130" href="decidability.html#6185" class="Bound">A</a> <a id="7132" href="decidability.html#6994" class="Bound">x</a><a id="7133" class="Symbol">))</a>

      <a id="7143" href="decidability.html#7143" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7146" class="Symbol">:</a> <a id="7148" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="7150" href="decidability.html#7150" class="Bound">b</a> <a id="7152" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="7154" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a> <a id="7159" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="7161" class="Symbol">(</a><a id="7162" href="decidability.html#6185" class="Bound">A</a> <a id="7164" href="decidability.html#6994" class="Bound">x</a> <a id="7166" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="7168" href="decidability.html#7150" class="Bound">b</a> <a id="7170" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7172" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="7176" class="Symbol">)</a>
      <a id="7184" href="decidability.html#7143" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a> <a id="7187" class="Symbol">=</a> <a id="7189" class="Symbol">(</a><a id="7190" href="decidability.html#6935" class="Bound">α</a> <a id="7192" href="decidability.html#6994" class="Bound">x</a> <a id="7194" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="7196" href="decidability.html#6939" class="Bound">ϕ</a> <a id="7198" href="decidability.html#6994" class="Bound">x</a><a id="7199" class="Symbol">)</a>

      <a id="7208" href="decidability.html#7208" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7212" class="Symbol">:</a> <a id="7214" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="7227" class="Symbol">(</a><a id="7228" href="decidability.html#6185" class="Bound">A</a> <a id="7230" href="decidability.html#6994" class="Bound">x</a><a id="7231" class="Symbol">)</a>
      <a id="7239" href="decidability.html#7208" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
is-decidable (A x)" class="Function">III</a> <a id="7243" class="Symbol">=</a> <a id="7245" href="decidability.html#7019" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true) → is-decidable (A x)" class="Function">I</a> <a id="7247" href="decidability.html#7143" data-type="(A : X → Type) (α : X → Bool) (ϕ : (x : X) → A x ⇔ α x ≡ true)
(x : X) →
Sigma Bool (λ b → A x ⇔ b ≡ true)" class="Function">II</a>
</pre>
<p>Although boolean-valued predicates are fine, we prefer to use
type-valued predicates for the sake of uniformity, because we can always
define type valued predicates, but only on special circumstances can we
define boolean-valued predicates. It is better to define all predicates
in the same way, and then write Agda code for predicates that happen to
be decidable.</p>
<h2 id="preservation-of-decidability">Preservation of decidability</h2>
If <code>A</code> and <code>B</code> are logically equivalent, then
<code>A</code> is decidable if and only if <code>B</code> is decidable.
We first prove one direction.
<pre class="Agda"><a id="map-decidable"></a><a id="7788" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7802" class="Symbol">:</a> <a id="7804" class="Symbol">{</a><a id="7805" href="decidability.html#7805" class="Bound">A</a> <a id="7807" href="decidability.html#7807" class="Bound">B</a> <a id="7809" class="Symbol">:</a> <a id="7811" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7815" class="Symbol">}</a> <a id="7817" class="Symbol">→</a> <a id="7819" class="Symbol">(</a><a id="7820" href="decidability.html#7805" class="Bound">A</a> <a id="7822" class="Symbol">→</a> <a id="7824" href="decidability.html#7807" class="Bound">B</a><a id="7825" class="Symbol">)</a> <a id="7827" class="Symbol">→</a> <a id="7829" class="Symbol">(</a><a id="7830" href="decidability.html#7807" class="Bound">B</a> <a id="7832" class="Symbol">→</a> <a id="7834" href="decidability.html#7805" class="Bound">A</a><a id="7835" class="Symbol">)</a> <a id="7837" class="Symbol">→</a> <a id="7839" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="7852" href="decidability.html#7805" class="Bound">A</a> <a id="7854" class="Symbol">→</a> <a id="7856" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="7869" href="decidability.html#7807" class="Bound">B</a>
<a id="7871" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7885" href="decidability.html#7885" class="Bound">f</a> <a id="7887" href="decidability.html#7887" class="Bound">g</a> <a id="7889" class="Symbol">(</a><a id="7890" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7894" href="decidability.html#7894" class="Bound">x</a><a id="7895" class="Symbol">)</a> <a id="7897" class="Symbol">=</a> <a id="7899" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="7903" class="Symbol">(</a><a id="7904" href="decidability.html#7885" class="Bound">f</a> <a id="7906" href="decidability.html#7894" class="Bound">x</a><a id="7907" class="Symbol">)</a>
<a id="7909" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="7923" href="decidability.html#7923" class="Bound">f</a> <a id="7925" href="decidability.html#7925" class="Bound">g</a> <a id="7927" class="Symbol">(</a><a id="7928" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7932" href="decidability.html#7932" class="Bound">h</a><a id="7933" class="Symbol">)</a> <a id="7935" class="Symbol">=</a> <a id="7937" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="7941" class="Symbol">(λ</a> <a id="7944" href="decidability.html#7944" class="Bound">y</a> <a id="7946" class="Symbol">→</a> <a id="7948" href="decidability.html#7932" class="Bound">h</a> <a id="7950" class="Symbol">(</a><a id="7951" href="decidability.html#7925" class="Bound">g</a> <a id="7953" href="decidability.html#7944" class="Bound">y</a><a id="7954" class="Symbol">))</a>

<a id="map-decidable-corollary"></a><a id="7958" href="decidability.html#7958" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="7982" class="Symbol">:</a> <a id="7984" class="Symbol">{</a><a id="7985" href="decidability.html#7985" class="Bound">A</a> <a id="7987" href="decidability.html#7987" class="Bound">B</a> <a id="7989" class="Symbol">:</a> <a id="7991" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7995" class="Symbol">}</a> <a id="7997" class="Symbol">→</a> <a id="7999" class="Symbol">(</a><a id="8000" href="decidability.html#7985" class="Bound">A</a> <a id="8002" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8004" href="decidability.html#7987" class="Bound">B</a><a id="8005" class="Symbol">)</a> <a id="8007" class="Symbol">→</a> <a id="8009" class="Symbol">(</a><a id="8010" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8023" href="decidability.html#7985" class="Bound">A</a> <a id="8025" href="binary-products.html#1270" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="8027" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8040" href="decidability.html#7987" class="Bound">B</a><a id="8041" class="Symbol">)</a>
<a id="8043" href="decidability.html#7958" data-type="A ⇔ B → is-decidable A ⇔ is-decidable B" class="Function">map-decidable-corollary</a> <a id="8067" class="Symbol">(</a><a id="8068" href="decidability.html#8068" class="Bound">f</a> <a id="8070" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8072" href="decidability.html#8072" class="Bound">g</a><a id="8073" class="Symbol">)</a> <a id="8075" class="Symbol">=</a> <a id="8077" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8091" href="decidability.html#8068" class="Bound">f</a> <a id="8093" href="decidability.html#8072" class="Bound">g</a> <a id="8095" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="8097" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="8111" href="decidability.html#8072" class="Bound">g</a> <a id="8113" href="decidability.html#8068" class="Bound">f</a>
</pre>
Variation:
<pre class="Agda"><a id="map-decidable&#39;"></a><a id="8138" href="decidability.html#8138" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8153" class="Symbol">:</a> <a id="8155" class="Symbol">{</a><a id="8156" href="decidability.html#8156" class="Bound">A</a> <a id="8158" href="decidability.html#8158" class="Bound">B</a> <a id="8160" class="Symbol">:</a> <a id="8162" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8166" class="Symbol">}</a> <a id="8168" class="Symbol">→</a> <a id="8170" class="Symbol">(</a><a id="8171" href="decidability.html#8156" class="Bound">A</a> <a id="8173" class="Symbol">→</a> <a id="8175" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8177" href="decidability.html#8158" class="Bound">B</a><a id="8178" class="Symbol">)</a> <a id="8180" class="Symbol">→</a> <a id="8182" class="Symbol">(</a><a id="8183" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8185" href="decidability.html#8156" class="Bound">A</a> <a id="8187" class="Symbol">→</a> <a id="8189" href="decidability.html#8158" class="Bound">B</a><a id="8190" class="Symbol">)</a> <a id="8192" class="Symbol">→</a> <a id="8194" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8207" href="decidability.html#8156" class="Bound">A</a> <a id="8209" class="Symbol">→</a> <a id="8211" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8224" href="decidability.html#8158" class="Bound">B</a>
<a id="8226" href="decidability.html#8138" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8241" href="decidability.html#8241" class="Bound">f</a> <a id="8243" href="decidability.html#8243" class="Bound">g</a> <a id="8245" class="Symbol">(</a><a id="8246" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8250" href="decidability.html#8250" class="Bound">x</a><a id="8251" class="Symbol">)</a> <a id="8253" class="Symbol">=</a> <a id="8255" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8259" class="Symbol">(</a><a id="8260" href="decidability.html#8241" class="Bound">f</a> <a id="8262" href="decidability.html#8250" class="Bound">x</a><a id="8263" class="Symbol">)</a>
<a id="8265" href="decidability.html#8138" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="8280" href="decidability.html#8280" class="Bound">f</a> <a id="8282" href="decidability.html#8282" class="Bound">g</a> <a id="8284" class="Symbol">(</a><a id="8285" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8289" href="decidability.html#8289" class="Bound">h</a><a id="8290" class="Symbol">)</a> <a id="8292" class="Symbol">=</a> <a id="8294" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8298" class="Symbol">(</a><a id="8299" href="decidability.html#8282" class="Bound">g</a> <a id="8301" href="decidability.html#8289" class="Bound">h</a><a id="8302" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="pointed-types-are-decidable"></a><a id="8317" href="decidability.html#8317" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8345" class="Symbol">:</a> <a id="8347" class="Symbol">{</a><a id="8348" href="decidability.html#8348" class="Bound">A</a> <a id="8350" class="Symbol">:</a> <a id="8352" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8356" class="Symbol">}</a> <a id="8358" class="Symbol">→</a> <a id="8360" href="decidability.html#8348" class="Bound">A</a> <a id="8362" class="Symbol">→</a> <a id="8364" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8377" href="decidability.html#8348" class="Bound">A</a>
<a id="8379" href="decidability.html#8317" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8407" class="Symbol">=</a> <a id="8409" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a>

<a id="empty-types-are-decidable"></a><a id="8414" href="decidability.html#8414" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8440" class="Symbol">:</a> <a id="8442" class="Symbol">{</a><a id="8443" href="decidability.html#8443" class="Bound">A</a> <a id="8445" class="Symbol">:</a> <a id="8447" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8451" class="Symbol">}</a> <a id="8453" class="Symbol">→</a> <a id="8455" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="8457" href="decidability.html#8443" class="Bound">A</a> <a id="8459" class="Symbol">→</a> <a id="8461" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8474" href="decidability.html#8443" class="Bound">A</a>
<a id="8476" href="decidability.html#8414" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8502" class="Symbol">=</a> <a id="8504" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a>

<a id="𝟙-is-decidable"></a><a id="8509" href="decidability.html#8509" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8524" class="Symbol">:</a> <a id="8526" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8539" href="unit-type.html#352" data-type="Type" class="Record">𝟙</a>
<a id="8541" href="decidability.html#8509" data-type="is-decidable 𝟙" class="Function">𝟙-is-decidable</a> <a id="8556" class="Symbol">=</a> <a id="8558" href="decidability.html#8317" data-type="A → is-decidable A" class="Function">pointed-types-are-decidable</a> <a id="8586" href="unit-type.html#382" data-type="𝟙" class="InductiveConstructor">⋆</a>

<a id="𝟘-is-decidable"></a><a id="8589" href="decidability.html#8589" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8604" class="Symbol">:</a> <a id="8606" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8619" href="empty-type.html#479" data-type="Set" class="Datatype">𝟘</a>
<a id="8621" href="decidability.html#8589" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a> <a id="8636" class="Symbol">=</a> <a id="8638" href="decidability.html#8414" data-type="¬ A → is-decidable A" class="Function">empty-types-are-decidable</a> <a id="8664" href="empty-type.html#3580" data-type="is-empty 𝟘" class="Function">𝟘-is-empty</a>

<a id="∔-preserves-decidability"></a><a id="8676" href="decidability.html#8676" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8701" class="Symbol">:</a> <a id="8703" class="Symbol">{</a><a id="8704" href="decidability.html#8704" class="Bound">A</a> <a id="8706" href="decidability.html#8706" class="Bound">B</a> <a id="8708" class="Symbol">:</a> <a id="8710" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="8714" class="Symbol">}</a>
                         <a id="8741" class="Symbol">→</a> <a id="8743" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8756" href="decidability.html#8704" class="Bound">A</a>
                         <a id="8783" class="Symbol">→</a> <a id="8785" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8798" href="decidability.html#8706" class="Bound">B</a>
                         <a id="8825" class="Symbol">→</a> <a id="8827" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="8840" class="Symbol">(</a><a id="8841" href="decidability.html#8704" class="Bound">A</a> <a id="8843" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="8845" href="decidability.html#8706" class="Bound">B</a><a id="8846" class="Symbol">)</a>
<a id="8848" href="decidability.html#8676" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8873" class="Symbol">(</a><a id="8874" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8878" href="decidability.html#8878" class="Bound">x</a><a id="8879" class="Symbol">)</a> <a id="8881" class="Symbol">_</a>       <a id="8889" class="Symbol">=</a> <a id="8891" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8895" class="Symbol">(</a><a id="8896" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8900" href="decidability.html#8878" class="Bound">x</a><a id="8901" class="Symbol">)</a>
<a id="8903" href="decidability.html#8676" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8928" class="Symbol">(</a><a id="8929" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8933" class="Symbol">_)</a> <a id="8936" class="Symbol">(</a><a id="8937" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8941" href="decidability.html#8941" class="Bound">y</a><a id="8942" class="Symbol">)</a> <a id="8944" class="Symbol">=</a> <a id="8946" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="8950" class="Symbol">(</a><a id="8951" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8955" href="decidability.html#8941" class="Bound">y</a><a id="8956" class="Symbol">)</a>
<a id="8958" href="decidability.html#8676" data-type="is-decidable A → is-decidable B → is-decidable (A ∔ B)" class="Function">∔-preserves-decidability</a> <a id="8983" class="Symbol">(</a><a id="8984" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8988" href="decidability.html#8988" class="Bound">h</a><a id="8989" class="Symbol">)</a> <a id="8991" class="Symbol">(</a><a id="8992" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="8996" href="decidability.html#8996" class="Bound">k</a><a id="8997" class="Symbol">)</a> <a id="8999" class="Symbol">=</a> <a id="9001" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9005" class="Symbol">(</a><a id="9006" href="binary-sums.html#3750" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="9020" href="decidability.html#8988" class="Bound">h</a> <a id="9022" href="decidability.html#8996" class="Bound">k</a><a id="9023" class="Symbol">)</a>

<a id="×-preserves-decidability"></a><a id="9026" href="decidability.html#9026" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9051" class="Symbol">:</a> <a id="9053" class="Symbol">{</a><a id="9054" href="decidability.html#9054" class="Bound">A</a> <a id="9056" href="decidability.html#9056" class="Bound">B</a> <a id="9058" class="Symbol">:</a> <a id="9060" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9064" class="Symbol">}</a>
                         <a id="9091" class="Symbol">→</a> <a id="9093" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9106" href="decidability.html#9054" class="Bound">A</a>
                         <a id="9133" class="Symbol">→</a> <a id="9135" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9148" href="decidability.html#9056" class="Bound">B</a>
                         <a id="9175" class="Symbol">→</a> <a id="9177" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9190" class="Symbol">(</a><a id="9191" href="decidability.html#9054" class="Bound">A</a> <a id="9193" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="9195" href="decidability.html#9056" class="Bound">B</a><a id="9196" class="Symbol">)</a>
<a id="9198" href="decidability.html#9026" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9223" class="Symbol">(</a><a id="9224" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9228" href="decidability.html#9228" class="Bound">x</a><a id="9229" class="Symbol">)</a> <a id="9231" class="Symbol">(</a><a id="9232" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9236" href="decidability.html#9236" class="Bound">y</a><a id="9237" class="Symbol">)</a> <a id="9239" class="Symbol">=</a> <a id="9241" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9245" class="Symbol">(</a><a id="9246" href="decidability.html#9228" class="Bound">x</a> <a id="9248" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9250" href="decidability.html#9236" class="Bound">y</a><a id="9251" class="Symbol">)</a>
<a id="9253" href="decidability.html#9026" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9278" class="Symbol">(</a><a id="9279" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9283" class="Symbol">_)</a> <a id="9286" class="Symbol">(</a><a id="9287" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9291" href="decidability.html#9291" class="Bound">k</a><a id="9292" class="Symbol">)</a> <a id="9294" class="Symbol">=</a> <a id="9296" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9300" class="Symbol">(λ</a> <a id="9303" class="Symbol">(</a><a id="9304" href="decidability.html#9304" class="Bound">x</a> <a id="9306" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9308" href="decidability.html#9308" class="Bound">y</a><a id="9309" class="Symbol">)</a> <a id="9311" class="Symbol">→</a> <a id="9313" href="decidability.html#9291" class="Bound">k</a> <a id="9315" href="decidability.html#9308" class="Bound">y</a><a id="9316" class="Symbol">)</a>
<a id="9318" href="decidability.html#9026" data-type="is-decidable A → is-decidable B → is-decidable (A × B)" class="Function">×-preserves-decidability</a> <a id="9343" class="Symbol">(</a><a id="9344" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9348" href="decidability.html#9348" class="Bound">h</a><a id="9349" class="Symbol">)</a> <a id="9351" class="Symbol">_</a>       <a id="9359" class="Symbol">=</a> <a id="9361" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9365" class="Symbol">(λ</a> <a id="9368" class="Symbol">(</a><a id="9369" href="decidability.html#9369" class="Bound">x</a> <a id="9371" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="9373" href="decidability.html#9373" class="Bound">y</a><a id="9374" class="Symbol">)</a> <a id="9376" class="Symbol">→</a> <a id="9378" href="decidability.html#9348" class="Bound">h</a> <a id="9380" href="decidability.html#9369" class="Bound">x</a><a id="9381" class="Symbol">)</a>

<a id="→-preserves-decidability"></a><a id="9384" href="decidability.html#9384" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9409" class="Symbol">:</a> <a id="9411" class="Symbol">{</a><a id="9412" href="decidability.html#9412" class="Bound">A</a> <a id="9414" href="decidability.html#9414" class="Bound">B</a> <a id="9416" class="Symbol">:</a> <a id="9418" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9422" class="Symbol">}</a>
                         <a id="9449" class="Symbol">→</a> <a id="9451" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9464" href="decidability.html#9412" class="Bound">A</a>
                         <a id="9491" class="Symbol">→</a> <a id="9493" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9506" href="decidability.html#9414" class="Bound">B</a>
                         <a id="9533" class="Symbol">→</a> <a id="9535" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9548" class="Symbol">(</a><a id="9549" href="decidability.html#9412" class="Bound">A</a> <a id="9551" class="Symbol">→</a> <a id="9553" href="decidability.html#9414" class="Bound">B</a><a id="9554" class="Symbol">)</a>
<a id="9556" href="decidability.html#9384" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9581" class="Symbol">_</a>       <a id="9589" class="Symbol">(</a><a id="9590" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9594" href="decidability.html#9594" class="Bound">y</a><a id="9595" class="Symbol">)</a> <a id="9597" class="Symbol">=</a> <a id="9599" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9603" class="Symbol">(λ</a> <a id="9606" href="decidability.html#9606" class="Bound">_</a> <a id="9608" class="Symbol">→</a> <a id="9610" href="decidability.html#9594" class="Bound">y</a><a id="9611" class="Symbol">)</a>
<a id="9613" href="decidability.html#9384" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9638" class="Symbol">(</a><a id="9639" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9643" href="decidability.html#9643" class="Bound">x</a><a id="9644" class="Symbol">)</a> <a id="9646" class="Symbol">(</a><a id="9647" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9651" href="decidability.html#9651" class="Bound">k</a><a id="9652" class="Symbol">)</a> <a id="9654" class="Symbol">=</a> <a id="9656" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9660" class="Symbol">(λ</a> <a id="9663" href="decidability.html#9663" class="Bound">f</a> <a id="9665" class="Symbol">→</a> <a id="9667" href="decidability.html#9651" class="Bound">k</a> <a id="9669" class="Symbol">(</a><a id="9670" href="decidability.html#9663" class="Bound">f</a> <a id="9672" href="decidability.html#9643" class="Bound">x</a><a id="9673" class="Symbol">))</a>
<a id="9676" href="decidability.html#9384" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9701" class="Symbol">(</a><a id="9702" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9706" href="decidability.html#9706" class="Bound">h</a><a id="9707" class="Symbol">)</a> <a id="9709" class="Symbol">(</a><a id="9710" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="9714" href="decidability.html#9714" class="Bound">k</a><a id="9715" class="Symbol">)</a> <a id="9717" class="Symbol">=</a> <a id="9719" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="9723" class="Symbol">(λ</a> <a id="9726" href="decidability.html#9726" class="Bound">x</a> <a id="9728" class="Symbol">→</a> <a id="9730" href="empty-type.html#1725" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="9737" class="Symbol">(</a><a id="9738" href="decidability.html#9706" class="Bound">h</a> <a id="9740" href="decidability.html#9726" class="Bound">x</a><a id="9741" class="Symbol">))</a>

<a id="¬-preserves-decidability"></a><a id="9745" href="decidability.html#9745" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9770" class="Symbol">:</a> <a id="9772" class="Symbol">{</a><a id="9773" href="decidability.html#9773" class="Bound">A</a> <a id="9775" class="Symbol">:</a> <a id="9777" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="9781" class="Symbol">}</a>
                         <a id="9808" class="Symbol">→</a> <a id="9810" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9823" href="decidability.html#9773" class="Bound">A</a>
                         <a id="9850" class="Symbol">→</a> <a id="9852" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="9865" class="Symbol">(</a><a id="9866" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="9868" href="decidability.html#9773" class="Bound">A</a><a id="9869" class="Symbol">)</a>
<a id="9871" href="decidability.html#9745" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="9896" href="decidability.html#9896" class="Bound">d</a> <a id="9898" class="Symbol">=</a> <a id="9900" href="decidability.html#9384" data-type="is-decidable A → is-decidable B → is-decidable (A → B)" class="Function">→-preserves-decidability</a> <a id="9925" href="decidability.html#9896" class="Bound">d</a> <a id="9927" href="decidability.html#8589" data-type="is-decidable 𝟘" class="Function">𝟘-is-decidable</a>
</pre>
<h2 id="exhaustively-searchable-types">Exhaustively searchable
types</h2>
We will explain in a future lecture why we need to use
<code>Type₁</code> rather than <code>Type</code> in the following
definition. For the moment we just mention that because the definition
mentions <code>Type</code>, there would be a circularity if the type of
the definition where again <code>Type</code>. Such circular definitions
are not allowed because if they were then we would be able to prove that
<code>0=1</code>. We have that <code>Type : Type₁</code> (the type of
<code>Type</code> is <code>Type₁</code>) but we can’t have
<code>Type : Type</code>.
<pre class="Agda"><a id="is-exhaustively-searchable"></a><a id="10454" href="decidability.html#10454" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10481" class="Symbol">:</a> <a id="10483" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="10488" class="Symbol">→</a> <a id="10490" href="general-notation.html#683" data-type="Set₂" class="Function">Type₁</a>
<a id="10496" href="decidability.html#10454" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="10523" href="decidability.html#10523" class="Bound">X</a> <a id="10525" class="Symbol">=</a> <a id="10527" class="Symbol">(</a><a id="10528" href="decidability.html#10528" class="Bound">A</a> <a id="10530" class="Symbol">:</a> <a id="10532" href="decidability.html#10523" class="Bound">X</a> <a id="10534" class="Symbol">→</a> <a id="10536" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="10540" class="Symbol">)</a>
                             <a id="10571" class="Symbol">→</a> <a id="10573" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="10596" href="decidability.html#10528" class="Bound">A</a>
                             <a id="10627" class="Symbol">→</a> <a id="10629" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="10642" class="Symbol">(</a><a id="10643" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="10645" href="decidability.html#10645" class="Bound">x</a> <a id="10647" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="10649" href="decidability.html#10523" class="Bound">X</a> <a id="10651" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="10653" href="decidability.html#10528" class="Bound">A</a> <a id="10655" href="decidability.html#10645" class="Bound">x</a><a id="10656" class="Symbol">)</a>
</pre>
<p><strong>Exercise</strong>. Show, in Agda, that the types
<code>𝟘</code>, <code>𝟙</code> , <code>Bool</code> and
<code>Fin n</code>, for any <code>n : ℕ</code>, are exhaustively
searchable. The idea is that we check whether or not <code>A x</code>
holds for each <code>x : A</code>, and if we find at least one, we
conclude that <code>Σ x ꞉ X , A x</code>, and otherwise we conclude that
<code>¬ (Σ x ꞉ X , A x)</code>. This is possible because these types are
finite.</p>
<p><strong>Exercise</strong>. Think why there can’t be any program of
type <code>is-exhaustively-searchable ℕ</code>, by reduction to the
Halting Problem. No Agda code is asked in this question. In fact, the
question is asking you to think why such Agda code can’t exist. This is
very different from proving, in Agda, that
<code>¬ is-exhaustively-searchable ℕ</code>. Interestingly, this is also
not provable in Agda, but explaining why this is the case is beyond the
scope of this module. In any case, this is an example of a statement
<code>A</code> such that neither <code>A</code> nor <code>¬ A</code> are
provable in Agda. Such statements are called <em>independent</em>. It
must be remarked that the reason why there isn’t an Agda program of type
<code>is-exhaustively-searchable ℕ</code> is <em>not</em> merely that
<code>ℕ</code> is infinite, because there are, perhaps surprisingly,
infinite types <code>A</code> such that a program of type
<code>is-exhastively-searchable A</code> can be coded in Agda. One
really does an argument such as reduction to the Halting Problem to show
that there is no program that can exaustively search the set
<code>ℕ</code> of natural numbers.</p>
<pre class="Agda"><a id="Π-exhaustibility"></a><a id="12075" href="decidability.html#12075" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12092" class="Symbol">:</a> <a id="12094" class="Symbol">(</a><a id="12095" href="decidability.html#12095" class="Bound">X</a> <a id="12097" class="Symbol">:</a> <a id="12099" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12103" class="Symbol">)</a>
                 <a id="12122" class="Symbol">→</a> <a id="12124" href="decidability.html#10454" data-type="Type → Type₁" class="Function">is-exhaustively-searchable</a> <a id="12151" href="decidability.html#12095" class="Bound">X</a>
                 <a id="12170" class="Symbol">→</a> <a id="12172" class="Symbol">(</a><a id="12173" href="decidability.html#12173" class="Bound">A</a> <a id="12175" class="Symbol">:</a> <a id="12177" href="decidability.html#12095" class="Bound">X</a> <a id="12179" class="Symbol">→</a> <a id="12181" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="12185" class="Symbol">)</a>
                 <a id="12204" class="Symbol">→</a> <a id="12206" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12229" href="decidability.html#12173" class="Bound">A</a>
                 <a id="12248" class="Symbol">→</a> <a id="12250" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="12263" class="Symbol">(</a><a id="12264" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12266" href="decidability.html#12266" class="Bound">x</a> <a id="12268" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12270" href="decidability.html#12095" class="Bound">X</a> <a id="12272" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12274" href="decidability.html#12173" class="Bound">A</a> <a id="12276" href="decidability.html#12266" class="Bound">x</a><a id="12277" class="Symbol">)</a>
<a id="12279" href="decidability.html#12075" data-type="(X : Type) →
is-exhaustively-searchable X →
(A : X → Type) → is-decidable-predicate A → is-decidable (Pi X A)" class="Function">Π-exhaustibility</a> <a id="12296" href="decidability.html#12296" class="Bound">X</a> <a id="12298" href="decidability.html#12298" class="Bound">s</a> <a id="12300" href="decidability.html#12300" class="Bound">A</a> <a id="12302" href="decidability.html#12302" class="Bound">d</a> <a id="12304" class="Symbol">=</a> <a id="12306" href="decidability.html#12790" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a>
 <a id="12310" class="Keyword">where</a>
  <a id="12318" href="decidability.html#12318" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12320" class="Symbol">:</a> <a id="12322" href="decidability.html#5290" data-type="(X → Type) → Type" class="Function">is-decidable-predicate</a> <a id="12345" class="Symbol">(λ</a> <a id="12348" href="decidability.html#12348" class="Bound">x</a> <a id="12350" class="Symbol">→</a> <a id="12352" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12354" class="Symbol">(</a><a id="12355" href="decidability.html#12300" class="Bound">A</a> <a id="12357" href="decidability.html#12348" class="Bound">x</a><a id="12358" class="Symbol">))</a>
  <a id="12363" href="decidability.html#12318" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a> <a id="12365" href="decidability.html#12365" class="Bound">x</a> <a id="12367" class="Symbol">=</a> <a id="12369" href="decidability.html#9745" data-type="is-decidable A → is-decidable (¬ A)" class="Function">¬-preserves-decidability</a> <a id="12394" class="Symbol">(</a><a id="12395" href="decidability.html#12302" class="Bound">d</a> <a id="12397" href="decidability.html#12365" class="Bound">x</a><a id="12398" class="Symbol">)</a>

  <a id="12403" href="decidability.html#12403" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12406" class="Symbol">:</a> <a id="12408" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="12421" class="Symbol">(</a><a id="12422" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12424" href="decidability.html#12424" class="Bound">x</a> <a id="12426" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12428" href="decidability.html#12296" class="Bound">X</a> <a id="12430" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12432" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12434" class="Symbol">(</a><a id="12435" href="decidability.html#12300" class="Bound">A</a> <a id="12437" href="decidability.html#12424" class="Bound">x</a><a id="12438" class="Symbol">))</a>
  <a id="12443" href="decidability.html#12403" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a> <a id="12446" class="Symbol">=</a> <a id="12448" href="decidability.html#12298" class="Bound">s</a> <a id="12450" class="Symbol">(λ</a> <a id="12453" href="decidability.html#12453" class="Bound">x</a> <a id="12455" class="Symbol">→</a> <a id="12457" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12459" class="Symbol">(</a><a id="12460" href="decidability.html#12300" class="Bound">A</a> <a id="12462" href="decidability.html#12453" class="Bound">x</a><a id="12463" class="Symbol">))</a> <a id="12466" href="decidability.html#12318" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable-predicate (λ x → ¬ A x)" class="Function">I</a>

  <a id="12471" href="decidability.html#12471" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12475" class="Symbol">:</a> <a id="12477" class="Symbol">(</a><a id="12478" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12480" href="decidability.html#12480" class="Bound">x</a> <a id="12482" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12484" href="decidability.html#12296" class="Bound">X</a> <a id="12486" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12488" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12490" class="Symbol">(</a><a id="12491" href="decidability.html#12300" class="Bound">A</a> <a id="12493" href="decidability.html#12480" class="Bound">x</a><a id="12494" class="Symbol">))</a> <a id="12497" class="Symbol">→</a> <a id="12499" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12501" class="Symbol">(</a><a id="12502" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12504" href="decidability.html#12504" class="Bound">x</a> <a id="12506" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12508" href="decidability.html#12296" class="Bound">X</a> <a id="12510" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12512" href="decidability.html#12300" class="Bound">A</a> <a id="12514" href="decidability.html#12504" class="Bound">x</a><a id="12515" class="Symbol">)</a>
  <a id="12519" href="decidability.html#12471" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12523" class="Symbol">(</a><a id="12524" href="decidability.html#12524" class="Bound">x</a> <a id="12526" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12528" href="decidability.html#12528" class="Bound">f</a><a id="12529" class="Symbol">)</a> <a id="12531" href="decidability.html#12531" class="Bound">g</a> <a id="12533" class="Symbol">=</a> <a id="12535" href="decidability.html#12528" class="Bound">f</a> <a id="12537" class="Symbol">(</a><a id="12538" href="decidability.html#12531" class="Bound">g</a> <a id="12540" href="decidability.html#12524" class="Bound">x</a><a id="12541" class="Symbol">)</a>

  <a id="12546" href="decidability.html#12546" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12549" class="Symbol">:</a> <a id="12551" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12553" class="Symbol">(</a><a id="12554" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12556" href="decidability.html#12556" class="Bound">x</a> <a id="12558" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12560" href="decidability.html#12296" class="Bound">X</a> <a id="12562" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12564" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12566" class="Symbol">(</a><a id="12567" href="decidability.html#12300" class="Bound">A</a> <a id="12569" href="decidability.html#12556" class="Bound">x</a><a id="12570" class="Symbol">))</a> <a id="12573" class="Symbol">→</a> <a id="12575" class="Symbol">(</a><a id="12576" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12578" href="decidability.html#12578" class="Bound">x</a> <a id="12580" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12582" href="decidability.html#12296" class="Bound">X</a> <a id="12584" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12586" href="decidability.html#12300" class="Bound">A</a> <a id="12588" href="decidability.html#12578" class="Bound">x</a><a id="12589" class="Symbol">)</a>
  <a id="12593" href="decidability.html#12546" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a> <a id="12596" href="decidability.html#12596" class="Bound">h</a> <a id="12598" href="decidability.html#12598" class="Bound">x</a> <a id="12600" class="Symbol">=</a> <a id="12602" href="decidability.html#12654" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a>
   <a id="12608" class="Keyword">where</a>
    <a id="12618" href="decidability.html#12618" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12620" class="Symbol">:</a> <a id="12622" href="negation.html#1951" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="12625" href="decidability.html#12300" class="Bound">A</a> <a id="12627" href="decidability.html#12598" class="Bound">x</a>
    <a id="12633" href="decidability.html#12618" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a> <a id="12635" href="decidability.html#12635" class="Bound">f</a> <a id="12637" class="Symbol">=</a> <a id="12639" href="decidability.html#12596" class="Bound">h</a> <a id="12641" class="Symbol">(</a><a id="12642" href="decidability.html#12598" class="Bound">x</a> <a id="12644" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="12646" href="decidability.html#12635" class="Bound">f</a><a id="12647" class="Symbol">)</a>

    <a id="12654" href="decidability.html#12654" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12657" class="Symbol">:</a> <a id="12659" href="decidability.html#12300" class="Bound">A</a> <a id="12661" href="decidability.html#12598" class="Bound">x</a>
    <a id="12667" href="decidability.html#12654" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
A x" class="Function">ii</a> <a id="12670" class="Symbol">=</a> <a id="12672" href="decidability.html#2866" data-type="is-decidable A → ¬¬ A → A" class="Function">¬¬-elim</a> <a id="12680" class="Symbol">(</a><a id="12681" href="decidability.html#12302" class="Bound">d</a> <a id="12683" href="decidability.html#12598" class="Bound">x</a><a id="12684" class="Symbol">)</a> <a id="12686" href="decidability.html#12618" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) (h : ¬ Sigma X (λ x → ¬ A x))
(x : X) →
¬¬ A x" class="Function">i</a>

  <a id="12691" href="decidability.html#12691" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12693" class="Symbol">:</a> <a id="12695" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="12708" class="Symbol">(</a><a id="12709" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="12711" href="decidability.html#12711" class="Bound">x</a> <a id="12713" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12715" href="decidability.html#12296" class="Bound">X</a> <a id="12717" href="sums.html#3564" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12719" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="12721" class="Symbol">(</a><a id="12722" href="decidability.html#12300" class="Bound">A</a> <a id="12724" href="decidability.html#12711" class="Bound">x</a><a id="12725" class="Symbol">))</a> <a id="12728" class="Symbol">→</a> <a id="12730" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="12743" class="Symbol">(</a><a id="12744" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12746" href="decidability.html#12746" class="Bound">x</a> <a id="12748" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12750" href="decidability.html#12296" class="Bound">X</a> <a id="12752" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12754" href="decidability.html#12300" class="Bound">A</a> <a id="12756" href="decidability.html#12746" class="Bound">x</a><a id="12757" class="Symbol">)</a>
  <a id="12761" href="decidability.html#12691" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12763" class="Symbol">=</a> <a id="12765" href="decidability.html#8138" data-type="(A → ¬ B) → (¬ A → B) → is-decidable A → is-decidable B" class="Function">map-decidable&#39;</a> <a id="12780" href="decidability.html#12471" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
Sigma X (λ x → ¬ A x) → ¬ Pi X A" class="Function">III</a> <a id="12784" href="decidability.html#12546" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
¬ Sigma X (λ x → ¬ A x) → Pi X A" class="Function">IV</a>

  <a id="12790" href="decidability.html#12790" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12793" class="Symbol">:</a> <a id="12795" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="12808" class="Symbol">(</a><a id="12809" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">Π</a> <a id="12811" href="decidability.html#12811" class="Bound">x</a> <a id="12813" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="12815" href="decidability.html#12296" class="Bound">X</a> <a id="12817" href="products.html#4053" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="12819" href="decidability.html#12300" class="Bound">A</a> <a id="12821" href="decidability.html#12811" class="Bound">x</a><a id="12822" class="Symbol">)</a>
  <a id="12826" href="decidability.html#12790" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Pi X A)" class="Function">VI</a> <a id="12829" class="Symbol">=</a> <a id="12831" href="decidability.html#12691" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x)) → is-decidable (Pi X A)" class="Function">V</a> <a id="12833" href="decidability.html#12403" data-type="(X : Type) (s : is-exhaustively-searchable X) (A : X → Type)
(d : is-decidable-predicate A) →
is-decidable (Sigma X (λ x → ¬ A x))" class="Function">II</a>
</pre>
<p><strong>Exercises.</strong> If two types <code>A</code> and
<code>B</code> are exhaustively searchable types, then so are the types
<code>A × B</code> and <code>A + B</code>. Moreover, if <code>X</code>
is an exhaustively searchable type and <code>A : X → Type</code> is a
family of types, and the type <code>A x</code> is exhaustively
searchable for each <code>x : X</code>, then the type
<code>Σ x ꞉ X , A x</code> is exhaustively searchable.</p>
<h2 id="decidable-equality">Decidable equality</h2>
<p>A particular case of interest regarding the above discussion is the
notion of a type having decidable equality, which can be written in Agda
as follows.</p>
<pre class="Agda"><a id="has-decidable-equality"></a><a id="13359" href="decidability.html#13359" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13382" class="Symbol">:</a> <a id="13384" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="13389" class="Symbol">→</a> <a id="13391" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="13396" href="decidability.html#13359" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13419" href="decidability.html#13419" class="Bound">X</a> <a id="13421" class="Symbol">=</a> <a id="13423" class="Symbol">(</a><a id="13424" href="decidability.html#13424" class="Bound">x</a> <a id="13426" href="decidability.html#13426" class="Bound">y</a> <a id="13428" class="Symbol">:</a> <a id="13430" href="decidability.html#13419" class="Bound">X</a><a id="13431" class="Symbol">)</a> <a id="13433" class="Symbol">→</a> <a id="13435" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="13448" class="Symbol">(</a><a id="13449" href="decidability.html#13424" class="Bound">x</a> <a id="13451" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="13453" href="decidability.html#13426" class="Bound">y</a><a id="13454" class="Symbol">)</a>
</pre>
<p><strong>Exercise.</strong> Show, in Agda, that a type <code>X</code>
has decidable equality if and only if there is a function
<code>X → X → Bool</code> that checks whether two elements of
<code>X</code> are equal or not.</p>
Some examples:
<pre class="Agda"><a id="Bool-has-decidable-equality"></a><a id="13660" href="decidability.html#13660" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13688" class="Symbol">:</a> <a id="13690" href="decidability.html#13359" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="13713" href="Bool.html#448" data-type="Set" class="Datatype">Bool</a>
<a id="13718" href="decidability.html#13660" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13746" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13752" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13758" class="Symbol">=</a> <a id="13760" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13764" class="Symbol">(</a><a id="13765" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13770" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a><a id="13774" class="Symbol">)</a>
<a id="13776" href="decidability.html#13660" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13804" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13810" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="13816" class="Symbol">=</a> <a id="13818" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13822" href="negation.html#3353" data-type="true ≢ false" class="Function">true-is-not-false</a>
<a id="13840" href="decidability.html#13660" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13868" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="13874" href="Bool.html#467" data-type="Bool" class="InductiveConstructor">true</a>  <a id="13880" class="Symbol">=</a> <a id="13882" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="13886" href="negation.html#3298" data-type="false ≢ true" class="Function">false-is-not-true</a>
<a id="13904" href="decidability.html#13660" data-type="has-decidable-equality Bool" class="Function">Bool-has-decidable-equality</a> <a id="13932" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="13938" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a> <a id="13944" class="Symbol">=</a> <a id="13946" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="13950" class="Symbol">(</a><a id="13951" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="13956" href="Bool.html#472" data-type="Bool" class="InductiveConstructor">false</a><a id="13961" class="Symbol">)</a>

<a id="13964" class="Keyword">open</a> <a id="13969" class="Keyword">import</a> <a id="13976" href="natural-numbers-functions.html" class="Module">natural-numbers-functions</a>

<a id="ℕ-has-decidable-equality"></a><a id="14003" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14028" class="Symbol">:</a> <a id="14030" href="decidability.html#13359" data-type="Type → Type" class="Function">has-decidable-equality</a> <a id="14053" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a>
<a id="14055" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14080" class="Number">0</a>       <a id="14088" class="Number">0</a>       <a id="14096" class="Symbol">=</a> <a id="14098" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="14102" class="Symbol">(</a><a id="14103" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14108" href="introduction.html#969" data-type="ℕ" class="InductiveConstructor">zero</a><a id="14112" class="Symbol">)</a>
<a id="14114" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14139" class="Number">0</a>       <a id="14147" class="Symbol">(</a><a id="14148" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14152" href="decidability.html#14152" class="Bound">y</a><a id="14153" class="Symbol">)</a> <a id="14155" class="Symbol">=</a> <a id="14157" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14161" href="natural-numbers-functions.html#486" data-type="0 ≢ suc x" class="Function">zero-is-not-suc</a>
<a id="14177" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14202" class="Symbol">(</a><a id="14203" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14207" href="decidability.html#14207" class="Bound">x</a><a id="14208" class="Symbol">)</a> <a id="14210" class="Number">0</a>       <a id="14218" class="Symbol">=</a> <a id="14220" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="14224" href="natural-numbers-functions.html#428" data-type="suc x ≢ 0" class="Function">suc-is-not-zero</a>
<a id="14240" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14265" class="Symbol">(</a><a id="14266" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14270" href="decidability.html#14270" class="Bound">x</a><a id="14271" class="Symbol">)</a> <a id="14273" class="Symbol">(</a><a id="14274" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14278" href="decidability.html#14278" class="Bound">y</a><a id="14279" class="Symbol">)</a> <a id="14281" class="Symbol">=</a> <a id="14283" href="decidability.html#14457" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a>
 <a id="14288" class="Keyword">where</a>
  <a id="14296" href="decidability.html#14296" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14299" class="Symbol">:</a> <a id="14301" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="14314" class="Symbol">(</a><a id="14315" href="decidability.html#14270" class="Bound">x</a> <a id="14317" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14319" href="decidability.html#14278" class="Bound">y</a><a id="14320" class="Symbol">)</a>
  <a id="14324" href="decidability.html#14296" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a> <a id="14327" class="Symbol">=</a> <a id="14329" href="decidability.html#14003" data-type="has-decidable-equality ℕ" class="Function">ℕ-has-decidable-equality</a> <a id="14354" href="decidability.html#14270" class="Bound">x</a> <a id="14356" href="decidability.html#14278" class="Bound">y</a>

  <a id="14361" href="decidability.html#14361" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14363" class="Symbol">:</a> <a id="14365" href="decidability.html#14270" class="Bound">x</a> <a id="14367" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14369" href="decidability.html#14278" class="Bound">y</a> <a id="14371" class="Symbol">→</a> <a id="14373" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14377" href="decidability.html#14270" class="Bound">x</a> <a id="14379" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14381" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14385" href="decidability.html#14278" class="Bound">y</a>
  <a id="14389" href="decidability.html#14361" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14391" class="Symbol">=</a> <a id="14393" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="14396" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a>

  <a id="14403" href="decidability.html#14403" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14406" class="Symbol">:</a> <a id="14408" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14412" href="decidability.html#14270" class="Bound">x</a> <a id="14414" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14416" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14420" href="decidability.html#14278" class="Bound">y</a> <a id="14422" class="Symbol">→</a> <a id="14424" href="decidability.html#14270" class="Bound">x</a> <a id="14426" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14428" href="decidability.html#14278" class="Bound">y</a>
  <a id="14432" href="decidability.html#14403" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14435" class="Symbol">=</a> <a id="14437" href="natural-numbers-functions.html#592" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-is-injective</a>

  <a id="14457" href="decidability.html#14457" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14461" class="Symbol">:</a> <a id="14463" href="decidability.html#2591" data-type="Type → Type" class="Function">is-decidable</a> <a id="14476" class="Symbol">(</a><a id="14477" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14481" href="decidability.html#14270" class="Bound">x</a> <a id="14483" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14485" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14489" href="decidability.html#14278" class="Bound">y</a><a id="14490" class="Symbol">)</a>
  <a id="14494" href="decidability.html#14457" data-type="(x y : ℕ) → is-decidable (suc x ≡ suc y)" class="Function">III</a> <a id="14498" class="Symbol">=</a> <a id="14500" href="decidability.html#7788" data-type="(A → B) → (B → A) → is-decidable A → is-decidable B" class="Function">map-decidable</a> <a id="14514" href="decidability.html#14361" data-type="(x y : ℕ) → x ≡ y → suc x ≡ suc y" class="Function">I</a> <a id="14516" href="decidability.html#14403" data-type="(x y : ℕ) → suc x ≡ suc y → x ≡ y" class="Function">II</a> <a id="14519" href="decidability.html#14296" data-type="(x y : ℕ) → is-decidable (x ≡ y)" class="Function">IH</a>
</pre>
<h2 id="equality-of-functions">Equality of functions</h2>
<p>As discussed above, it is not possible to decide whether or not we
have <code>f ∼ g</code> for two functions <code>f</code> and
<code>g</code>, for example of type <code>ℕ → ℕ</code>. However,
sometimes we can <em>prove</em> or <em>disprove</em> this for
<em>particular</em> functions. Here are some examples:</p>
<pre class="Agda"><a id="14807" class="Keyword">private</a>
 <a id="f"></a><a id="14816" href="decidability.html#14816" class="Function">f</a> <a id="g"></a><a id="14818" href="decidability.html#14818" class="Function">g</a> <a id="h"></a><a id="14820" href="decidability.html#14820" class="Function">h</a> <a id="14822" class="Symbol">:</a> <a id="14824" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a> <a id="14826" class="Symbol">→</a> <a id="14828" href="introduction.html#953" data-type="Set" class="Datatype">ℕ</a>

 <a id="14832" href="decidability.html#14816" class="Function">f</a> <a id="14834" href="decidability.html#14834" class="Bound">x</a> <a id="14836" class="Symbol">=</a> <a id="14838" href="decidability.html#14834" class="Bound">x</a>

 <a id="14842" href="decidability.html#14818" class="Function">g</a> <a id="14844" class="Number">0</a>       <a id="14852" class="Symbol">=</a> <a id="14854" class="Number">0</a>
 <a id="14857" href="decidability.html#14818" class="Function">g</a> <a id="14859" class="Symbol">(</a><a id="14860" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14864" href="decidability.html#14864" class="Bound">x</a><a id="14865" class="Symbol">)</a> <a id="14867" class="Symbol">=</a> <a id="14869" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14873" class="Symbol">(</a><a id="14874" href="decidability.html#14818" class="Function">g</a> <a id="14876" href="decidability.html#14864" class="Bound">x</a><a id="14877" class="Symbol">)</a>

 <a id="14881" href="decidability.html#14820" class="Function">h</a> <a id="14883" href="decidability.html#14883" class="Bound">x</a> <a id="14885" class="Symbol">=</a> <a id="14887" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14891" href="decidability.html#14883" class="Bound">x</a>

 <a id="f-equals-g"></a><a id="14895" href="decidability.html#14895" class="Function">f-equals-g</a> <a id="14906" class="Symbol">:</a> <a id="14908" href="decidability.html#14816" class="Function">f</a> <a id="14910" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="14912" href="decidability.html#14818" class="Function">g</a>
 <a id="14915" href="decidability.html#14895" class="Function">f-equals-g</a> <a id="14926" class="Number">0</a>       <a id="14934" class="Symbol">=</a> <a id="14936" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="14941" class="Symbol">(</a><a id="14942" href="decidability.html#14816" class="Function">f</a> <a id="14944" class="Number">0</a><a id="14945" class="Symbol">)</a>
 <a id="14948" href="decidability.html#14895" class="Function">f-equals-g</a> <a id="14959" class="Symbol">(</a><a id="14960" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="14964" href="decidability.html#14964" class="Bound">x</a><a id="14965" class="Symbol">)</a> <a id="14967" class="Symbol">=</a> <a id="14969" href="decidability.html#15022" class="Function">γ</a>
  <a id="14973" class="Keyword">where</a>
   <a id="14982" href="decidability.html#14982" class="Function">IH</a> <a id="14985" class="Symbol">:</a> <a id="14987" href="decidability.html#14816" class="Function">f</a> <a id="14989" href="decidability.html#14964" class="Bound">x</a> <a id="14991" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="14993" href="decidability.html#14818" class="Function">g</a> <a id="14995" href="decidability.html#14964" class="Bound">x</a>
   <a id="15000" href="decidability.html#14982" class="Function">IH</a> <a id="15003" class="Symbol">=</a> <a id="15005" href="decidability.html#14895" class="Function">f-equals-g</a> <a id="15016" href="decidability.html#14964" class="Bound">x</a>

   <a id="15022" href="decidability.html#15022" class="Function">γ</a> <a id="15024" class="Symbol">:</a> <a id="15026" href="decidability.html#14816" class="Function">f</a> <a id="15028" class="Symbol">(</a><a id="15029" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15033" href="decidability.html#14964" class="Bound">x</a><a id="15034" class="Symbol">)</a> <a id="15036" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15038" href="decidability.html#14818" class="Function">g</a> <a id="15040" class="Symbol">(</a><a id="15041" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15045" href="decidability.html#14964" class="Bound">x</a><a id="15046" class="Symbol">)</a>
   <a id="15051" href="decidability.html#15022" class="Function">γ</a> <a id="15053" class="Symbol">=</a> <a id="15055" href="decidability.html#14816" class="Function">f</a> <a id="15057" class="Symbol">(</a><a id="15058" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15062" href="decidability.html#14964" class="Bound">x</a><a id="15063" class="Symbol">)</a> <a id="15065" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15068" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15073" class="Symbol">_</a> <a id="15075" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15084" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15088" href="decidability.html#14964" class="Bound">x</a>     <a id="15094" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15097" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15102" class="Symbol">_</a> <a id="15104" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15113" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15117" class="Symbol">(</a><a id="15118" href="decidability.html#14816" class="Function">f</a> <a id="15120" href="decidability.html#14964" class="Bound">x</a><a id="15121" class="Symbol">)</a> <a id="15123" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15126" href="identity-type.html#2263" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="15129" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15133" href="decidability.html#14982" class="Function">IH</a> <a id="15136" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15145" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15149" class="Symbol">(</a><a id="15150" href="decidability.html#14818" class="Function">g</a> <a id="15152" href="decidability.html#14964" class="Bound">x</a><a id="15153" class="Symbol">)</a> <a id="15155" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="15158" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="15163" class="Symbol">_</a> <a id="15165" href="identity-type.html#4108" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
       <a id="15174" href="decidability.html#14818" class="Function">g</a> <a id="15176" class="Symbol">(</a><a id="15177" href="introduction.html#979" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="15181" href="decidability.html#14964" class="Bound">x</a><a id="15182" class="Symbol">)</a> <a id="15184" href="identity-type.html#4194" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>

 <a id="f-not-equals-h"></a><a id="15188" href="decidability.html#15188" class="Function">f-not-equals-h</a> <a id="15203" class="Symbol">:</a> <a id="15205" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15207" class="Symbol">(</a><a id="15208" href="decidability.html#14816" class="Function">f</a> <a id="15210" href="identity-type.html#3214" data-type="((x : A) → B x) → ((x : A) → B x) → Type" class="Function Operator">∼</a> <a id="15212" href="decidability.html#14820" class="Function">h</a><a id="15213" class="Symbol">)</a>
 <a id="15216" href="decidability.html#15188" class="Function">f-not-equals-h</a> <a id="15231" href="decidability.html#15231" class="Bound">e</a> <a id="15233" class="Symbol">=</a> <a id="15235" href="decidability.html#15287" class="Function">contradiction</a> <a id="15249" href="decidability.html#15262" class="Function">d</a>
  <a id="15253" class="Keyword">where</a>
   <a id="15262" href="decidability.html#15262" class="Function">d</a> <a id="15264" class="Symbol">:</a> <a id="15266" class="Number">0</a> <a id="15268" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15270" class="Number">1</a>
   <a id="15275" href="decidability.html#15262" class="Function">d</a> <a id="15277" class="Symbol">=</a> <a id="15279" href="decidability.html#15231" class="Bound">e</a> <a id="15281" class="Number">0</a>

   <a id="15287" href="decidability.html#15287" class="Function">contradiction</a> <a id="15301" class="Symbol">:</a> <a id="15303" href="empty-type.html#1641" data-type="Type → Type" class="Function Operator">¬</a> <a id="15305" class="Symbol">(</a><a id="15306" class="Number">0</a> <a id="15308" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="15310" class="Number">1</a><a id="15311" class="Symbol">)</a>
   <a id="15316" href="decidability.html#15287" class="Function">contradiction</a> <a id="15330" class="Symbol">()</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
