<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module “Advanced Functional Programming” at
the <a
href="https://www.birmingham.ac.uk/schools/computer-science/index.aspx">School
of Computer Science</a> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="324" class="Symbol">{-#</a> <a id="328" class="Keyword">OPTIONS</a> <a id="336" class="Pragma">--without-K</a> <a id="348" class="Pragma">--safe</a> <a id="355" class="Symbol">#-}</a>

<a id="360" class="Keyword">module</a> <a id="367" href="negation.html" class="Module">negation</a> <a id="376" class="Keyword">where</a>

<a id="383" class="Keyword">open</a> <a id="388" class="Keyword">import</a> <a id="395" href="general-notation.html" class="Module">general-notation</a>
<a id="412" class="Keyword">open</a> <a id="417" class="Keyword">import</a> <a id="424" href="prelude.html" class="Module">prelude</a>
</pre>-->
<h1 id="reasoning-with-negation">Reasoning with negation</h1>
<p><a href="empty-type.html">Recall that</a> we defined the negation
<code>¬ A</code> of a type <code>A</code> to be the function type
<code>A → 𝟘</code>, and that we also wrote <code>is-empty A</code> as a
synonym of <code>¬ A</code>.</p>
<h2 id="emptiness-of-the-empty-type">Emptiness of the empty type</h2>
We have the following two proofs of “not false” or “the empty type is
empty”:
<pre class="Agda"><a id="not-false"></a><a id="757" href="negation.html#757" data-type="¬ 𝟘" class="Function">not-false</a> <a id="767" class="Symbol">:</a> <a id="769" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="771" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a>
<a id="773" href="negation.html#757" data-type="¬ 𝟘" class="Function">not-false</a> <a id="783" class="Symbol">=</a> <a id="785" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a>

<a id="not-false&#39;"></a><a id="793" href="negation.html#793" data-type="¬ 𝟘" class="Function">not-false&#39;</a> <a id="804" class="Symbol">:</a> <a id="806" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="808" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a>
<a id="810" href="negation.html#793" data-type="¬ 𝟘" class="Function">not-false&#39;</a> <a id="821" class="Symbol">=</a> <a id="823" href="products.html#1143" data-type="A → A" class="Function">id</a>
</pre>
<p>A lot of things about negation don’t depend on the fact that the
target type of the function type is <code>𝟘</code>. We will begin by
proving some things about negation by generalizing <code>𝟘</code> to any
type <code>R</code> of “results”.</p>
<h2 id="implication-from-disjunction-and-negation">Implication from
disjunction and negation</h2>
If <code>¬ A</code> or <code>B</code>, then <code>A implies B</code>:
<pre class="Agda"><a id="implication-from-disjunction-and-negation"></a><a id="1130" href="negation.html#1130" data-type="¬ A ∔ B → A → B" class="Function">implication-from-disjunction-and-negation</a> <a id="1172" class="Symbol">:</a> <a id="1174" class="Symbol">{</a><a id="1175" href="negation.html#1175" class="Bound">A</a> <a id="1177" href="negation.html#1177" class="Bound">B</a> <a id="1179" class="Symbol">:</a> <a id="1181" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="1185" class="Symbol">}</a> <a id="1187" class="Symbol">→</a> <a id="1189" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="1191" href="negation.html#1175" class="Bound">A</a> <a id="1193" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="1195" href="negation.html#1177" class="Bound">B</a> <a id="1197" class="Symbol">→</a> <a id="1199" class="Symbol">(</a><a id="1200" href="negation.html#1175" class="Bound">A</a> <a id="1202" class="Symbol">→</a> <a id="1204" href="negation.html#1177" class="Bound">B</a><a id="1205" class="Symbol">)</a>
<a id="1207" href="negation.html#1130" data-type="¬ A ∔ B → A → B" class="Function">implication-from-disjunction-and-negation</a> <a id="1249" class="Symbol">(</a><a id="1250" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="1254" href="negation.html#1254" class="Bound">f</a><a id="1255" class="Symbol">)</a> <a id="1257" href="negation.html#1257" class="Bound">a</a> <a id="1259" class="Symbol">=</a> <a id="1261" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="1268" class="Symbol">(</a><a id="1269" href="negation.html#1254" class="Bound">f</a> <a id="1271" href="negation.html#1257" class="Bound">a</a><a id="1272" class="Symbol">)</a>
<a id="1274" href="negation.html#1130" data-type="¬ A ∔ B → A → B" class="Function">implication-from-disjunction-and-negation</a> <a id="1316" class="Symbol">(</a><a id="1317" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="1321" href="negation.html#1321" class="Bound">b</a><a id="1322" class="Symbol">)</a> <a id="1324" href="negation.html#1324" class="Bound">a</a> <a id="1326" class="Symbol">=</a> <a id="1328" href="negation.html#1321" class="Bound">b</a>
</pre>
<h2 id="contrapositives">Contrapositives</h2>
If <code>A</code> implies <code>B</code>, then <code>B → R</code>
implies <code>A → R</code>:
<pre class="Agda"><a id="arrow-contravariance"></a><a id="1414" href="negation.html#1414" data-type="(A → B) → (B → R) → A → R" class="Function">arrow-contravariance</a> <a id="1435" class="Symbol">:</a> <a id="1437" class="Symbol">{</a><a id="1438" href="negation.html#1438" class="Bound">A</a> <a id="1440" href="negation.html#1440" class="Bound">B</a> <a id="1442" href="negation.html#1442" class="Bound">R</a> <a id="1444" class="Symbol">:</a> <a id="1446" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="1450" class="Symbol">}</a>
                     <a id="1473" class="Symbol">→</a> <a id="1475" class="Symbol">(</a><a id="1476" href="negation.html#1438" class="Bound">A</a> <a id="1478" class="Symbol">→</a> <a id="1480" href="negation.html#1440" class="Bound">B</a><a id="1481" class="Symbol">)</a>
                     <a id="1504" class="Symbol">→</a> <a id="1506" class="Symbol">(</a><a id="1507" href="negation.html#1440" class="Bound">B</a> <a id="1509" class="Symbol">→</a> <a id="1511" href="negation.html#1442" class="Bound">R</a><a id="1512" class="Symbol">)</a> <a id="1514" class="Symbol">→</a> <a id="1516" class="Symbol">(</a><a id="1517" href="negation.html#1438" class="Bound">A</a> <a id="1519" class="Symbol">→</a> <a id="1521" href="negation.html#1442" class="Bound">R</a><a id="1522" class="Symbol">)</a>
<a id="1524" href="negation.html#1414" data-type="(A → B) → (B → R) → A → R" class="Function">arrow-contravariance</a> <a id="1545" href="negation.html#1545" class="Bound">f</a> <a id="1547" href="negation.html#1547" class="Bound">g</a> <a id="1549" class="Symbol">=</a> <a id="1551" href="negation.html#1547" class="Bound">g</a> <a id="1553" href="products.html#3490" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="1555" href="negation.html#1545" class="Bound">f</a>
</pre>
A particular case of interest is the following. The <a
href="https://en.wikipedia.org/wiki/Contraposition">contrapositive</a>
of an implication <code>A → B</code> is the implication
<code>¬ B → ¬ A</code>:
<pre class="Agda"><a id="contrapositive"></a><a id="1742" href="negation.html#1742" data-type="(A → B) → ¬ B → ¬ A" class="Function">contrapositive</a> <a id="1757" class="Symbol">:</a> <a id="1759" class="Symbol">{</a><a id="1760" href="negation.html#1760" class="Bound">A</a> <a id="1762" href="negation.html#1762" class="Bound">B</a> <a id="1764" class="Symbol">:</a> <a id="1766" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="1770" class="Symbol">}</a> <a id="1772" class="Symbol">→</a> <a id="1774" class="Symbol">(</a><a id="1775" href="negation.html#1760" class="Bound">A</a> <a id="1777" class="Symbol">→</a> <a id="1779" href="negation.html#1762" class="Bound">B</a><a id="1780" class="Symbol">)</a> <a id="1782" class="Symbol">→</a> <a id="1784" class="Symbol">(</a><a id="1785" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="1787" href="negation.html#1762" class="Bound">B</a> <a id="1789" class="Symbol">→</a> <a id="1791" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="1793" href="negation.html#1760" class="Bound">A</a><a id="1794" class="Symbol">)</a>
<a id="1796" href="negation.html#1742" data-type="(A → B) → ¬ B → ¬ A" class="Function">contrapositive</a> <a id="1811" class="Symbol">{</a><a id="1812" href="negation.html#1812" class="Bound">A</a><a id="1813" class="Symbol">}</a> <a id="1815" class="Symbol">{</a><a id="1816" href="negation.html#1816" class="Bound">B</a><a id="1817" class="Symbol">}</a> <a id="1819" class="Symbol">=</a> <a id="1821" href="negation.html#1414" data-type="(A → B) → (B → R) → A → R" class="Function">arrow-contravariance</a> <a id="1842" class="Symbol">{</a><a id="1843" href="negation.html#1812" class="Bound">A</a><a id="1844" class="Symbol">}</a> <a id="1846" class="Symbol">{</a><a id="1847" href="negation.html#1816" class="Bound">B</a><a id="1848" class="Symbol">}</a> <a id="1850" class="Symbol">{</a><a id="1851" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a><a id="1852" class="Symbol">}</a>
</pre>
<p>This can also be read as “if we have a function A → B and B is empty,
then also A must be empty”.</p>
<h2 id="double-and-triple-negations">Double and triple negations</h2>
<p>We now introduce notation for double and triple negation, to reduce
the number of needed brackets:</p>
<pre class="Agda"><a id="¬¬_"></a><a id="2097" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬_</a> <a id="¬¬¬_"></a><a id="2101" href="negation.html#2101" data-type="Type → Type" class="Function Operator">¬¬¬_</a> <a id="2106" class="Symbol">:</a> <a id="2108" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
<a id="2120" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a>  <a id="2124" href="negation.html#2124" class="Bound">A</a> <a id="2126" class="Symbol">=</a> <a id="2128" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a><a id="2129" class="Symbol">(</a><a id="2130" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="2132" href="negation.html#2124" class="Bound">A</a><a id="2133" class="Symbol">)</a>
<a id="2135" href="negation.html#2101" data-type="Type → Type" class="Function Operator">¬¬¬</a> <a id="2139" href="negation.html#2139" class="Bound">A</a> <a id="2141" class="Symbol">=</a> <a id="2143" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a><a id="2144" class="Symbol">(</a><a id="2145" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2148" href="negation.html#2139" class="Bound">A</a><a id="2149" class="Symbol">)</a>
</pre>
We have that <code>A</code> implies <code>¬¬ A</code>. This is called
double negation introduction. More generally, we have the following:
<pre class="Agda"><a id="dni"></a><a id="2280" href="negation.html#2280" data-type="(A R : Type) → A → (A → R) → R" class="Function">dni</a> <a id="2284" class="Symbol">:</a> <a id="2286" class="Symbol">(</a><a id="2287" href="negation.html#2287" class="Bound">A</a> <a id="2289" href="negation.html#2289" class="Bound">R</a> <a id="2291" class="Symbol">:</a> <a id="2293" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="2297" class="Symbol">)</a> <a id="2299" class="Symbol">→</a> <a id="2301" href="negation.html#2287" class="Bound">A</a> <a id="2303" class="Symbol">→</a> <a id="2305" class="Symbol">((</a><a id="2307" href="negation.html#2287" class="Bound">A</a> <a id="2309" class="Symbol">→</a> <a id="2311" href="negation.html#2289" class="Bound">R</a><a id="2312" class="Symbol">)</a> <a id="2314" class="Symbol">→</a> <a id="2316" href="negation.html#2289" class="Bound">R</a><a id="2317" class="Symbol">)</a>
<a id="2319" href="negation.html#2280" data-type="(A R : Type) → A → (A → R) → R" class="Function">dni</a> <a id="2323" href="negation.html#2323" class="Bound">A</a> <a id="2325" href="negation.html#2325" class="Bound">R</a> <a id="2327" href="negation.html#2327" class="Bound">a</a> <a id="2329" href="negation.html#2329" class="Bound">u</a> <a id="2331" class="Symbol">=</a> <a id="2333" href="negation.html#2329" class="Bound">u</a> <a id="2335" href="negation.html#2327" class="Bound">a</a>

<a id="¬¬-intro"></a><a id="2338" href="negation.html#2338" data-type="A → ¬¬ A" class="Function">¬¬-intro</a> <a id="2347" class="Symbol">:</a> <a id="2349" class="Symbol">{</a><a id="2350" href="negation.html#2350" class="Bound">A</a> <a id="2352" class="Symbol">:</a> <a id="2354" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="2358" class="Symbol">}</a> <a id="2360" class="Symbol">→</a> <a id="2362" href="negation.html#2350" class="Bound">A</a> <a id="2364" class="Symbol">→</a> <a id="2366" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2369" href="negation.html#2350" class="Bound">A</a>
<a id="2371" href="negation.html#2338" data-type="A → ¬¬ A" class="Function">¬¬-intro</a> <a id="2380" class="Symbol">{</a><a id="2381" href="negation.html#2381" class="Bound">A</a><a id="2382" class="Symbol">}</a> <a id="2384" class="Symbol">=</a> <a id="2386" href="negation.html#2280" data-type="(A R : Type) → A → (A → R) → R" class="Function">dni</a> <a id="2390" href="negation.html#2381" class="Bound">A</a> <a id="2392" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a>
</pre>
We don’t always have <code>¬¬ A → A</code> in proofs-as-programs. This
has to do with <em>computability theory</em>. But sometimes we do. For
example, if we know that <code>A ∔ ¬ A</code> then <code>¬¬A → A</code>
follows: <!--
<pre class="Agda"><a id="2594" class="Keyword">private</a> <a id="2602" class="Comment">-- because it is defined elsewhere, and it is here for illustration only</a>
</pre>-->
<pre class="Agda"> <a id="¬¬-elim"></a><a id="2692" href="negation.html#2692" class="Function">¬¬-elim</a> <a id="2700" class="Symbol">:</a> <a id="2702" class="Symbol">{</a><a id="2703" href="negation.html#2703" class="Bound">A</a> <a id="2705" class="Symbol">:</a> <a id="2707" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="2711" class="Symbol">}</a> <a id="2713" class="Symbol">→</a> <a id="2715" href="negation.html#2703" class="Bound">A</a> <a id="2717" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2719" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="2721" href="negation.html#2703" class="Bound">A</a> <a id="2723" class="Symbol">→</a> <a id="2725" href="negation.html#2097" data-type="Type → Type" class="Function Operator">¬¬</a> <a id="2728" href="negation.html#2703" class="Bound">A</a> <a id="2730" class="Symbol">→</a> <a id="2732" href="negation.html#2703" class="Bound">A</a>
 <a id="2735" href="negation.html#2692" class="Function">¬¬-elim</a> <a id="2743" class="Symbol">(</a><a id="2744" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2748" href="negation.html#2748" class="Bound">x</a><a id="2749" class="Symbol">)</a> <a id="2751" href="negation.html#2751" class="Bound">f</a> <a id="2753" class="Symbol">=</a> <a id="2755" href="negation.html#2748" class="Bound">x</a>
 <a id="2758" href="negation.html#2692" class="Function">¬¬-elim</a> <a id="2766" class="Symbol">(</a><a id="2767" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2771" href="negation.html#2771" class="Bound">g</a><a id="2772" class="Symbol">)</a> <a id="2774" href="negation.html#2774" class="Bound">f</a> <a id="2776" class="Symbol">=</a> <a id="2778" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="2785" class="Symbol">(</a><a id="2786" href="negation.html#2774" class="Bound">f</a> <a id="2788" href="negation.html#2771" class="Bound">g</a><a id="2789" class="Symbol">)</a>
</pre>
For more details, see the lecture notes on <a
href="decidability.html">decidability</a>, where we discuss
<code>¬¬-elim</code> again. But three negations always imply one, and
conversely:
<pre class="Agda"><a id="three-negations-imply-one"></a><a id="2973" href="negation.html#2973" data-type="¬¬¬ A → ¬ A" class="Function">three-negations-imply-one</a> <a id="2999" class="Symbol">:</a> <a id="3001" class="Symbol">{</a><a id="3002" href="negation.html#3002" class="Bound">A</a> <a id="3004" class="Symbol">:</a> <a id="3006" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3010" class="Symbol">}</a> <a id="3012" class="Symbol">→</a> <a id="3014" href="negation.html#2101" data-type="Type → Type" class="Function Operator">¬¬¬</a> <a id="3018" href="negation.html#3002" class="Bound">A</a> <a id="3020" class="Symbol">→</a> <a id="3022" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="3024" href="negation.html#3002" class="Bound">A</a>
<a id="3026" href="negation.html#2973" data-type="¬¬¬ A → ¬ A" class="Function">three-negations-imply-one</a> <a id="3052" class="Symbol">=</a> <a id="3054" href="negation.html#1742" data-type="(A → B) → ¬ B → ¬ A" class="Function">contrapositive</a> <a id="3069" href="negation.html#2338" data-type="A → ¬¬ A" class="Function">¬¬-intro</a>

<a id="one-negation-implies-three"></a><a id="3079" href="negation.html#3079" data-type="¬ A → ¬¬¬ A" class="Function">one-negation-implies-three</a> <a id="3106" class="Symbol">:</a> <a id="3108" class="Symbol">{</a><a id="3109" href="negation.html#3109" class="Bound">A</a> <a id="3111" class="Symbol">:</a> <a id="3113" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3117" class="Symbol">}</a> <a id="3119" class="Symbol">→</a> <a id="3121" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="3123" href="negation.html#3109" class="Bound">A</a> <a id="3125" class="Symbol">→</a> <a id="3127" href="negation.html#2101" data-type="Type → Type" class="Function Operator">¬¬¬</a> <a id="3131" href="negation.html#3109" class="Bound">A</a>
<a id="3133" href="negation.html#3079" data-type="¬ A → ¬¬¬ A" class="Function">one-negation-implies-three</a> <a id="3160" class="Symbol">=</a> <a id="3162" href="negation.html#2338" data-type="A → ¬¬ A" class="Function">¬¬-intro</a>
</pre>
<h2 id="negation-of-the-identity-type">Negation of the identity
type</h2>
It is useful to introduce a notation for the negation of the <a
href="identity-type.html">identity type</a>:
<pre class="Agda"><a id="_≢_"></a><a id="3320" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">_≢_</a> <a id="3324" class="Symbol">:</a> <a id="3326" class="Symbol">{</a><a id="3327" href="negation.html#3327" class="Bound">X</a> <a id="3329" class="Symbol">:</a> <a id="3331" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3335" class="Symbol">}</a> <a id="3337" class="Symbol">→</a> <a id="3339" href="negation.html#3327" class="Bound">X</a> <a id="3341" class="Symbol">→</a> <a id="3343" href="negation.html#3327" class="Bound">X</a> <a id="3345" class="Symbol">→</a> <a id="3347" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a>
<a id="3352" href="negation.html#3352" class="Bound">x</a> <a id="3354" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3356" href="negation.html#3356" class="Bound">y</a> <a id="3358" class="Symbol">=</a> <a id="3360" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="3362" class="Symbol">(</a><a id="3363" href="negation.html#3352" class="Bound">x</a> <a id="3365" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3367" href="negation.html#3356" class="Bound">y</a><a id="3368" class="Symbol">)</a>

<a id="≢-sym"></a><a id="3371" href="negation.html#3371" data-type="x ≢ y → y ≢ x" class="Function">≢-sym</a> <a id="3377" class="Symbol">:</a> <a id="3379" class="Symbol">{</a><a id="3380" href="negation.html#3380" class="Bound">X</a> <a id="3382" class="Symbol">:</a> <a id="3384" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3388" class="Symbol">}</a> <a id="3390" class="Symbol">{</a><a id="3391" href="negation.html#3391" class="Bound">x</a> <a id="3393" href="negation.html#3393" class="Bound">y</a> <a id="3395" class="Symbol">:</a> <a id="3397" href="negation.html#3380" class="Bound">X</a><a id="3398" class="Symbol">}</a> <a id="3400" class="Symbol">→</a> <a id="3402" href="negation.html#3391" class="Bound">x</a> <a id="3404" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3406" href="negation.html#3393" class="Bound">y</a> <a id="3408" class="Symbol">→</a> <a id="3410" href="negation.html#3393" class="Bound">y</a> <a id="3412" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3414" href="negation.html#3391" class="Bound">x</a>
<a id="3416" href="negation.html#3371" data-type="x ≢ y → y ≢ x" class="Function">≢-sym</a> <a id="3422" class="Symbol">=</a> <a id="3424" href="negation.html#1742" data-type="(A → B) → ¬ B → ¬ A" class="Function">contrapositive</a> <a id="3439" href="identity-type.html#2343" data-type="x ≡ y → y ≡ x" class="Function">sym</a>

<a id="false-is-not-true"></a><a id="3444" href="negation.html#3444" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3462" class="Symbol">:</a> <a id="3464" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3470" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3472" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
<a id="3477" href="negation.html#3444" data-type="false ≢ true" class="Function">false-is-not-true</a> <a id="3495" class="Symbol">()</a>

<a id="true-is-not-false"></a><a id="3499" href="negation.html#3499" data-type="true ≢ false" class="Function">true-is-not-false</a> <a id="3517" class="Symbol">:</a> <a id="3519" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3524" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3526" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a>
<a id="3532" href="negation.html#3499" data-type="true ≢ false" class="Function">true-is-not-false</a> <a id="3550" class="Symbol">()</a>
</pre>
The following is more interesting:
<pre class="Agda"><a id="not-false-is-true"></a><a id="3600" href="negation.html#3600" data-type="(x : Bool) → x ≢ false → x ≡ true" class="Function">not-false-is-true</a> <a id="3618" class="Symbol">:</a> <a id="3620" class="Symbol">(</a><a id="3621" href="negation.html#3621" class="Bound">x</a> <a id="3623" class="Symbol">:</a> <a id="3625" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a><a id="3629" class="Symbol">)</a> <a id="3631" class="Symbol">→</a> <a id="3633" href="negation.html#3621" class="Bound">x</a> <a id="3635" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3637" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3643" class="Symbol">→</a> <a id="3645" href="negation.html#3621" class="Bound">x</a> <a id="3647" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3649" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
<a id="3654" href="negation.html#3600" data-type="(x : Bool) → x ≢ false → x ≡ true" class="Function">not-false-is-true</a> <a id="3672" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="3678" href="negation.html#3678" class="Bound">f</a> <a id="3680" class="Symbol">=</a> <a id="3682" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3687" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>
<a id="3692" href="negation.html#3600" data-type="(x : Bool) → x ≢ false → x ≡ true" class="Function">not-false-is-true</a> <a id="3710" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3716" href="negation.html#3716" class="Bound">f</a> <a id="3718" class="Symbol">=</a> <a id="3720" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3727" class="Symbol">(</a><a id="3728" href="negation.html#3716" class="Bound">f</a> <a id="3730" class="Symbol">(</a><a id="3731" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3736" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a><a id="3741" class="Symbol">))</a>

<a id="not-true-is-false"></a><a id="3745" href="negation.html#3745" data-type="(x : Bool) → x ≢ true → x ≡ false" class="Function">not-true-is-false</a> <a id="3763" class="Symbol">:</a> <a id="3765" class="Symbol">(</a><a id="3766" href="negation.html#3766" class="Bound">x</a> <a id="3768" class="Symbol">:</a> <a id="3770" href="Bool.html#594" data-type="Set" class="Datatype">Bool</a><a id="3774" class="Symbol">)</a> <a id="3776" class="Symbol">→</a> <a id="3778" href="negation.html#3766" class="Bound">x</a> <a id="3780" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="3782" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a> <a id="3787" class="Symbol">→</a> <a id="3789" href="negation.html#3766" class="Bound">x</a> <a id="3791" href="identity-type.html#729" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3793" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a>
<a id="3799" href="negation.html#3745" data-type="(x : Bool) → x ≢ true → x ≡ false" class="Function">not-true-is-false</a> <a id="3817" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a>  <a id="3823" href="negation.html#3823" class="Bound">f</a> <a id="3825" class="Symbol">=</a> <a id="3827" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="3834" class="Symbol">(</a><a id="3835" href="negation.html#3823" class="Bound">f</a> <a id="3837" class="Symbol">(</a><a id="3838" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3843" href="Bool.html#613" data-type="Bool" class="InductiveConstructor">true</a><a id="3847" class="Symbol">))</a>
<a id="3850" href="negation.html#3745" data-type="(x : Bool) → x ≢ true → x ≡ false" class="Function">not-true-is-false</a> <a id="3868" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a> <a id="3874" href="negation.html#3874" class="Bound">f</a> <a id="3876" class="Symbol">=</a> <a id="3878" href="identity-type.html#766" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3883" href="Bool.html#618" data-type="Bool" class="InductiveConstructor">false</a>
</pre>
<h2 id="disjointness-of-binary-sums">Disjointness of binary sums</h2>
We now show something that is intuitively the case:
<pre class="Agda"><a id="inl-is-not-inr"></a><a id="3986" href="negation.html#3986" data-type="inl x ≢ inr y" class="Function">inl-is-not-inr</a> <a id="4001" class="Symbol">:</a> <a id="4003" class="Symbol">{</a><a id="4004" href="negation.html#4004" class="Bound">X</a> <a id="4006" href="negation.html#4006" class="Bound">Y</a> <a id="4008" class="Symbol">:</a> <a id="4010" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4014" class="Symbol">}</a> <a id="4016" class="Symbol">{</a><a id="4017" href="negation.html#4017" class="Bound">x</a> <a id="4019" class="Symbol">:</a> <a id="4021" href="negation.html#4004" class="Bound">X</a><a id="4022" class="Symbol">}</a> <a id="4024" class="Symbol">{</a><a id="4025" href="negation.html#4025" class="Bound">y</a> <a id="4027" class="Symbol">:</a> <a id="4029" href="negation.html#4006" class="Bound">Y</a><a id="4030" class="Symbol">}</a> <a id="4032" class="Symbol">→</a> <a id="4034" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="4038" href="negation.html#4017" class="Bound">x</a> <a id="4040" href="negation.html#3320" data-type="X → X → Type" class="Function Operator">≢</a> <a id="4042" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4046" href="negation.html#4025" class="Bound">y</a>
<a id="4048" href="negation.html#3986" data-type="inl x ≢ inr y" class="Function">inl-is-not-inr</a> <a id="4063" class="Symbol">()</a>
</pre>
<p>Agda just knows it.</p>
<h2 id="disjunctions-and-negation">Disjunctions and negation</h2>
If <code>A or B</code> holds and <code>B</code> is false, then
<code>A</code> must hold:
<pre class="Agda"><a id="right-fails-gives-left-holds"></a><a id="4186" href="negation.html#4186" data-type="A ∔ B → ¬ B → A" class="Function">right-fails-gives-left-holds</a> <a id="4215" class="Symbol">:</a> <a id="4217" class="Symbol">{</a><a id="4218" href="negation.html#4218" class="Bound">A</a> <a id="4220" href="negation.html#4220" class="Bound">B</a> <a id="4222" class="Symbol">:</a> <a id="4224" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4228" class="Symbol">}</a> <a id="4230" class="Symbol">→</a> <a id="4232" href="negation.html#4218" class="Bound">A</a> <a id="4234" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4236" href="negation.html#4220" class="Bound">B</a> <a id="4238" class="Symbol">→</a> <a id="4240" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="4242" href="negation.html#4220" class="Bound">B</a> <a id="4244" class="Symbol">→</a> <a id="4246" href="negation.html#4218" class="Bound">A</a>
<a id="4248" href="negation.html#4186" data-type="A ∔ B → ¬ B → A" class="Function">right-fails-gives-left-holds</a> <a id="4277" class="Symbol">(</a><a id="4278" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="4282" href="negation.html#4282" class="Bound">a</a><a id="4283" class="Symbol">)</a> <a id="4285" href="negation.html#4285" class="Bound">f</a> <a id="4287" class="Symbol">=</a> <a id="4289" href="negation.html#4282" class="Bound">a</a>
<a id="4291" href="negation.html#4186" data-type="A ∔ B → ¬ B → A" class="Function">right-fails-gives-left-holds</a> <a id="4320" class="Symbol">(</a><a id="4321" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4325" href="negation.html#4325" class="Bound">b</a><a id="4326" class="Symbol">)</a> <a id="4328" href="negation.html#4328" class="Bound">f</a> <a id="4330" class="Symbol">=</a> <a id="4332" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="4339" class="Symbol">(</a><a id="4340" href="negation.html#4328" class="Bound">f</a> <a id="4342" href="negation.html#4325" class="Bound">b</a><a id="4343" class="Symbol">)</a>

<a id="left-fails-gives-right-holds"></a><a id="4346" href="negation.html#4346" data-type="A ∔ B → ¬ A → B" class="Function">left-fails-gives-right-holds</a> <a id="4375" class="Symbol">:</a> <a id="4377" class="Symbol">{</a><a id="4378" href="negation.html#4378" class="Bound">A</a> <a id="4380" href="negation.html#4380" class="Bound">B</a> <a id="4382" class="Symbol">:</a> <a id="4384" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4388" class="Symbol">}</a> <a id="4390" class="Symbol">→</a> <a id="4392" href="negation.html#4378" class="Bound">A</a> <a id="4394" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4396" href="negation.html#4380" class="Bound">B</a> <a id="4398" class="Symbol">→</a> <a id="4400" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="4402" href="negation.html#4378" class="Bound">A</a> <a id="4404" class="Symbol">→</a> <a id="4406" href="negation.html#4380" class="Bound">B</a>
<a id="4408" href="negation.html#4346" data-type="A ∔ B → ¬ A → B" class="Function">left-fails-gives-right-holds</a> <a id="4437" class="Symbol">(</a><a id="4438" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="4442" href="negation.html#4442" class="Bound">a</a><a id="4443" class="Symbol">)</a> <a id="4445" href="negation.html#4445" class="Bound">f</a> <a id="4447" class="Symbol">=</a> <a id="4449" href="empty-type.html#1871" data-type="(x : 𝟘) → A x" class="Function">𝟘-elim</a> <a id="4456" class="Symbol">(</a><a id="4457" href="negation.html#4445" class="Bound">f</a> <a id="4459" href="negation.html#4442" class="Bound">a</a><a id="4460" class="Symbol">)</a>
<a id="4462" href="negation.html#4346" data-type="A ∔ B → ¬ A → B" class="Function">left-fails-gives-right-holds</a> <a id="4491" class="Symbol">(</a><a id="4492" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4496" href="negation.html#4496" class="Bound">b</a><a id="4497" class="Symbol">)</a> <a id="4499" href="negation.html#4499" class="Bound">f</a> <a id="4501" class="Symbol">=</a> <a id="4503" href="negation.html#4496" class="Bound">b</a>
</pre>
<h2 id="negation-of-the-existential-quantifier">Negation of the
existential quantifier:</h2>
If there is no <code>x : X</code> with <code>A x</code>, then for all
<code>x : X</code> not <code>A x</code>:
<pre class="Agda"><a id="not-exists-implies-forall-not"></a><a id="4629" href="negation.html#4629" data-type="¬ Sigma X A → (x : X) → ¬ A x" class="Function">not-exists-implies-forall-not</a> <a id="4659" class="Symbol">:</a> <a id="4661" class="Symbol">{</a><a id="4662" href="negation.html#4662" class="Bound">X</a> <a id="4664" class="Symbol">:</a> <a id="4666" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4670" class="Symbol">}</a> <a id="4672" class="Symbol">{</a><a id="4673" href="negation.html#4673" class="Bound">A</a> <a id="4675" class="Symbol">:</a> <a id="4677" href="negation.html#4662" class="Bound">X</a> <a id="4679" class="Symbol">→</a> <a id="4681" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4685" class="Symbol">}</a>
                              <a id="4717" class="Symbol">→</a> <a id="4719" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="4721" class="Symbol">(</a><a id="4722" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="4724" href="negation.html#4724" class="Bound">x</a> <a id="4726" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="4728" href="negation.html#4662" class="Bound">X</a> <a id="4730" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="4732" href="negation.html#4673" class="Bound">A</a> <a id="4734" href="negation.html#4724" class="Bound">x</a><a id="4735" class="Symbol">)</a>
                              <a id="4767" class="Symbol">→</a> <a id="4769" class="Symbol">(</a><a id="4770" href="negation.html#4770" class="Bound">x</a> <a id="4772" class="Symbol">:</a> <a id="4774" href="negation.html#4662" class="Bound">X</a><a id="4775" class="Symbol">)</a> <a id="4777" class="Symbol">→</a> <a id="4779" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="4781" href="negation.html#4673" class="Bound">A</a> <a id="4783" href="negation.html#4770" class="Bound">x</a>
<a id="4785" href="negation.html#4629" data-type="¬ Sigma X A → (x : X) → ¬ A x" class="Function">not-exists-implies-forall-not</a> <a id="4815" href="negation.html#4815" class="Bound">f</a> <a id="4817" href="negation.html#4817" class="Bound">x</a> <a id="4819" href="negation.html#4819" class="Bound">a</a> <a id="4821" class="Symbol">=</a> <a id="4823" href="negation.html#4815" class="Bound">f</a> <a id="4825" class="Symbol">(</a><a id="4826" href="negation.html#4817" class="Bound">x</a> <a id="4828" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="4830" href="negation.html#4819" class="Bound">a</a><a id="4831" class="Symbol">)</a>
</pre>
The converse also holds:
<pre class="Agda"><a id="forall-not-implies-not-exists"></a><a id="4870" href="negation.html#4870" data-type="((x : X) → ¬ A x) → ¬ Sigma X A" class="Function">forall-not-implies-not-exists</a> <a id="4900" class="Symbol">:</a> <a id="4902" class="Symbol">{</a><a id="4903" href="negation.html#4903" class="Bound">X</a> <a id="4905" class="Symbol">:</a> <a id="4907" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4911" class="Symbol">}</a> <a id="4913" class="Symbol">{</a><a id="4914" href="negation.html#4914" class="Bound">A</a> <a id="4916" class="Symbol">:</a> <a id="4918" href="negation.html#4903" class="Bound">X</a> <a id="4920" class="Symbol">→</a> <a id="4922" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4926" class="Symbol">}</a>
                              <a id="4958" class="Symbol">→</a> <a id="4960" class="Symbol">((</a><a id="4962" href="negation.html#4962" class="Bound">x</a> <a id="4964" class="Symbol">:</a> <a id="4966" href="negation.html#4903" class="Bound">X</a><a id="4967" class="Symbol">)</a> <a id="4969" class="Symbol">→</a> <a id="4971" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="4973" href="negation.html#4914" class="Bound">A</a> <a id="4975" href="negation.html#4962" class="Bound">x</a><a id="4976" class="Symbol">)</a>
                              <a id="5008" class="Symbol">→</a> <a id="5010" href="empty-type.html#1787" data-type="Type → Type" class="Function Operator">¬</a> <a id="5012" class="Symbol">(</a><a id="5013" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">Σ</a> <a id="5015" href="negation.html#5015" class="Bound">x</a> <a id="5017" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">꞉</a> <a id="5019" href="negation.html#4903" class="Bound">X</a> <a id="5021" href="sums.html#3710" data-type="(A : Type) → (A → Type) → Type" class="Function">,</a> <a id="5023" href="negation.html#4914" class="Bound">A</a> <a id="5025" href="negation.html#5015" class="Bound">x</a><a id="5026" class="Symbol">)</a>
<a id="5028" href="negation.html#4870" data-type="((x : X) → ¬ A x) → ¬ Sigma X A" class="Function">forall-not-implies-not-exists</a> <a id="5058" href="negation.html#5058" class="Bound">g</a> <a id="5060" class="Symbol">(</a><a id="5061" href="negation.html#5061" class="Bound">x</a> <a id="5063" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5065" href="negation.html#5065" class="Bound">a</a><a id="5066" class="Symbol">)</a> <a id="5068" class="Symbol">=</a> <a id="5070" href="negation.html#5058" class="Bound">g</a> <a id="5072" href="negation.html#5061" class="Bound">x</a> <a id="5074" href="negation.html#5065" class="Bound">a</a>
</pre>
<p>Notice how these are particular cases of <a
href="https://en.wikipedia.org/wiki/Currying"><code>curry</code> and
<code>uncurry</code></a>.</p>
<h2 id="implication-truth-table">Implication truth table</h2>
Here is a proof of the implication truth-table:
<pre class="Agda"><a id="5271" class="Keyword">open</a> <a id="5276" class="Keyword">import</a> <a id="5283" href="empty-type.html" class="Module">empty-type</a>
<a id="5294" class="Keyword">open</a> <a id="5299" class="Keyword">import</a> <a id="5306" href="unit-type.html" class="Module">unit-type</a>

<a id="implication-truth-table"></a><a id="5317" href="negation.html#5317" data-type="((𝟘 → 𝟘) ⇔ 𝟙) × ((𝟘 → 𝟙) ⇔ 𝟙) × ((𝟙 → 𝟘) ⇔ 𝟘) × ((𝟙 → 𝟙) ⇔ 𝟙)" class="Function">implication-truth-table</a> <a id="5341" class="Symbol">:</a> <a id="5343" class="Symbol">((</a><a id="5345" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a> <a id="5347" class="Symbol">→</a> <a id="5349" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a><a id="5350" class="Symbol">)</a> <a id="5352" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="5354" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a><a id="5355" class="Symbol">)</a>
                        <a id="5381" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="5383" class="Symbol">((</a><a id="5385" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a> <a id="5387" class="Symbol">→</a> <a id="5389" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a><a id="5390" class="Symbol">)</a> <a id="5392" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="5394" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a><a id="5395" class="Symbol">)</a>
                        <a id="5421" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="5423" class="Symbol">((</a><a id="5425" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a> <a id="5427" class="Symbol">→</a> <a id="5429" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a><a id="5430" class="Symbol">)</a> <a id="5432" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="5434" href="empty-type.html#625" data-type="Set" class="Datatype">𝟘</a><a id="5435" class="Symbol">)</a>
                        <a id="5461" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="5463" class="Symbol">((</a><a id="5465" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a> <a id="5467" class="Symbol">→</a> <a id="5469" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a><a id="5470" class="Symbol">)</a> <a id="5472" href="binary-products.html#1416" data-type="Type → Type → Type" class="Function Operator">⇔</a> <a id="5474" href="unit-type.html#498" data-type="Type" class="Record">𝟙</a><a id="5475" class="Symbol">)</a>
<a id="5477" href="negation.html#5317" data-type="((𝟘 → 𝟘) ⇔ 𝟙) × ((𝟘 → 𝟙) ⇔ 𝟙) × ((𝟙 → 𝟘) ⇔ 𝟘) × ((𝟙 → 𝟙) ⇔ 𝟙)" class="Function">implication-truth-table</a> <a id="5501" class="Symbol">=</a> <a id="5503" class="Symbol">((λ</a> <a id="5507" href="negation.html#5507" class="Bound">_</a> <a id="5509" class="Symbol">→</a> <a id="5511" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5512" class="Symbol">)</a>   <a id="5516" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5518" class="Symbol">(λ</a> <a id="5521" href="negation.html#5521" class="Bound">_</a> <a id="5523" class="Symbol">→</a> <a id="5525" href="products.html#1143" data-type="A → A" class="Function">id</a><a id="5527" class="Symbol">))</a> <a id="5530" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a>
                          <a id="5558" class="Symbol">((λ</a> <a id="5562" href="negation.html#5562" class="Bound">_</a> <a id="5564" class="Symbol">→</a> <a id="5566" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5567" class="Symbol">)</a>   <a id="5571" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5573" class="Symbol">(λ</a> <a id="5576" href="negation.html#5576" class="Bound">_</a> <a id="5578" href="negation.html#5578" class="Bound">_</a> <a id="5580" class="Symbol">→</a> <a id="5582" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5583" class="Symbol">))</a> <a id="5586" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a>
                          <a id="5614" class="Symbol">((λ</a> <a id="5618" href="negation.html#5618" class="Bound">f</a> <a id="5620" class="Symbol">→</a> <a id="5622" href="negation.html#5618" class="Bound">f</a> <a id="5624" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5625" class="Symbol">)</a> <a id="5627" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5629" class="Symbol">(λ</a> <a id="5632" href="negation.html#5632" class="Bound">⋆</a> <a id="5634" href="negation.html#5634" class="Bound">_</a> <a id="5636" class="Symbol">→</a> <a id="5638" href="negation.html#5632" class="Bound">⋆</a><a id="5639" class="Symbol">))</a> <a id="5642" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a>
                          <a id="5670" class="Symbol">((λ</a> <a id="5674" href="negation.html#5674" class="Bound">_</a> <a id="5676" class="Symbol">→</a> <a id="5678" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5679" class="Symbol">)</a>   <a id="5683" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5685" class="Symbol">(λ</a> <a id="5688" href="negation.html#5688" class="Bound">_</a> <a id="5690" href="negation.html#5690" class="Bound">_</a> <a id="5692" class="Symbol">→</a> <a id="5694" href="unit-type.html#528" data-type="𝟙" class="InductiveConstructor">⋆</a><a id="5695" class="Symbol">))</a>
</pre>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
