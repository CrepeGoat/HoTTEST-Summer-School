<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<a id=modBool></a>
<h2 id="the-booleans">The booleans</h2>
We discuss the elimination principle for the booleans. The booleans are
defined by constructors <code>true</code> and <code>false</code>:
<pre class="Agda"><a id="445" class="Keyword">data</a> <a id="Bool"></a><a id="450" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="455" class="Symbol">:</a> <a id="457" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="462" class="Keyword">where</a>
 <a id="Bool.true"></a><a id="469" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="Bool.false"></a><a id="474" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="480" class="Symbol">:</a> <a id="482" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
</pre>
<h3 id="if-then-else"><code>if-then-else</code></h3>
The non-dependent eliminator of the type of booleans amounts to
<code>if-then-else</code>
<pre class="Agda"><a id="if_then_else_"></a><a id="597" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if_then_else_</a> <a id="611" class="Symbol">:</a> <a id="613" class="Symbol">{</a><a id="614" href="Bool.html#614" class="Bound">A</a> <a id="616" class="Symbol">:</a> <a id="618" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="622" class="Symbol">}</a> <a id="624" class="Symbol">→</a> <a id="626" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="631" class="Symbol">→</a> <a id="633" href="Bool.html#614" class="Bound">A</a> <a id="635" class="Symbol">→</a> <a id="637" href="Bool.html#614" class="Bound">A</a> <a id="639" class="Symbol">→</a> <a id="641" href="Bool.html#614" class="Bound">A</a>
<a id="643" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="646" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="652" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="657" href="Bool.html#657" class="Bound">x</a> <a id="659" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="664" href="Bool.html#664" class="Bound">y</a> <a id="666" class="Symbol">=</a> <a id="668" href="Bool.html#657" class="Bound">x</a>
<a id="670" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="673" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="679" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="684" href="Bool.html#684" class="Bound">x</a> <a id="686" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="691" href="Bool.html#691" class="Bound">y</a> <a id="693" class="Symbol">=</a> <a id="695" href="Bool.html#691" class="Bound">y</a>
</pre>
<p>In general, the non-dependent elimination principle of a type
explains how to “get out of the type”, whereas the constructors tell us
how to “get into the type”.</p>
<h3 id="dependent-if-then-else">Dependent <code>if-then-else</code></h3>
Notice that both <code>x</code> (the <code>then</code> branch) and
<code>y</code> (the <code>else</code> branch) have the same type, name
<code>A</code>. Using dependent type, we can have different types in the
dependent version of the eliminator. We make the type <code>A</code>
depend on the boolean condition of the <code>if-then-else</code>. This
means that now we will have <code>A : Bool → Type</code> instead of
<code>A : Bool</code>. This is a function that given a boolean
<code>b : Bool</code>, returns a type <code>A b</code>. Functions whose
return value is a type are also called <em>type families</em>. Also
<code>A b</code> is called a <em>dependent type</em>. It depends on the
value of the boolean <code>b</code>. Here is an example, which we make
private to this module.
<pre class="Agda"><a id="1533" class="Keyword">private</a>
 <a id="1542" class="Keyword">open</a> <a id="1547" class="Keyword">import</a> <a id="1554" href="natural-numbers-type.html" class="Module">natural-numbers-type</a>
 <a id="A-example"></a><a id="1576" href="Bool.html#1576" class="Function">A-example</a> <a id="1586" class="Symbol">:</a> <a id="1588" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="1593" class="Symbol">→</a> <a id="1595" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
 <a id="1601" href="Bool.html#1576" class="Function">A-example</a> <a id="1611" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="1617" class="Symbol">=</a> <a id="1619" href="introduction.html#535" data-type="Set" class="Datatype">ℕ</a>
 <a id="1622" href="Bool.html#1576" class="Function">A-example</a> <a id="1632" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="1638" class="Symbol">=</a> <a id="1640" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
</pre>
Using this idea, we have the following dependently-typed version of
<code>if_then_else_</code>, which now has four explicit arguments. We
make <code>A</code> explicit this time, because Agda can hardly ever
infer it.
<pre class="Agda"><a id="dependent-on_if_then_else_"></a><a id="1852" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">dependent-on_if_then_else_</a> <a id="1879" class="Symbol">:</a> <a id="1881" class="Symbol">(</a><a id="1882" href="Bool.html#1882" class="Bound">A</a> <a id="1884" class="Symbol">:</a> <a id="1886" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="1891" class="Symbol">→</a> <a id="1893" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="1897" class="Symbol">)</a> <a id="1899" class="Symbol">→</a> <a id="1901" class="Symbol">(</a><a id="1902" href="Bool.html#1902" class="Bound">b</a> <a id="1904" class="Symbol">:</a> <a id="1906" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="1910" class="Symbol">)</a> <a id="1912" class="Symbol">→</a> <a id="1914" href="Bool.html#1882" class="Bound">A</a> <a id="1916" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a> <a id="1921" class="Symbol">→</a> <a id="1923" href="Bool.html#1882" class="Bound">A</a> <a id="1925" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="1931" class="Symbol">→</a> <a id="1933" href="Bool.html#1882" class="Bound">A</a> <a id="1935" href="Bool.html#1902" class="Bound">b</a>
<a id="1937" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">dependent-on</a> <a id="1950" href="Bool.html#1950" class="Bound">A</a> <a id="1952" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">if</a> <a id="1955" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="1961" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">then</a> <a id="1966" href="Bool.html#1966" class="Bound">x</a> <a id="1968" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">else</a> <a id="1973" href="Bool.html#1973" class="Bound">y</a> <a id="1975" class="Symbol">=</a> <a id="1977" href="Bool.html#1966" class="Bound">x</a>
<a id="1979" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">dependent-on</a> <a id="1992" href="Bool.html#1992" class="Bound">A</a> <a id="1994" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">if</a> <a id="1997" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="2003" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">then</a> <a id="2008" href="Bool.html#2008" class="Bound">x</a> <a id="2010" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">else</a> <a id="2015" href="Bool.html#2015" class="Bound">y</a> <a id="2017" class="Symbol">=</a> <a id="2019" href="Bool.html#2015" class="Bound">y</a>
</pre>
Notice that the return type <code>A b</code> depends on the second
argument <code>b</code> of the function. Notice also that
<code>x : A true</code> and <code>y : A false</code>.
<pre class="Agda"><a id="2168" class="Keyword">private</a>
 <a id="example₀"></a><a id="2177" href="Bool.html#2177" class="Function">example₀</a> <a id="2186" class="Symbol">:</a> <a id="2188" class="Symbol">(</a><a id="2189" href="Bool.html#2189" class="Bound">b</a> <a id="2191" class="Symbol">:</a> <a id="2193" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="2197" class="Symbol">)</a> <a id="2199" class="Symbol">→</a> <a id="2201" href="Bool.html#1576" class="Function">A-example</a> <a id="2211" href="Bool.html#2189" class="Bound">b</a>
 <a id="2214" href="Bool.html#2177" class="Function">example₀</a> <a id="2223" href="Bool.html#2223" class="Bound">b</a> <a id="2225" class="Symbol">=</a> <a id="2227" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">dependent-on</a> <a id="2240" href="Bool.html#1576" class="Function">A-example</a> <a id="2250" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">if</a> <a id="2253" href="Bool.html#2223" class="Bound">b</a> <a id="2255" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">then</a> <a id="2260" class="Number">3</a> <a id="2262" href="Bool.html#1852" data-type="(A : Bool → Type) (b : Bool) → A true → A false → A b" class="Function Operator">else</a> <a id="2267" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
</pre>
<p>This works because <code>3 : A-example true</code> and
<code>true : A-example false</code>. So the dependent version of
<code>if-then-else</code> allows the <code>then</code> and
<code>else</code> branches have different types, which depend on the
type of the condition.</p>
<h3
id="the-official-definition-of-the-eliminator-of-the-type-of-booleans">The
official definition of the eliminator of the type of booleans</h3>
Traditionally the argument of the type we want to eliminate (the
booleans in our case) is written last:
<pre class="Agda"><a id="Bool-elim"></a><a id="2675" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="2685" class="Symbol">:</a> <a id="2687" class="Symbol">(</a><a id="2688" href="Bool.html#2688" class="Bound">A</a> <a id="2690" class="Symbol">:</a> <a id="2692" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="2697" class="Symbol">→</a> <a id="2699" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2703" class="Symbol">)</a>
          <a id="2715" class="Symbol">→</a> <a id="2717" href="Bool.html#2688" class="Bound">A</a> <a id="2719" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
          <a id="2734" class="Symbol">→</a> <a id="2736" href="Bool.html#2688" class="Bound">A</a> <a id="2738" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>
          <a id="2754" class="Symbol">→</a> <a id="2756" class="Symbol">(</a><a id="2757" href="Bool.html#2757" class="Bound">b</a> <a id="2759" class="Symbol">:</a> <a id="2761" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="2765" class="Symbol">)</a> <a id="2767" class="Symbol">→</a> <a id="2769" href="Bool.html#2688" class="Bound">A</a> <a id="2771" href="Bool.html#2757" class="Bound">b</a>
<a id="2773" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="2783" href="Bool.html#2783" class="Bound">A</a> <a id="2785" href="Bool.html#2785" class="Bound">x</a> <a id="2787" href="Bool.html#2787" class="Bound">y</a> <a id="2789" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="2795" class="Symbol">=</a> <a id="2797" href="Bool.html#2785" class="Bound">x</a>
<a id="2799" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="2809" href="Bool.html#2809" class="Bound">A</a> <a id="2811" href="Bool.html#2811" class="Bound">x</a> <a id="2813" href="Bool.html#2813" class="Bound">y</a> <a id="2815" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="2821" class="Symbol">=</a> <a id="2823" href="Bool.html#2813" class="Bound">y</a>
</pre>
<p>The type of <code>Bool-elim</code> says that if we provide elements
of the type <code>A true</code> and <code>A false</code>, we get a
function <code>(b : Bool) → A b</code>.</p>
The non-dependent version is a particular case of the dependent version,
by considering the constant type family <code>λ _ → A</code> for a given
<code>A : Type</code>. This time we make the first argument
<code>A</code> implicit:
<pre class="Agda"><a id="Bool-nondep-elim"></a><a id="3167" href="Bool.html#3167" data-type="A → A → Bool → A" class="Function">Bool-nondep-elim</a> <a id="3184" class="Symbol">:</a> <a id="3186" class="Symbol">{</a><a id="3187" href="Bool.html#3187" class="Bound">A</a> <a id="3189" class="Symbol">:</a> <a id="3191" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3195" class="Symbol">}</a>
                 <a id="3214" class="Symbol">→</a> <a id="3216" href="Bool.html#3187" class="Bound">A</a>
                 <a id="3235" class="Symbol">→</a> <a id="3237" href="Bool.html#3187" class="Bound">A</a>
                 <a id="3256" class="Symbol">→</a> <a id="3258" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="3263" class="Symbol">→</a> <a id="3265" href="Bool.html#3187" class="Bound">A</a>
<a id="3267" href="Bool.html#3167" data-type="A → A → Bool → A" class="Function">Bool-nondep-elim</a> <a id="3284" class="Symbol">{</a><a id="3285" href="Bool.html#3285" class="Bound">A</a><a id="3286" class="Symbol">}</a> <a id="3288" class="Symbol">=</a> <a id="3290" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="3300" class="Symbol">(λ</a> <a id="3303" href="Bool.html#3303" class="Bound">_</a> <a id="3305" class="Symbol">→</a> <a id="3307" href="Bool.html#3285" class="Bound">A</a><a id="3308" class="Symbol">)</a>
</pre>
<p>This produces a function <code>Bool → A</code> from two given
elements of the type <code>A</code>.</p>
<h3 id="logical-reading-of-the-eliminator">Logical reading of the
eliminator</h3>
<p>The <em>conclusion</em> of <code>Bool-elim</code> is
<code>(b : Bool) → A b</code>, which under <em>propositions as
types</em> has the logical reading “for all <code>b : Bool</code>, the
proposition <code>A b</code> holds”. The <em>hypotheses</em>
<code>A true</code> and <code>A false</code> are all is needed to reach
this conclusion.</p>
<p>Thus the logical reading of <code>Bool-elim</code> is:</p>
<ul>
<li>In order to prove that “for all <code>b : Bool</code>, the
proposition <code>A b</code> holds”</li>
</ul>
<p>it is enough to prove that</p>
<ul>
<li><p>the proposition <code>A true</code> holds, and</p></li>
<li><p>the proposition <code>A false</code> holds,</p></li>
</ul>
<p>which should be intuitively clear.</p>
<h3 id="examples-of-proofs-using-the-eliminator">Examples of proofs
using the eliminator</h3>
First define
<pre class="Agda"><a id="not"></a><a id="4009" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4013" class="Symbol">:</a> <a id="4015" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="4020" class="Symbol">→</a> <a id="4022" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="4027" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4031" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="4037" class="Symbol">=</a> <a id="4039" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>
<a id="4045" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4049" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4055" class="Symbol">=</a> <a id="4057" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
</pre>
Then we can prove that <code>not</code> can be expressed using
<code>if-then-else</code>:
<pre class="Agda"><a id="4142" class="Keyword">open</a> <a id="4147" class="Keyword">import</a> <a id="4154" href="identity-type.html" class="Module">identity-type</a>
<a id="not-defined-with-if"></a><a id="4168" href="Bool.html#4168" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if</a> <a id="4188" class="Symbol">:</a> <a id="4190" class="Symbol">(</a><a id="4191" href="Bool.html#4191" class="Bound">b</a> <a id="4193" class="Symbol">:</a> <a id="4195" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="4199" class="Symbol">)</a> <a id="4201" class="Symbol">→</a> <a id="4203" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4207" href="Bool.html#4191" class="Bound">b</a> <a id="4209" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4211" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="4214" href="Bool.html#4191" class="Bound">b</a> <a id="4216" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="4221" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4227" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="4232" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="4237" href="Bool.html#4168" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if</a> <a id="4257" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="4263" class="Symbol">=</a> <a id="4265" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4270" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>
<a id="4276" href="Bool.html#4168" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if</a> <a id="4296" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4302" class="Symbol">=</a> <a id="4304" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4309" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
</pre>
Using the eliminator, this can be proved as follows:
<pre class="Agda"><a id="not-defined-with-if₀"></a><a id="4379" href="Bool.html#4379" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₀</a> <a id="4400" class="Symbol">:</a> <a id="4402" class="Symbol">(</a><a id="4403" href="Bool.html#4403" class="Bound">b</a> <a id="4405" class="Symbol">:</a> <a id="4407" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="4411" class="Symbol">)</a> <a id="4413" class="Symbol">→</a> <a id="4415" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4419" href="Bool.html#4403" class="Bound">b</a> <a id="4421" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4423" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="4426" href="Bool.html#4403" class="Bound">b</a> <a id="4428" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="4433" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4439" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="4444" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="4449" href="Bool.html#4379" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₀</a> <a id="4470" class="Symbol">=</a> <a id="4472" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="4482" href="Bool.html#4497" data-type="Bool → Type" class="Function">A</a> <a id="4484" href="Bool.html#4558" data-type="A true" class="Function">x</a> <a id="4486" href="Bool.html#4589" data-type="A false" class="Function">y</a>
 <a id="4489" class="Keyword">where</a>
  <a id="4497" href="Bool.html#4497" data-type="Bool → Type" class="Function">A</a> <a id="4499" class="Symbol">:</a> <a id="4501" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="4506" class="Symbol">→</a> <a id="4508" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
  <a id="4515" href="Bool.html#4497" data-type="Bool → Type" class="Function">A</a> <a id="4517" href="Bool.html#4517" class="Bound">b</a> <a id="4519" class="Symbol">=</a> <a id="4521" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4525" href="Bool.html#4517" class="Bound">b</a> <a id="4527" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4529" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="4532" href="Bool.html#4517" class="Bound">b</a> <a id="4534" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="4539" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4545" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="4550" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>

  <a id="4558" href="Bool.html#4558" data-type="A true" class="Function">x</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="Bool.html#4497" data-type="Bool → Type" class="Function">A</a> <a id="4564" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="4571" href="Bool.html#4558" data-type="A true" class="Function">x</a> <a id="4573" class="Symbol">=</a> <a id="4575" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4580" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>

  <a id="4589" href="Bool.html#4589" data-type="A false" class="Function">y</a> <a id="4591" class="Symbol">:</a> <a id="4593" href="Bool.html#4497" data-type="Bool → Type" class="Function">A</a> <a id="4595" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>
  <a id="4603" href="Bool.html#4589" data-type="A false" class="Function">y</a> <a id="4605" class="Symbol">=</a> <a id="4607" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4612" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
</pre>
Of course, we can “in-line” the definitions of the <code>where</code>
clause:
<pre class="Agda"><a id="not-defined-with-if₁"></a><a id="4696" href="Bool.html#4696" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₁</a> <a id="4717" class="Symbol">:</a> <a id="4719" class="Symbol">(</a><a id="4720" href="Bool.html#4720" class="Bound">b</a> <a id="4722" class="Symbol">:</a> <a id="4724" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="4728" class="Symbol">)</a> <a id="4730" class="Symbol">→</a> <a id="4732" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4736" href="Bool.html#4720" class="Bound">b</a> <a id="4738" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4740" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="4743" href="Bool.html#4720" class="Bound">b</a> <a id="4745" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="4750" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4756" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="4761" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="4766" href="Bool.html#4696" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₁</a> <a id="4787" class="Symbol">=</a> <a id="4789" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a>
                        <a id="4823" class="Symbol">(λ</a> <a id="4826" href="Bool.html#4826" class="Bound">b</a> <a id="4828" class="Symbol">→</a> <a id="4830" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="4834" href="Bool.html#4826" class="Bound">b</a> <a id="4836" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4838" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="4841" href="Bool.html#4826" class="Bound">b</a> <a id="4843" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="4848" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="4854" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="4859" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="4863" class="Symbol">)</a>
                        <a id="4889" class="Symbol">(</a><a id="4890" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4895" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="4900" class="Symbol">)</a>
                        <a id="4926" class="Symbol">(</a><a id="4927" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4932" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="4936" class="Symbol">)</a>
</pre>
This is shorter but probably less readable. The following is even
shorter, using the fact that Agda can infer the property
<code>A : Bool → Type</code> we want to prove automatically. We use
<code>_</code> to tell Agda “please figure out yourself what this
argument in the function has to be”:
<pre class="Agda"><a id="not-defined-with-if₂"></a><a id="5222" href="Bool.html#5222" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₂</a> <a id="5243" class="Symbol">:</a> <a id="5245" class="Symbol">(</a><a id="5246" href="Bool.html#5246" class="Bound">b</a> <a id="5248" class="Symbol">:</a> <a id="5250" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="5254" class="Symbol">)</a> <a id="5256" class="Symbol">→</a> <a id="5258" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="5262" href="Bool.html#5246" class="Bound">b</a> <a id="5264" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5266" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">if</a> <a id="5269" href="Bool.html#5246" class="Bound">b</a> <a id="5271" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">then</a> <a id="5276" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="5282" href="Bool.html#597" data-type="Bool → A → A → A" class="Function Operator">else</a> <a id="5287" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="5292" href="Bool.html#5222" data-type="(b : Bool) → not b ≡ (if b then false else true)" class="Function">not-defined-with-if₂</a> <a id="5313" class="Symbol">=</a> <a id="5315" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="5325" class="Symbol">_</a> <a id="5327" class="Symbol">(</a><a id="5328" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="5333" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="5338" class="Symbol">)</a> <a id="5340" class="Symbol">(</a><a id="5341" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="5346" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="5350" class="Symbol">)</a>
</pre>
In situations where we try to use <code>_</code> but Agda can’t
determine that there is a <em>unique</em> answer to what <code>_</code>
should be, the colour yellow is used to indicate this in the syntax
highlighting, accompanied by an error message. To give another example,
we first define the notion of an <a
href="https://en.wikipedia.org/wiki/Involution_(mathematics)">involution</a>,
or involutive function:
<pre class="Agda"><a id="is-involution"></a><a id="5738" href="Bool.html#5738" data-type="(X → X) → Type" class="Function">is-involution</a> <a id="5752" class="Symbol">:</a> <a id="5754" class="Symbol">{</a><a id="5755" href="Bool.html#5755" class="Bound">X</a> <a id="5757" class="Symbol">:</a> <a id="5759" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="5763" class="Symbol">}</a> <a id="5765" class="Symbol">→</a> <a id="5767" class="Symbol">(</a><a id="5768" href="Bool.html#5755" class="Bound">X</a> <a id="5770" class="Symbol">→</a> <a id="5772" href="Bool.html#5755" class="Bound">X</a><a id="5773" class="Symbol">)</a> <a id="5775" class="Symbol">→</a> <a id="5777" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="5782" href="Bool.html#5738" data-type="(X → X) → Type" class="Function">is-involution</a> <a id="5796" class="Symbol">{</a><a id="5797" href="Bool.html#5797" class="Bound">X</a><a id="5798" class="Symbol">}</a> <a id="5800" href="Bool.html#5800" class="Bound">f</a> <a id="5802" class="Symbol">=</a> <a id="5804" class="Symbol">(</a><a id="5805" href="Bool.html#5805" class="Bound">x</a> <a id="5807" class="Symbol">:</a> <a id="5809" href="Bool.html#5797" class="Bound">X</a><a id="5810" class="Symbol">)</a> <a id="5812" class="Symbol">→</a> <a id="5814" href="Bool.html#5800" class="Bound">f</a> <a id="5816" class="Symbol">(</a><a id="5817" href="Bool.html#5800" class="Bound">f</a> <a id="5819" href="Bool.html#5805" class="Bound">x</a><a id="5820" class="Symbol">)</a> <a id="5822" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5824" href="Bool.html#5805" class="Bound">x</a>
</pre>
For example, list reversal is an involution. Another example is boolean
negation:
<pre class="Agda"><a id="not-is-involution"></a><a id="5920" href="Bool.html#5920" data-type="is-involution not" class="Function">not-is-involution</a> <a id="5938" class="Symbol">:</a> <a id="5940" href="Bool.html#5738" data-type="(X → X) → Type" class="Function">is-involution</a> <a id="5954" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a>
<a id="5958" href="Bool.html#5920" data-type="is-involution not" class="Function">not-is-involution</a> <a id="5976" class="Symbol">=</a> <a id="5978" href="Bool.html#2675" data-type="(A : Bool → Type) → A true → A false → (b : Bool) → A b" class="Function">Bool-elim</a> <a id="5988" class="Symbol">_</a> <a id="5990" class="Symbol">(</a><a id="5991" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="5996" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a><a id="6000" class="Symbol">)</a> <a id="6002" class="Symbol">(</a><a id="6003" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6008" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a><a id="6013" class="Symbol">)</a>
</pre>
A proof without mentioning <code>is-involution</code> and without using
the eliminator is also possible, of course:
<pre class="Agda"><a id="not-is-involution&#39;"></a><a id="6132" href="Bool.html#6132" data-type="(b : Bool) → not (not b) ≡ b" class="Function">not-is-involution&#39;</a> <a id="6151" class="Symbol">:</a> <a id="6153" class="Symbol">(</a><a id="6154" href="Bool.html#6154" class="Bound">b</a> <a id="6156" class="Symbol">:</a> <a id="6158" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a><a id="6162" class="Symbol">)</a> <a id="6164" class="Symbol">→</a> <a id="6166" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="6170" class="Symbol">(</a><a id="6171" href="Bool.html#4009" data-type="Bool → Bool" class="Function">not</a> <a id="6175" href="Bool.html#6154" class="Bound">b</a><a id="6176" class="Symbol">)</a> <a id="6178" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6180" href="Bool.html#6154" class="Bound">b</a>
<a id="6182" href="Bool.html#6132" data-type="(b : Bool) → not (not b) ≡ b" class="Function">not-is-involution&#39;</a> <a id="6201" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="6207" class="Symbol">=</a> <a id="6209" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6214" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="6219" href="Bool.html#6132" data-type="(b : Bool) → not (not b) ≡ b" class="Function">not-is-involution&#39;</a> <a id="6238" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="6244" class="Symbol">=</a> <a id="6246" href="identity-type.html#620" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6251" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>
</pre>
<p>Very often we will give definitions by pattern-matching as above
instead of <code>Bool-elim</code>. But the concept of eliminator for a
type remains useful, and it is what <code>MLTT</code> (Martin-Löf Type
Theory), the foundation of our programming language Agda, uses to define
types. Types are defined by formation rules, construtors, eliminators,
and equations explaining how the constructors interact with the
eliminators. Pattern-matching can be considered as “syntax sugar” for
definitions using eliminators. Usually definitions using pattern
matching are more readable than definitions using eliminators, but they
are equivalent to definitions using eliminators.</p>
Notice that in the definition of <code>is-involution</code> we needed to
explicitly indicate the implicit argument <code>X</code> using curly
brackets. Agda allows the notation <code>∀</code> in order to be able to
omit the type <code>X</code>, provided it can be inferred automaticaly,
which it can in our situation:
<pre class="Agda"><a id="is-involution&#39;"></a><a id="7193" href="Bool.html#7193" data-type="(X → X) → Type" class="Function">is-involution&#39;</a> <a id="7208" class="Symbol">:</a> <a id="7210" class="Symbol">{</a><a id="7211" href="Bool.html#7211" class="Bound">X</a> <a id="7213" class="Symbol">:</a> <a id="7215" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="7219" class="Symbol">}</a> <a id="7221" class="Symbol">→</a> <a id="7223" class="Symbol">(</a><a id="7224" href="Bool.html#7211" class="Bound">X</a> <a id="7226" class="Symbol">→</a> <a id="7228" href="Bool.html#7211" class="Bound">X</a><a id="7229" class="Symbol">)</a> <a id="7231" class="Symbol">→</a> <a id="7233" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a>
<a id="7238" href="Bool.html#7193" data-type="(X → X) → Type" class="Function">is-involution&#39;</a> <a id="7253" href="Bool.html#7253" class="Bound">f</a> <a id="7255" class="Symbol">=</a> <a id="7257" class="Symbol">∀</a> <a id="7259" href="Bool.html#7259" class="Bound">x</a> <a id="7261" class="Symbol">→</a> <a id="7263" href="Bool.html#7253" class="Bound">f</a> <a id="7265" class="Symbol">(</a><a id="7266" href="Bool.html#7253" class="Bound">f</a> <a id="7268" href="Bool.html#7259" class="Bound">x</a><a id="7269" class="Symbol">)</a> <a id="7271" href="identity-type.html#583" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7273" href="Bool.html#7259" class="Bound">x</a>
</pre>
<h3 id="some-useful-functions">Some useful functions</h3>
<pre class="Agda"><a id="_&amp;&amp;_"></a><a id="7314" href="Bool.html#7314" data-type="Bool → Bool → Bool" class="Function Operator">_&amp;&amp;_</a> <a id="7319" class="Symbol">:</a> <a id="7321" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7326" class="Symbol">→</a> <a id="7328" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7333" class="Symbol">→</a> <a id="7335" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="7340" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="7346" href="Bool.html#7314" data-type="Bool → Bool → Bool" class="Function Operator">&amp;&amp;</a> <a id="7349" href="Bool.html#7349" class="Bound">y</a> <a id="7351" class="Symbol">=</a> <a id="7353" href="Bool.html#7349" class="Bound">y</a>
<a id="7355" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="7361" href="Bool.html#7314" data-type="Bool → Bool → Bool" class="Function Operator">&amp;&amp;</a> <a id="7364" href="Bool.html#7364" class="Bound">y</a> <a id="7366" class="Symbol">=</a> <a id="7368" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a>

<a id="_||_"></a><a id="7375" href="Bool.html#7375" data-type="Bool → Bool → Bool" class="Function Operator">_||_</a> <a id="7380" class="Symbol">:</a> <a id="7382" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7387" class="Symbol">→</a> <a id="7389" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a> <a id="7394" class="Symbol">→</a> <a id="7396" href="Bool.html#450" data-type="Set" class="Datatype">Bool</a>
<a id="7401" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>  <a id="7407" href="Bool.html#7375" data-type="Bool → Bool → Bool" class="Function Operator">||</a> <a id="7410" href="Bool.html#7410" class="Bound">y</a> <a id="7412" class="Symbol">=</a> <a id="7414" href="Bool.html#469" data-type="Bool" class="InductiveConstructor">true</a>
<a id="7419" href="Bool.html#474" data-type="Bool" class="InductiveConstructor">false</a> <a id="7425" href="Bool.html#7375" data-type="Bool → Bool → Bool" class="Function Operator">||</a> <a id="7428" href="Bool.html#7428" class="Bound">y</a> <a id="7430" class="Symbol">=</a> <a id="7432" href="Bool.html#7428" class="Bound">y</a>

<a id="7435" class="Keyword">infixr</a> <a id="7442" class="Number">20</a> <a id="7445" href="Bool.html#7375" data-type="Bool → Bool → Bool" class="Function Operator">_||_</a>
<a id="7450" class="Keyword">infixr</a> <a id="7457" class="Number">30</a> <a id="7460" href="Bool.html#7314" data-type="Bool → Bool → Bool" class="Function Operator">_&amp;&amp;_</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}

</html>
