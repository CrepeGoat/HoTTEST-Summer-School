<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module <a
href="https://program-and-modules-handbook.bham.ac.uk/webhandbooks/WebHandbooks-control-servlet?Action=getModuleDetailsList%22Advanced%20Functional%20Programming%22pgSubj=06%22Advanced%20Functional%20Programming%22pgCrse=35309%22Advanced%20Functional%20Programming%22searchTerm=002024">Advanced
Functional Programmin</a> at the <a
href="https://www.birmingham.ac.uk/schools/computer-science/index.aspx">School
of Computer Science</a> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="579" class="Symbol">{-#</a> <a id="583" class="Keyword">OPTIONS</a> <a id="591" class="Pragma">--without-K</a> <a id="603" class="Pragma">--safe</a> <a id="610" class="Symbol">#-}</a>

<a id="615" class="Keyword">module</a> <a id="622" href="binary-sums.html" class="Module">binary-sums</a> <a id="634" class="Keyword">where</a>

<a id="641" class="Keyword">open</a> <a id="646" class="Keyword">import</a> <a id="653" href="general-notation.html" class="Module">general-notation</a>
</pre>-->
<h1 id="the-binary-sum-type-former-__">The binary-sum type former
<code>_∔_</code></h1>
This is the same as (or, more precisely, <a
href="isomorphisms.html">isomorphic</a> to) the <code>Either</code> type
defined earlier (you can try this as an exercise). The notation in type
theory is <code>_+_</code>, but we want to reserve this for addition of
natural numbers, and hence we use the same symbol with a dot on top:
<pre class="Agda"><a id="1024" class="Keyword">data</a> <a id="_∔_"></a><a id="1029" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a> <a id="1033" class="Symbol">(</a><a id="1034" href="binary-sums.html#1034" class="Bound">A</a> <a id="1036" href="binary-sums.html#1036" class="Bound">B</a> <a id="1038" class="Symbol">:</a> <a id="1040" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="1044" class="Symbol">)</a> <a id="1046" class="Symbol">:</a> <a id="1048" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a> <a id="1053" class="Keyword">where</a>
 <a id="_∔_.inl"></a><a id="1060" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="1064" class="Symbol">:</a> <a id="1066" href="binary-sums.html#1034" class="Bound">A</a> <a id="1068" class="Symbol">→</a> <a id="1070" href="binary-sums.html#1034" class="Bound">A</a> <a id="1072" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="1074" href="binary-sums.html#1036" class="Bound">B</a>
 <a id="_∔_.inr"></a><a id="1077" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="1081" class="Symbol">:</a> <a id="1083" href="binary-sums.html#1036" class="Bound">B</a> <a id="1085" class="Symbol">→</a> <a id="1087" href="binary-sums.html#1034" class="Bound">A</a> <a id="1089" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="1091" href="binary-sums.html#1036" class="Bound">B</a>

<a id="1094" class="Keyword">infixr</a> <a id="1101" class="Number">20</a> <a id="1104" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a>
</pre>
<p>The type <code>A ∔ B</code> is called the coproduct of <code>A</code>
and <code>B</code>, or the sum of <code>A</code> and <code>B</code>, or
the disjoint union of <code>A</code> and <code>B</code>. The elements of
<code>A ∔ B</code> are of the form <code>inl x</code> with
<code>x : A</code> and <code>inr y</code> with <code>y : B</code>.</p>
<p>In terms of computation, we use the type <code>A ∔ B</code> when we
want to put the two types together into a single type. It is also
possible to write <code>A ∔ A</code>, in which case we will have two
copies of the type <code>A</code>, so that now every element
<code>x</code> of <code>A</code> has two different incarnations
<code>inl a</code> and <code>inr a</code> in the type
<code>A ∔ A</code>. For example, the <a href="unit-type.html">unit
type</a> <code>𝟙</code> has exactly one element, namely
<code>⋆ : 𝟙</code>, and hence the type <code>𝟙 ∔ 𝟙</code> has precisely
two elements, namely <code>inl ⋆</code> and <code>inr ⋆</code>.</p>
<h2 id="logical-disjunction-or">Logical disjunction (“or”)</h2>
<p>In terms of logic, we use the type <code>A ∔ B</code> to express “A
or B”. This is because in order for “A or B” to hold, at least one of A
and B must hold. The type <code>A → A ∔ B</code> of the function
<code>inl</code> is interpreted as saying that if A holds then so does
“A or B”, and similarly, the type of B → A ∔ B of the function
<code>inr</code> says that if B holds then so does “A or B”. In other
words, if <code>x : A</code> is a proof of <code>A</code>, then
<code>inl x : A + B</code> is a proof of <code>A or B</code>, and if
<code>y : B</code> is a proof of B, them <code>inr y : A + B</code> is a
proof of “A or B”. Here when we said “proof” we meant “program” after
the propositions-as-types and proofs-as-programs paradigm.</p>
<h2 id="logical-disjunction-in-hottuf">Logical disjunction in
HoTT/UF</h2>
<p>In HoTT/UF it useful to have an alternative disjunction operation
<code>A ∨ B</code> defined to be <code>∥ A ∔ B ∥</code> where
<code>∥_∥</code> is a certain <em>propositional truncation</em>
operation.</p>
<h2 id="elimination-principle">Elimination principle</h2>
<p>Now suppose we want to define a dependent function
<code>(z : A ∔ B) → C z</code>. How can we do that? If we have two
functions <code>f : (x : A) → C (inl x)</code> and
<code>g : (y : B) → C (inr y)</code>, then, given
<code>z : A ∔ B</code>, we can inspect whether <code>z</code> is of the
form <code>inl x</code> with <code>x : A</code> or of the form
<code>inr y</code> with <code>y : B</code>, and the respectively apply
<code>f</code> or <code>g</code> to get an element of <code>C z</code>.
This procedure is called the <em>elimination</em> principle for the type
former <code>_∔_</code> and can be written in Agda as follows:</p>
<pre class="Agda"><a id="∔-elim"></a><a id="3199" href="binary-sums.html#3199" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3206" class="Symbol">:</a> <a id="3208" class="Symbol">{</a><a id="3209" href="binary-sums.html#3209" class="Bound">A</a> <a id="3211" href="binary-sums.html#3211" class="Bound">B</a> <a id="3213" class="Symbol">:</a> <a id="3215" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3219" class="Symbol">}</a> <a id="3221" class="Symbol">(</a><a id="3222" href="binary-sums.html#3222" class="Bound">C</a> <a id="3224" class="Symbol">:</a> <a id="3226" href="binary-sums.html#3209" class="Bound">A</a> <a id="3228" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3230" href="binary-sums.html#3211" class="Bound">B</a> <a id="3232" class="Symbol">→</a> <a id="3234" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3238" class="Symbol">)</a>
       <a id="3247" class="Symbol">→</a> <a id="3249" class="Symbol">((</a><a id="3251" href="binary-sums.html#3251" class="Bound">x</a> <a id="3253" class="Symbol">:</a> <a id="3255" href="binary-sums.html#3209" class="Bound">A</a><a id="3256" class="Symbol">)</a> <a id="3258" class="Symbol">→</a> <a id="3260" href="binary-sums.html#3222" class="Bound">C</a> <a id="3262" class="Symbol">(</a><a id="3263" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3267" href="binary-sums.html#3251" class="Bound">x</a><a id="3268" class="Symbol">))</a>
       <a id="3278" class="Symbol">→</a> <a id="3280" class="Symbol">((</a><a id="3282" href="binary-sums.html#3282" class="Bound">y</a> <a id="3284" class="Symbol">:</a> <a id="3286" href="binary-sums.html#3211" class="Bound">B</a><a id="3287" class="Symbol">)</a> <a id="3289" class="Symbol">→</a> <a id="3291" href="binary-sums.html#3222" class="Bound">C</a> <a id="3293" class="Symbol">(</a><a id="3294" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3298" href="binary-sums.html#3282" class="Bound">y</a><a id="3299" class="Symbol">))</a>
       <a id="3309" class="Symbol">→</a> <a id="3311" class="Symbol">(</a><a id="3312" href="binary-sums.html#3312" class="Bound">z</a> <a id="3314" class="Symbol">:</a> <a id="3316" href="binary-sums.html#3209" class="Bound">A</a> <a id="3318" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3320" href="binary-sums.html#3211" class="Bound">B</a><a id="3321" class="Symbol">)</a> <a id="3323" class="Symbol">→</a> <a id="3325" href="binary-sums.html#3222" class="Bound">C</a> <a id="3327" href="binary-sums.html#3312" class="Bound">z</a>
<a id="3329" href="binary-sums.html#3199" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3336" href="binary-sums.html#3336" class="Bound">C</a> <a id="3338" href="binary-sums.html#3338" class="Bound">f</a> <a id="3340" href="binary-sums.html#3340" class="Bound">g</a> <a id="3342" class="Symbol">(</a><a id="3343" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3347" href="binary-sums.html#3347" class="Bound">x</a><a id="3348" class="Symbol">)</a> <a id="3350" class="Symbol">=</a> <a id="3352" href="binary-sums.html#3338" class="Bound">f</a> <a id="3354" href="binary-sums.html#3347" class="Bound">x</a>
<a id="3356" href="binary-sums.html#3199" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3363" href="binary-sums.html#3363" class="Bound">C</a> <a id="3365" href="binary-sums.html#3365" class="Bound">f</a> <a id="3367" href="binary-sums.html#3367" class="Bound">g</a> <a id="3369" class="Symbol">(</a><a id="3370" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3374" href="binary-sums.html#3374" class="Bound">y</a><a id="3375" class="Symbol">)</a> <a id="3377" class="Symbol">=</a> <a id="3379" href="binary-sums.html#3367" class="Bound">g</a> <a id="3381" href="binary-sums.html#3374" class="Bound">y</a>
</pre>
So the eliminator amounts to simply definition by cases. In terms of
logic, it says that in order to show that “for all z : A ∔ B we have
that C z holds” it is enough to show two things: (1) “for all x : A it
is the case that C (inl x) holds”, and (2) “forall y : B it is the case
that C (inr y) holds”. This is not only sufficient, but also necessary:
<pre class="Agda"><a id="3748" class="Keyword">open</a> <a id="3753" class="Keyword">import</a> <a id="3760" href="binary-products.html" class="Module">binary-products</a>

<a id="∔-split"></a><a id="3777" href="binary-sums.html#3777" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3785" class="Symbol">:</a> <a id="3787" class="Symbol">{</a><a id="3788" href="binary-sums.html#3788" class="Bound">A</a> <a id="3790" href="binary-sums.html#3790" class="Bound">B</a> <a id="3792" class="Symbol">:</a> <a id="3794" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3798" class="Symbol">}</a> <a id="3800" class="Symbol">(</a><a id="3801" href="binary-sums.html#3801" class="Bound">C</a> <a id="3803" class="Symbol">:</a> <a id="3805" href="binary-sums.html#3788" class="Bound">A</a> <a id="3807" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3809" href="binary-sums.html#3790" class="Bound">B</a> <a id="3811" class="Symbol">→</a> <a id="3813" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="3817" class="Symbol">)</a>
        <a id="3827" class="Symbol">→</a> <a id="3829" class="Symbol">((</a><a id="3831" href="binary-sums.html#3831" class="Bound">z</a> <a id="3833" class="Symbol">:</a> <a id="3835" href="binary-sums.html#3788" class="Bound">A</a> <a id="3837" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3839" href="binary-sums.html#3790" class="Bound">B</a><a id="3840" class="Symbol">)</a> <a id="3842" class="Symbol">→</a> <a id="3844" href="binary-sums.html#3801" class="Bound">C</a> <a id="3846" href="binary-sums.html#3831" class="Bound">z</a><a id="3847" class="Symbol">)</a>
        <a id="3857" class="Symbol">→</a> <a id="3859" class="Symbol">((</a><a id="3861" href="binary-sums.html#3861" class="Bound">x</a> <a id="3863" class="Symbol">:</a> <a id="3865" href="binary-sums.html#3788" class="Bound">A</a><a id="3866" class="Symbol">)</a> <a id="3868" class="Symbol">→</a> <a id="3870" href="binary-sums.html#3801" class="Bound">C</a> <a id="3872" class="Symbol">(</a><a id="3873" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3877" href="binary-sums.html#3861" class="Bound">x</a><a id="3878" class="Symbol">))</a> <a id="3881" href="binary-products.html#1027" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="3883" class="Symbol">((</a><a id="3885" href="binary-sums.html#3885" class="Bound">y</a> <a id="3887" class="Symbol">:</a> <a id="3889" href="binary-sums.html#3790" class="Bound">B</a><a id="3890" class="Symbol">)</a> <a id="3892" class="Symbol">→</a> <a id="3894" href="binary-sums.html#3801" class="Bound">C</a> <a id="3896" class="Symbol">(</a><a id="3897" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3901" href="binary-sums.html#3885" class="Bound">y</a><a id="3902" class="Symbol">))</a>
<a id="3905" href="binary-sums.html#3777" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3913" class="Symbol">{</a><a id="3914" href="binary-sums.html#3914" class="Bound">A</a><a id="3915" class="Symbol">}</a> <a id="3917" class="Symbol">{</a><a id="3918" href="binary-sums.html#3918" class="Bound">B</a><a id="3919" class="Symbol">}</a> <a id="3921" href="binary-sums.html#3921" class="Bound">C</a> <a id="3923" href="binary-sums.html#3923" class="Bound">h</a> <a id="3925" class="Symbol">=</a> <a id="3927" href="binary-sums.html#3942" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3929" href="sums.html#2879" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3931" href="binary-sums.html#3987" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a>
 <a id="3934" class="Keyword">where</a>
  <a id="3942" href="binary-sums.html#3942" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3944" class="Symbol">:</a> <a id="3946" class="Symbol">(</a><a id="3947" href="binary-sums.html#3947" class="Bound">x</a> <a id="3949" class="Symbol">:</a> <a id="3951" href="binary-sums.html#3914" class="Bound">A</a><a id="3952" class="Symbol">)</a> <a id="3954" class="Symbol">→</a> <a id="3956" href="binary-sums.html#3921" class="Bound">C</a> <a id="3958" class="Symbol">(</a><a id="3959" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3963" href="binary-sums.html#3947" class="Bound">x</a><a id="3964" class="Symbol">)</a>
  <a id="3968" href="binary-sums.html#3942" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3970" href="binary-sums.html#3970" class="Bound">x</a> <a id="3972" class="Symbol">=</a> <a id="3974" href="binary-sums.html#3923" class="Bound">h</a> <a id="3976" class="Symbol">(</a><a id="3977" href="binary-sums.html#1060" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3981" href="binary-sums.html#3970" class="Bound">x</a><a id="3982" class="Symbol">)</a>

  <a id="3987" href="binary-sums.html#3987" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="3989" class="Symbol">:</a> <a id="3991" class="Symbol">(</a><a id="3992" href="binary-sums.html#3992" class="Bound">y</a> <a id="3994" class="Symbol">:</a> <a id="3996" href="binary-sums.html#3918" class="Bound">B</a><a id="3997" class="Symbol">)</a> <a id="3999" class="Symbol">→</a> <a id="4001" href="binary-sums.html#3921" class="Bound">C</a> <a id="4003" class="Symbol">(</a><a id="4004" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4008" href="binary-sums.html#3992" class="Bound">y</a><a id="4009" class="Symbol">)</a>
  <a id="4013" href="binary-sums.html#3987" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="4015" href="binary-sums.html#4015" class="Bound">y</a> <a id="4017" class="Symbol">=</a> <a id="4019" href="binary-sums.html#3923" class="Bound">h</a> <a id="4021" class="Symbol">(</a><a id="4022" href="binary-sums.html#1077" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="4026" href="binary-sums.html#4015" class="Bound">y</a><a id="4027" class="Symbol">)</a>
</pre>
There is also a version of the eliminator in which <code>C</code>
doesn’t depend on <code>z : A ∔ B</code> and is always the same:
<pre class="Agda"><a id="∔-nondep-elim"></a><a id="4151" href="binary-sums.html#4151" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="4165" class="Symbol">:</a> <a id="4167" class="Symbol">{</a><a id="4168" href="binary-sums.html#4168" class="Bound">A</a> <a id="4170" href="binary-sums.html#4170" class="Bound">B</a> <a id="4172" href="binary-sums.html#4172" class="Bound">C</a> <a id="4174" class="Symbol">:</a> <a id="4176" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="4180" class="Symbol">}</a>
              <a id="4196" class="Symbol">→</a> <a id="4198" class="Symbol">(</a><a id="4199" href="binary-sums.html#4168" class="Bound">A</a> <a id="4201" class="Symbol">→</a> <a id="4203" href="binary-sums.html#4172" class="Bound">C</a><a id="4204" class="Symbol">)</a>
              <a id="4220" class="Symbol">→</a> <a id="4222" class="Symbol">(</a><a id="4223" href="binary-sums.html#4170" class="Bound">B</a> <a id="4225" class="Symbol">→</a> <a id="4227" href="binary-sums.html#4172" class="Bound">C</a><a id="4228" class="Symbol">)</a>
              <a id="4244" class="Symbol">→</a> <a id="4246" class="Symbol">(</a><a id="4247" href="binary-sums.html#4168" class="Bound">A</a> <a id="4249" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4251" href="binary-sums.html#4170" class="Bound">B</a> <a id="4253" class="Symbol">→</a> <a id="4255" href="binary-sums.html#4172" class="Bound">C</a><a id="4256" class="Symbol">)</a>
<a id="4258" href="binary-sums.html#4151" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="4272" class="Symbol">{</a><a id="4273" href="binary-sums.html#4273" class="Bound">A</a><a id="4274" class="Symbol">}</a> <a id="4276" class="Symbol">{</a><a id="4277" href="binary-sums.html#4277" class="Bound">B</a><a id="4278" class="Symbol">}</a> <a id="4280" class="Symbol">{</a><a id="4281" href="binary-sums.html#4281" class="Bound">C</a><a id="4282" class="Symbol">}</a> <a id="4284" class="Symbol">=</a> <a id="4286" href="binary-sums.html#3199" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="4293" class="Symbol">(λ</a> <a id="4296" href="binary-sums.html#4296" class="Bound">z</a> <a id="4298" class="Symbol">→</a> <a id="4300" href="binary-sums.html#4281" class="Bound">C</a><a id="4301" class="Symbol">)</a>
</pre>
In terms of logic, this means that in order to show that “A or B implies
C”, it is enough to show that both “A implies C” and “B implies C”. This
also can be inverted:
<pre class="Agda"><a id="∔-nondep-split"></a><a id="4483" href="binary-sums.html#4483" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4498" class="Symbol">:</a> <a id="4500" class="Symbol">{</a><a id="4501" href="binary-sums.html#4501" class="Bound">A</a> <a id="4503" href="binary-sums.html#4503" class="Bound">B</a> <a id="4505" href="binary-sums.html#4505" class="Bound">C</a> <a id="4507" class="Symbol">:</a> <a id="4509" href="general-notation.html#1072" data-type="Set₁" class="Function">Type</a><a id="4513" class="Symbol">}</a>
               <a id="4530" class="Symbol">→</a> <a id="4532" class="Symbol">(</a><a id="4533" href="binary-sums.html#4501" class="Bound">A</a> <a id="4535" href="binary-sums.html#1029" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4537" href="binary-sums.html#4503" class="Bound">B</a> <a id="4539" class="Symbol">→</a> <a id="4541" href="binary-sums.html#4505" class="Bound">C</a><a id="4542" class="Symbol">)</a>
               <a id="4559" class="Symbol">→</a> <a id="4561" class="Symbol">(</a><a id="4562" href="binary-sums.html#4501" class="Bound">A</a> <a id="4564" class="Symbol">→</a> <a id="4566" href="binary-sums.html#4505" class="Bound">C</a><a id="4567" class="Symbol">)</a> <a id="4569" href="binary-products.html#1027" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="4571" class="Symbol">(</a><a id="4572" href="binary-sums.html#4503" class="Bound">B</a> <a id="4574" class="Symbol">→</a> <a id="4576" href="binary-sums.html#4505" class="Bound">C</a><a id="4577" class="Symbol">)</a>
<a id="4579" href="binary-sums.html#4483" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4594" class="Symbol">{</a><a id="4595" href="binary-sums.html#4595" class="Bound">A</a><a id="4596" class="Symbol">}</a> <a id="4598" class="Symbol">{</a><a id="4599" href="binary-sums.html#4599" class="Bound">B</a><a id="4600" class="Symbol">}</a> <a id="4602" class="Symbol">{</a><a id="4603" href="binary-sums.html#4603" class="Bound">C</a><a id="4604" class="Symbol">}</a> <a id="4606" class="Symbol">=</a> <a id="4608" href="binary-sums.html#3777" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="4616" class="Symbol">(λ</a> <a id="4619" href="binary-sums.html#4619" class="Bound">z</a> <a id="4621" class="Symbol">→</a> <a id="4623" href="binary-sums.html#4603" class="Bound">C</a><a id="4624" class="Symbol">)</a>
</pre>
<p>In terms of logic, this means that if <code>A or B implies C</code>
then both <code>A implies C</code> and <code>B implies C</code>.</p>
<h2 id="alternative-definition-of-__">Alternative definition of
<code>_∔_</code></h2>
<p>There is <a href="binary-sums-as-sums.html">another way to define
binary sums</a> as a special case of <code>Σ</code>.</p>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
