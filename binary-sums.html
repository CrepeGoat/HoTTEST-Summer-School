<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module “Advanced Functional Programming” at
the <a
href="https://www.birmingham.ac.uk/schools/computer-science/index.aspx">School
of Computer Science</a> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="324" class="Symbol">{-#</a> <a id="328" class="Keyword">OPTIONS</a> <a id="336" class="Pragma">--without-K</a> <a id="348" class="Pragma">--safe</a> <a id="355" class="Symbol">#-}</a>

<a id="360" class="Keyword">module</a> <a id="367" href="binary-sums.html" class="Module">binary-sums</a> <a id="379" class="Keyword">where</a>

<a id="386" class="Keyword">open</a> <a id="391" class="Keyword">import</a> <a id="398" href="general-notation.html" class="Module">general-notation</a>
</pre>-->
<h1 id="the-binary-sum-type-former-__">The binary-sum type former
<code>_∔_</code></h1>
This is the same as (or, more precisely, <a
href="isomorphisms.html">isomorphic</a> to) the <code>Either</code> type
defined earlier (you can try this as an exercise). The notation in type
theory is <code>_+_</code>, but we want to reserve this for addition of
natural numbers, and hence we use the same symbol with a dot on top:
<pre class="Agda"><a id="769" class="Keyword">data</a> <a id="_∔_"></a><a id="774" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a> <a id="778" class="Symbol">(</a><a id="779" href="binary-sums.html#779" class="Bound">A</a> <a id="781" href="binary-sums.html#781" class="Bound">B</a> <a id="783" class="Symbol">:</a> <a id="785" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="789" class="Symbol">)</a> <a id="791" class="Symbol">:</a> <a id="793" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a> <a id="798" class="Keyword">where</a>
 <a id="_∔_.inl"></a><a id="805" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="809" class="Symbol">:</a> <a id="811" href="binary-sums.html#779" class="Bound">A</a> <a id="813" class="Symbol">→</a> <a id="815" href="binary-sums.html#779" class="Bound">A</a> <a id="817" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="819" href="binary-sums.html#781" class="Bound">B</a>
 <a id="_∔_.inr"></a><a id="822" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="826" class="Symbol">:</a> <a id="828" href="binary-sums.html#781" class="Bound">B</a> <a id="830" class="Symbol">→</a> <a id="832" href="binary-sums.html#779" class="Bound">A</a> <a id="834" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="836" href="binary-sums.html#781" class="Bound">B</a>

<a id="839" class="Keyword">infixr</a> <a id="846" class="Number">20</a> <a id="849" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a>
</pre>
<p>The type <code>A ∔ B</code> is called the coproduct of <code>A</code>
and <code>B</code>, or the sum of <code>A</code> and <code>B</code>, or
the disjoint union of <code>A</code> and <code>B</code>. The elements of
<code>A ∔ B</code> are of the form <code>inl x</code> with
<code>x : A</code> and <code>inr y</code> with <code>y : B</code>.</p>
<p>In terms of computation, we use the type <code>A ∔ B</code> when we
want to put the two types together into a single type. It is also
possible to write <code>A ∔ A</code>, in which case we will have two
copies of the type <code>A</code>, so that now every element
<code>x</code> of <code>A</code> has two different incarnations
<code>inl a</code> and <code>inr a</code> in the type
<code>A ∔ A</code>. For example, the <a href="unit-type.html">unit
type</a> <code>𝟙</code> has exactly one element, namely
<code>⋆ : 𝟙</code>, and hence the type <code>𝟙 ∔ 𝟙</code> has precisely
two elements, namely <code>inl ⋆</code> and <code>inr ⋆</code>.</p>
<h2 id="logical-disjunction-or">Logical disjunction (“or”)</h2>
<p>In terms of logic, we use the type <code>A ∔ B</code> to express “A
or B”. This is because in order for “A or B” to hold, at least one of A
and B must hold. The type <code>A → A ∔ B</code> of the function
<code>inl</code> is interpreted as saying that if A holds then so does
“A or B”, and similarly, the type of B → A ∔ B of the function
<code>inr</code> says that if B holds then so does “A or B”. In other
words, if <code>x : A</code> is a proof of <code>A</code>, then
<code>inl x : A + B</code> is a proof of <code>A or B</code>, and if
<code>y : B</code> is a proof of B, them <code>inr y : A + B</code> is a
proof of “A or B”. Here when we said “proof” we meant “program” after
the propositions-as-types and proofs-as-programs paradigm.</p>
<h2 id="logical-disjunction-in-hottuf">Logical disjunction in
HoTT/UF</h2>
<p>In HoTT/UF it useful to have an alternative disjunction operation
<code>A ∨ B</code> defined to be <code>∥ A ∔ B ∥</code> where
<code>∥_∥</code> is a certain <em>propositional truncation</em>
operation.</p>
<h2 id="elimination-principle">Elimination principle</h2>
<p>Now suppose we want to define a dependent function
<code>(z : A ∔ B) → C z</code>. How can we do that? If we have two
functions <code>f : (x : A) → C (inl x)</code> and
<code>g : (y : B) → C (inr y)</code>, then, given
<code>z : A ∔ B</code>, we can inspect whether <code>z</code> is of the
form <code>inl x</code> with <code>x : A</code> or of the form
<code>inr y</code> with <code>y : B</code>, and the respectively apply
<code>f</code> or <code>g</code> to get an element of <code>C z</code>.
This procedure is called the <em>elimination</em> principle for the type
former <code>_∔_</code> and can be written in Agda as follows:</p>
<pre class="Agda"><a id="∔-elim"></a><a id="2944" href="binary-sums.html#2944" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="2951" class="Symbol">:</a> <a id="2953" class="Symbol">{</a><a id="2954" href="binary-sums.html#2954" class="Bound">A</a> <a id="2956" href="binary-sums.html#2956" class="Bound">B</a> <a id="2958" class="Symbol">:</a> <a id="2960" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="2964" class="Symbol">}</a> <a id="2966" class="Symbol">(</a><a id="2967" href="binary-sums.html#2967" class="Bound">C</a> <a id="2969" class="Symbol">:</a> <a id="2971" href="binary-sums.html#2954" class="Bound">A</a> <a id="2973" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2975" href="binary-sums.html#2956" class="Bound">B</a> <a id="2977" class="Symbol">→</a> <a id="2979" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="2983" class="Symbol">)</a>
       <a id="2992" class="Symbol">→</a> <a id="2994" class="Symbol">((</a><a id="2996" href="binary-sums.html#2996" class="Bound">x</a> <a id="2998" class="Symbol">:</a> <a id="3000" href="binary-sums.html#2954" class="Bound">A</a><a id="3001" class="Symbol">)</a> <a id="3003" class="Symbol">→</a> <a id="3005" href="binary-sums.html#2967" class="Bound">C</a> <a id="3007" class="Symbol">(</a><a id="3008" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3012" href="binary-sums.html#2996" class="Bound">x</a><a id="3013" class="Symbol">))</a>
       <a id="3023" class="Symbol">→</a> <a id="3025" class="Symbol">((</a><a id="3027" href="binary-sums.html#3027" class="Bound">y</a> <a id="3029" class="Symbol">:</a> <a id="3031" href="binary-sums.html#2956" class="Bound">B</a><a id="3032" class="Symbol">)</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="binary-sums.html#2967" class="Bound">C</a> <a id="3038" class="Symbol">(</a><a id="3039" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3043" href="binary-sums.html#3027" class="Bound">y</a><a id="3044" class="Symbol">))</a>
       <a id="3054" class="Symbol">→</a> <a id="3056" class="Symbol">(</a><a id="3057" href="binary-sums.html#3057" class="Bound">z</a> <a id="3059" class="Symbol">:</a> <a id="3061" href="binary-sums.html#2954" class="Bound">A</a> <a id="3063" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3065" href="binary-sums.html#2956" class="Bound">B</a><a id="3066" class="Symbol">)</a> <a id="3068" class="Symbol">→</a> <a id="3070" href="binary-sums.html#2967" class="Bound">C</a> <a id="3072" href="binary-sums.html#3057" class="Bound">z</a>
<a id="3074" href="binary-sums.html#2944" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3081" href="binary-sums.html#3081" class="Bound">C</a> <a id="3083" href="binary-sums.html#3083" class="Bound">f</a> <a id="3085" href="binary-sums.html#3085" class="Bound">g</a> <a id="3087" class="Symbol">(</a><a id="3088" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3092" href="binary-sums.html#3092" class="Bound">x</a><a id="3093" class="Symbol">)</a> <a id="3095" class="Symbol">=</a> <a id="3097" href="binary-sums.html#3083" class="Bound">f</a> <a id="3099" href="binary-sums.html#3092" class="Bound">x</a>
<a id="3101" href="binary-sums.html#2944" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3108" href="binary-sums.html#3108" class="Bound">C</a> <a id="3110" href="binary-sums.html#3110" class="Bound">f</a> <a id="3112" href="binary-sums.html#3112" class="Bound">g</a> <a id="3114" class="Symbol">(</a><a id="3115" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3119" href="binary-sums.html#3119" class="Bound">y</a><a id="3120" class="Symbol">)</a> <a id="3122" class="Symbol">=</a> <a id="3124" href="binary-sums.html#3112" class="Bound">g</a> <a id="3126" href="binary-sums.html#3119" class="Bound">y</a>
</pre>
So the eliminator amounts to simply definition by cases. In terms of
logic, it says that in order to show that “for all z : A ∔ B we have
that C z holds” it is enough to show two things: (1) “for all x : A it
is the case that C (inl x) holds”, and (2) “forall y : B it is the case
that C (inr y) holds”. This is not only sufficient, but also necessary:
<pre class="Agda"><a id="3493" class="Keyword">open</a> <a id="3498" class="Keyword">import</a> <a id="3505" href="binary-products.html" class="Module">binary-products</a>

<a id="∔-split"></a><a id="3522" href="binary-sums.html#3522" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3530" class="Symbol">:</a> <a id="3532" class="Symbol">{</a><a id="3533" href="binary-sums.html#3533" class="Bound">A</a> <a id="3535" href="binary-sums.html#3535" class="Bound">B</a> <a id="3537" class="Symbol">:</a> <a id="3539" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3543" class="Symbol">}</a> <a id="3545" class="Symbol">(</a><a id="3546" href="binary-sums.html#3546" class="Bound">C</a> <a id="3548" class="Symbol">:</a> <a id="3550" href="binary-sums.html#3533" class="Bound">A</a> <a id="3552" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3554" href="binary-sums.html#3535" class="Bound">B</a> <a id="3556" class="Symbol">→</a> <a id="3558" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3562" class="Symbol">)</a>
        <a id="3572" class="Symbol">→</a> <a id="3574" class="Symbol">((</a><a id="3576" href="binary-sums.html#3576" class="Bound">z</a> <a id="3578" class="Symbol">:</a> <a id="3580" href="binary-sums.html#3533" class="Bound">A</a> <a id="3582" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3584" href="binary-sums.html#3535" class="Bound">B</a><a id="3585" class="Symbol">)</a> <a id="3587" class="Symbol">→</a> <a id="3589" href="binary-sums.html#3546" class="Bound">C</a> <a id="3591" href="binary-sums.html#3576" class="Bound">z</a><a id="3592" class="Symbol">)</a>
        <a id="3602" class="Symbol">→</a> <a id="3604" class="Symbol">((</a><a id="3606" href="binary-sums.html#3606" class="Bound">x</a> <a id="3608" class="Symbol">:</a> <a id="3610" href="binary-sums.html#3533" class="Bound">A</a><a id="3611" class="Symbol">)</a> <a id="3613" class="Symbol">→</a> <a id="3615" href="binary-sums.html#3546" class="Bound">C</a> <a id="3617" class="Symbol">(</a><a id="3618" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3622" href="binary-sums.html#3606" class="Bound">x</a><a id="3623" class="Symbol">))</a> <a id="3626" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="3628" class="Symbol">((</a><a id="3630" href="binary-sums.html#3630" class="Bound">y</a> <a id="3632" class="Symbol">:</a> <a id="3634" href="binary-sums.html#3535" class="Bound">B</a><a id="3635" class="Symbol">)</a> <a id="3637" class="Symbol">→</a> <a id="3639" href="binary-sums.html#3546" class="Bound">C</a> <a id="3641" class="Symbol">(</a><a id="3642" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3646" href="binary-sums.html#3630" class="Bound">y</a><a id="3647" class="Symbol">))</a>
<a id="3650" href="binary-sums.html#3522" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3658" class="Symbol">{</a><a id="3659" href="binary-sums.html#3659" class="Bound">A</a><a id="3660" class="Symbol">}</a> <a id="3662" class="Symbol">{</a><a id="3663" href="binary-sums.html#3663" class="Bound">B</a><a id="3664" class="Symbol">}</a> <a id="3666" href="binary-sums.html#3666" class="Bound">C</a> <a id="3668" href="binary-sums.html#3668" class="Bound">h</a> <a id="3670" class="Symbol">=</a> <a id="3672" href="binary-sums.html#3687" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3674" href="sums.html#2624" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3676" href="binary-sums.html#3732" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a>
 <a id="3679" class="Keyword">where</a>
  <a id="3687" href="binary-sums.html#3687" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3689" class="Symbol">:</a> <a id="3691" class="Symbol">(</a><a id="3692" href="binary-sums.html#3692" class="Bound">x</a> <a id="3694" class="Symbol">:</a> <a id="3696" href="binary-sums.html#3659" class="Bound">A</a><a id="3697" class="Symbol">)</a> <a id="3699" class="Symbol">→</a> <a id="3701" href="binary-sums.html#3666" class="Bound">C</a> <a id="3703" class="Symbol">(</a><a id="3704" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3708" href="binary-sums.html#3692" class="Bound">x</a><a id="3709" class="Symbol">)</a>
  <a id="3713" href="binary-sums.html#3687" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3715" href="binary-sums.html#3715" class="Bound">x</a> <a id="3717" class="Symbol">=</a> <a id="3719" href="binary-sums.html#3668" class="Bound">h</a> <a id="3721" class="Symbol">(</a><a id="3722" href="binary-sums.html#805" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3726" href="binary-sums.html#3715" class="Bound">x</a><a id="3727" class="Symbol">)</a>

  <a id="3732" href="binary-sums.html#3732" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="3734" class="Symbol">:</a> <a id="3736" class="Symbol">(</a><a id="3737" href="binary-sums.html#3737" class="Bound">y</a> <a id="3739" class="Symbol">:</a> <a id="3741" href="binary-sums.html#3663" class="Bound">B</a><a id="3742" class="Symbol">)</a> <a id="3744" class="Symbol">→</a> <a id="3746" href="binary-sums.html#3666" class="Bound">C</a> <a id="3748" class="Symbol">(</a><a id="3749" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3753" href="binary-sums.html#3737" class="Bound">y</a><a id="3754" class="Symbol">)</a>
  <a id="3758" href="binary-sums.html#3732" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="3760" href="binary-sums.html#3760" class="Bound">y</a> <a id="3762" class="Symbol">=</a> <a id="3764" href="binary-sums.html#3668" class="Bound">h</a> <a id="3766" class="Symbol">(</a><a id="3767" href="binary-sums.html#822" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3771" href="binary-sums.html#3760" class="Bound">y</a><a id="3772" class="Symbol">)</a>
</pre>
There is also a version of the eliminator in which <code>C</code>
doesn’t depend on <code>z : A ∔ B</code> and is always the same:
<pre class="Agda"><a id="∔-nondep-elim"></a><a id="3896" href="binary-sums.html#3896" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="3910" class="Symbol">:</a> <a id="3912" class="Symbol">{</a><a id="3913" href="binary-sums.html#3913" class="Bound">A</a> <a id="3915" href="binary-sums.html#3915" class="Bound">B</a> <a id="3917" href="binary-sums.html#3917" class="Bound">C</a> <a id="3919" class="Symbol">:</a> <a id="3921" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="3925" class="Symbol">}</a>
              <a id="3941" class="Symbol">→</a> <a id="3943" class="Symbol">(</a><a id="3944" href="binary-sums.html#3913" class="Bound">A</a> <a id="3946" class="Symbol">→</a> <a id="3948" href="binary-sums.html#3917" class="Bound">C</a><a id="3949" class="Symbol">)</a>
              <a id="3965" class="Symbol">→</a> <a id="3967" class="Symbol">(</a><a id="3968" href="binary-sums.html#3915" class="Bound">B</a> <a id="3970" class="Symbol">→</a> <a id="3972" href="binary-sums.html#3917" class="Bound">C</a><a id="3973" class="Symbol">)</a>
              <a id="3989" class="Symbol">→</a> <a id="3991" class="Symbol">(</a><a id="3992" href="binary-sums.html#3913" class="Bound">A</a> <a id="3994" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3996" href="binary-sums.html#3915" class="Bound">B</a> <a id="3998" class="Symbol">→</a> <a id="4000" href="binary-sums.html#3917" class="Bound">C</a><a id="4001" class="Symbol">)</a>
<a id="4003" href="binary-sums.html#3896" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="4017" class="Symbol">{</a><a id="4018" href="binary-sums.html#4018" class="Bound">A</a><a id="4019" class="Symbol">}</a> <a id="4021" class="Symbol">{</a><a id="4022" href="binary-sums.html#4022" class="Bound">B</a><a id="4023" class="Symbol">}</a> <a id="4025" class="Symbol">{</a><a id="4026" href="binary-sums.html#4026" class="Bound">C</a><a id="4027" class="Symbol">}</a> <a id="4029" class="Symbol">=</a> <a id="4031" href="binary-sums.html#2944" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="4038" class="Symbol">(λ</a> <a id="4041" href="binary-sums.html#4041" class="Bound">z</a> <a id="4043" class="Symbol">→</a> <a id="4045" href="binary-sums.html#4026" class="Bound">C</a><a id="4046" class="Symbol">)</a>
</pre>
In terms of logic, this means that in order to show that “A or B implies
C”, it is enough to show that both “A implies C” and “B implies C”. This
also can be inverted:
<pre class="Agda"><a id="∔-nondep-split"></a><a id="4228" href="binary-sums.html#4228" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4243" class="Symbol">:</a> <a id="4245" class="Symbol">{</a><a id="4246" href="binary-sums.html#4246" class="Bound">A</a> <a id="4248" href="binary-sums.html#4248" class="Bound">B</a> <a id="4250" href="binary-sums.html#4250" class="Bound">C</a> <a id="4252" class="Symbol">:</a> <a id="4254" href="general-notation.html#817" data-type="Set₁" class="Function">Type</a><a id="4258" class="Symbol">}</a>
               <a id="4275" class="Symbol">→</a> <a id="4277" class="Symbol">(</a><a id="4278" href="binary-sums.html#4246" class="Bound">A</a> <a id="4280" href="binary-sums.html#774" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4282" href="binary-sums.html#4248" class="Bound">B</a> <a id="4284" class="Symbol">→</a> <a id="4286" href="binary-sums.html#4250" class="Bound">C</a><a id="4287" class="Symbol">)</a>
               <a id="4304" class="Symbol">→</a> <a id="4306" class="Symbol">(</a><a id="4307" href="binary-sums.html#4246" class="Bound">A</a> <a id="4309" class="Symbol">→</a> <a id="4311" href="binary-sums.html#4250" class="Bound">C</a><a id="4312" class="Symbol">)</a> <a id="4314" href="binary-products.html#772" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="4316" class="Symbol">(</a><a id="4317" href="binary-sums.html#4248" class="Bound">B</a> <a id="4319" class="Symbol">→</a> <a id="4321" href="binary-sums.html#4250" class="Bound">C</a><a id="4322" class="Symbol">)</a>
<a id="4324" href="binary-sums.html#4228" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4339" class="Symbol">{</a><a id="4340" href="binary-sums.html#4340" class="Bound">A</a><a id="4341" class="Symbol">}</a> <a id="4343" class="Symbol">{</a><a id="4344" href="binary-sums.html#4344" class="Bound">B</a><a id="4345" class="Symbol">}</a> <a id="4347" class="Symbol">{</a><a id="4348" href="binary-sums.html#4348" class="Bound">C</a><a id="4349" class="Symbol">}</a> <a id="4351" class="Symbol">=</a> <a id="4353" href="binary-sums.html#3522" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="4361" class="Symbol">(λ</a> <a id="4364" href="binary-sums.html#4364" class="Bound">z</a> <a id="4366" class="Symbol">→</a> <a id="4368" href="binary-sums.html#4348" class="Bound">C</a><a id="4369" class="Symbol">)</a>
</pre>
<p>In terms of logic, this means that if <code>A or B implies C</code>
then both <code>A implies C</code> and <code>B implies C</code>.</p>
<h2 id="alternative-definition-of-__">Alternative definition of
<code>_∔_</code></h2>
<p>There is <a href="binary-sums-as-sums.html">another way to define
binary sums</a> as a special case of <code>Σ</code>.</p>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
