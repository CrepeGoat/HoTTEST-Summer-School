<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p>Martin Escardo. Notes originally written for the module “Advanced
Functional Programming” at the School of Computer Science of the
University of Birmingham, UK.</p>
<!--
<pre class="Agda"><a id="178" class="Symbol">{-#</a> <a id="182" class="Keyword">OPTIONS</a> <a id="190" class="Pragma">--without-K</a> <a id="202" class="Pragma">--safe</a> <a id="209" class="Symbol">#-}</a>

<a id="214" class="Keyword">module</a> <a id="221" href="binary-sums.html" class="Module">binary-sums</a> <a id="233" class="Keyword">where</a>

<a id="240" class="Keyword">open</a> <a id="245" class="Keyword">import</a> <a id="252" href="general-notation.html" class="Module">general-notation</a>
</pre>-->
<h1 id="the-binary-sum-type-former-__">The binary-sum type former
<code>_∔_</code></h1>
This is the same as (or, more precisely, <a
href="isomorphisms.html">isomorphic</a> to) the <code>Either</code> type
defined earlier (you can try this as an exercise). The notation in type
theory is <code>_+_</code>, but we want to reserve this for addition of
natural numbers, and hence we use the same symbol with a dot on top:
<pre class="Agda"><a id="623" class="Keyword">data</a> <a id="_∔_"></a><a id="628" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a> <a id="632" class="Symbol">(</a><a id="633" href="binary-sums.html#633" class="Bound">A</a> <a id="635" href="binary-sums.html#635" class="Bound">B</a> <a id="637" class="Symbol">:</a> <a id="639" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="643" class="Symbol">)</a> <a id="645" class="Symbol">:</a> <a id="647" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a> <a id="652" class="Keyword">where</a>
 <a id="_∔_.inl"></a><a id="659" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="663" class="Symbol">:</a> <a id="665" href="binary-sums.html#633" class="Bound">A</a> <a id="667" class="Symbol">→</a> <a id="669" href="binary-sums.html#633" class="Bound">A</a> <a id="671" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="673" href="binary-sums.html#635" class="Bound">B</a>
 <a id="_∔_.inr"></a><a id="676" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="680" class="Symbol">:</a> <a id="682" href="binary-sums.html#635" class="Bound">B</a> <a id="684" class="Symbol">→</a> <a id="686" href="binary-sums.html#633" class="Bound">A</a> <a id="688" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="690" href="binary-sums.html#635" class="Bound">B</a>

<a id="693" class="Keyword">infixr</a> <a id="700" class="Number">20</a> <a id="703" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">_∔_</a>
</pre>
<p>The type <code>A ∔ B</code> is called the coproduct of <code>A</code>
and <code>B</code>, or the sum of <code>A</code> and <code>B</code>, or
the disjoint union of <code>A</code> and <code>B</code>. The elements of
<code>A ∔ B</code> are of the form <code>inl x</code> with
<code>x : A</code> and <code>inr y</code> with <code>y : B</code>.</p>
<p>In terms of computation, we use the type <code>A ∔ B</code> when we
want to put the two types together into a single type. It is also
possible to write <code>A ∔ A</code>, in which case we will have two
copies of the type <code>A</code>, so that now every element
<code>x</code> of <code>A</code> has two different incarnations
<code>inl a</code> and <code>inr a</code> in the type
<code>A ∔ A</code>. For example, the <a href="unit-type.html">unit
type</a> <code>𝟙</code> has exactly one element, namely
<code>⋆ : 𝟙</code>, and hence the type <code>𝟙 ∔ 𝟙</code> has precisely
two elements, namely <code>inl ⋆</code> and <code>inr ⋆</code>.</p>
<h2 id="logical-disjunction-or">Logical disjunction (“or”)</h2>
<p>In terms of logic, we use the type <code>A ∔ B</code> to express “A
or B”. This is because in order for “A or B” to hold, at least one of A
and B must hold. The type <code>A → A ∔ B</code> of the function
<code>inl</code> is interpreted as saying that if A holds then so does
“A or B”, and similarly, the type of B → A ∔ B of the function
<code>inr</code> says that if B holds then so does “A or B”. In other
words, if <code>x : A</code> is a proof of <code>A</code>, then
<code>inl x : A + B</code> is a proof of <code>A or B</code>, and if
<code>y : B</code> is a proof of B, them <code>inr y : A + B</code> is a
proof of “A or B”. Here when we said “proof” we meant “program” after
the propositions-as-types and proofs-as-programs paradigm.</p>
<h2 id="logical-disjunction-in-hottuf">Logical disjunction in
HoTT/UF</h2>
<p>In HoTT/UF it useful to have an alternative disjunction operation
<code>A ∨ B</code> defined to be <code>∥ A ∔ B ∥</code> where
<code>∥_∥</code> is a certain <em>propositional truncation</em>
operation.</p>
<h2 id="elimination-principle">Elimination principle</h2>
<p>Now suppose we want to define a dependent function
<code>(z : A ∔ B) → C z</code>. How can we do that? If we have two
functions <code>f : (x : A) → C (inl x)</code> and
<code>g : (y : B) → C (inr y)</code>, then, given
<code>z : A ∔ B</code>, we can inspect whether <code>z</code> is of the
form <code>inl x</code> with <code>x : A</code> or of the form
<code>inr y</code> with <code>y : B</code>, and the respectively apply
<code>f</code> or <code>g</code> to get an element of <code>C z</code>.
This procedure is called the <em>elimination</em> principle for the type
former <code>_∔_</code> and can be written in Agda as follows:</p>
<pre class="Agda"><a id="∔-elim"></a><a id="2798" href="binary-sums.html#2798" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="2805" class="Symbol">:</a> <a id="2807" class="Symbol">{</a><a id="2808" href="binary-sums.html#2808" class="Bound">A</a> <a id="2810" href="binary-sums.html#2810" class="Bound">B</a> <a id="2812" class="Symbol">:</a> <a id="2814" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2818" class="Symbol">}</a> <a id="2820" class="Symbol">(</a><a id="2821" href="binary-sums.html#2821" class="Bound">C</a> <a id="2823" class="Symbol">:</a> <a id="2825" href="binary-sums.html#2808" class="Bound">A</a> <a id="2827" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2829" href="binary-sums.html#2810" class="Bound">B</a> <a id="2831" class="Symbol">→</a> <a id="2833" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="2837" class="Symbol">)</a>
       <a id="2846" class="Symbol">→</a> <a id="2848" class="Symbol">((</a><a id="2850" href="binary-sums.html#2850" class="Bound">x</a> <a id="2852" class="Symbol">:</a> <a id="2854" href="binary-sums.html#2808" class="Bound">A</a><a id="2855" class="Symbol">)</a> <a id="2857" class="Symbol">→</a> <a id="2859" href="binary-sums.html#2821" class="Bound">C</a> <a id="2861" class="Symbol">(</a><a id="2862" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2866" href="binary-sums.html#2850" class="Bound">x</a><a id="2867" class="Symbol">))</a>
       <a id="2877" class="Symbol">→</a> <a id="2879" class="Symbol">((</a><a id="2881" href="binary-sums.html#2881" class="Bound">y</a> <a id="2883" class="Symbol">:</a> <a id="2885" href="binary-sums.html#2810" class="Bound">B</a><a id="2886" class="Symbol">)</a> <a id="2888" class="Symbol">→</a> <a id="2890" href="binary-sums.html#2821" class="Bound">C</a> <a id="2892" class="Symbol">(</a><a id="2893" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2897" href="binary-sums.html#2881" class="Bound">y</a><a id="2898" class="Symbol">))</a>
       <a id="2908" class="Symbol">→</a> <a id="2910" class="Symbol">(</a><a id="2911" href="binary-sums.html#2911" class="Bound">z</a> <a id="2913" class="Symbol">:</a> <a id="2915" href="binary-sums.html#2808" class="Bound">A</a> <a id="2917" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="2919" href="binary-sums.html#2810" class="Bound">B</a><a id="2920" class="Symbol">)</a> <a id="2922" class="Symbol">→</a> <a id="2924" href="binary-sums.html#2821" class="Bound">C</a> <a id="2926" href="binary-sums.html#2911" class="Bound">z</a>
<a id="2928" href="binary-sums.html#2798" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="2935" href="binary-sums.html#2935" class="Bound">C</a> <a id="2937" href="binary-sums.html#2937" class="Bound">f</a> <a id="2939" href="binary-sums.html#2939" class="Bound">g</a> <a id="2941" class="Symbol">(</a><a id="2942" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="2946" href="binary-sums.html#2946" class="Bound">x</a><a id="2947" class="Symbol">)</a> <a id="2949" class="Symbol">=</a> <a id="2951" href="binary-sums.html#2937" class="Bound">f</a> <a id="2953" href="binary-sums.html#2946" class="Bound">x</a>
<a id="2955" href="binary-sums.html#2798" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="2962" href="binary-sums.html#2962" class="Bound">C</a> <a id="2964" href="binary-sums.html#2964" class="Bound">f</a> <a id="2966" href="binary-sums.html#2966" class="Bound">g</a> <a id="2968" class="Symbol">(</a><a id="2969" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="2973" href="binary-sums.html#2973" class="Bound">y</a><a id="2974" class="Symbol">)</a> <a id="2976" class="Symbol">=</a> <a id="2978" href="binary-sums.html#2966" class="Bound">g</a> <a id="2980" href="binary-sums.html#2973" class="Bound">y</a>
</pre>
So the eliminator amounts to simply definition by cases. In terms of
logic, it says that in order to show that “for all z : A ∔ B we have
that C z holds” it is enough to show two things: (1) “for all x : A it
is the case that C (inl x) holds”, and (2) “forall y : B it is the case
that C (inr y) holds”. This is not only sufficient, but also necessary:
<pre class="Agda"><a id="3347" class="Keyword">open</a> <a id="3352" class="Keyword">import</a> <a id="3359" href="binary-products.html" class="Module">binary-products</a>

<a id="∔-split"></a><a id="3376" href="binary-sums.html#3376" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3384" class="Symbol">:</a> <a id="3386" class="Symbol">{</a><a id="3387" href="binary-sums.html#3387" class="Bound">A</a> <a id="3389" href="binary-sums.html#3389" class="Bound">B</a> <a id="3391" class="Symbol">:</a> <a id="3393" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3397" class="Symbol">}</a> <a id="3399" class="Symbol">(</a><a id="3400" href="binary-sums.html#3400" class="Bound">C</a> <a id="3402" class="Symbol">:</a> <a id="3404" href="binary-sums.html#3387" class="Bound">A</a> <a id="3406" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3408" href="binary-sums.html#3389" class="Bound">B</a> <a id="3410" class="Symbol">→</a> <a id="3412" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3416" class="Symbol">)</a>
        <a id="3426" class="Symbol">→</a> <a id="3428" class="Symbol">((</a><a id="3430" href="binary-sums.html#3430" class="Bound">z</a> <a id="3432" class="Symbol">:</a> <a id="3434" href="binary-sums.html#3387" class="Bound">A</a> <a id="3436" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3438" href="binary-sums.html#3389" class="Bound">B</a><a id="3439" class="Symbol">)</a> <a id="3441" class="Symbol">→</a> <a id="3443" href="binary-sums.html#3400" class="Bound">C</a> <a id="3445" href="binary-sums.html#3430" class="Bound">z</a><a id="3446" class="Symbol">)</a>
        <a id="3456" class="Symbol">→</a> <a id="3458" class="Symbol">((</a><a id="3460" href="binary-sums.html#3460" class="Bound">x</a> <a id="3462" class="Symbol">:</a> <a id="3464" href="binary-sums.html#3387" class="Bound">A</a><a id="3465" class="Symbol">)</a> <a id="3467" class="Symbol">→</a> <a id="3469" href="binary-sums.html#3400" class="Bound">C</a> <a id="3471" class="Symbol">(</a><a id="3472" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3476" href="binary-sums.html#3460" class="Bound">x</a><a id="3477" class="Symbol">))</a> <a id="3480" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="3482" class="Symbol">((</a><a id="3484" href="binary-sums.html#3484" class="Bound">y</a> <a id="3486" class="Symbol">:</a> <a id="3488" href="binary-sums.html#3389" class="Bound">B</a><a id="3489" class="Symbol">)</a> <a id="3491" class="Symbol">→</a> <a id="3493" href="binary-sums.html#3400" class="Bound">C</a> <a id="3495" class="Symbol">(</a><a id="3496" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3500" href="binary-sums.html#3484" class="Bound">y</a><a id="3501" class="Symbol">))</a>
<a id="3504" href="binary-sums.html#3376" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="3512" class="Symbol">{</a><a id="3513" href="binary-sums.html#3513" class="Bound">A</a><a id="3514" class="Symbol">}</a> <a id="3516" class="Symbol">{</a><a id="3517" href="binary-sums.html#3517" class="Bound">B</a><a id="3518" class="Symbol">}</a> <a id="3520" href="binary-sums.html#3520" class="Bound">C</a> <a id="3522" href="binary-sums.html#3522" class="Bound">h</a> <a id="3524" class="Symbol">=</a> <a id="3526" href="binary-sums.html#3541" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3528" href="sums.html#2478" data-type="(fst : A) (snd : B fst) → Σ B" class="InductiveConstructor Operator">,</a> <a id="3530" href="binary-sums.html#3586" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a>
 <a id="3533" class="Keyword">where</a>
  <a id="3541" href="binary-sums.html#3541" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3543" class="Symbol">:</a> <a id="3545" class="Symbol">(</a><a id="3546" href="binary-sums.html#3546" class="Bound">x</a> <a id="3548" class="Symbol">:</a> <a id="3550" href="binary-sums.html#3513" class="Bound">A</a><a id="3551" class="Symbol">)</a> <a id="3553" class="Symbol">→</a> <a id="3555" href="binary-sums.html#3520" class="Bound">C</a> <a id="3557" class="Symbol">(</a><a id="3558" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3562" href="binary-sums.html#3546" class="Bound">x</a><a id="3563" class="Symbol">)</a>
  <a id="3567" href="binary-sums.html#3541" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (x : A) → C (inl x)" class="Function">f</a> <a id="3569" href="binary-sums.html#3569" class="Bound">x</a> <a id="3571" class="Symbol">=</a> <a id="3573" href="binary-sums.html#3522" class="Bound">h</a> <a id="3575" class="Symbol">(</a><a id="3576" href="binary-sums.html#659" data-type="A → A ∔ B" class="InductiveConstructor">inl</a> <a id="3580" href="binary-sums.html#3569" class="Bound">x</a><a id="3581" class="Symbol">)</a>

  <a id="3586" href="binary-sums.html#3586" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="3588" class="Symbol">:</a> <a id="3590" class="Symbol">(</a><a id="3591" href="binary-sums.html#3591" class="Bound">y</a> <a id="3593" class="Symbol">:</a> <a id="3595" href="binary-sums.html#3517" class="Bound">B</a><a id="3596" class="Symbol">)</a> <a id="3598" class="Symbol">→</a> <a id="3600" href="binary-sums.html#3520" class="Bound">C</a> <a id="3602" class="Symbol">(</a><a id="3603" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3607" href="binary-sums.html#3591" class="Bound">y</a><a id="3608" class="Symbol">)</a>
  <a id="3612" href="binary-sums.html#3586" data-type="(C : A ∔ B → Type) → ((z : A ∔ B) → C z) → (y : B) → C (inr y)" class="Function">g</a> <a id="3614" href="binary-sums.html#3614" class="Bound">y</a> <a id="3616" class="Symbol">=</a> <a id="3618" href="binary-sums.html#3522" class="Bound">h</a> <a id="3620" class="Symbol">(</a><a id="3621" href="binary-sums.html#676" data-type="B → A ∔ B" class="InductiveConstructor">inr</a> <a id="3625" href="binary-sums.html#3614" class="Bound">y</a><a id="3626" class="Symbol">)</a>
</pre>
There is also a version of the eliminator in which <code>C</code>
doesn’t depend on <code>z : A ∔ B</code> and is always the same:
<pre class="Agda"><a id="∔-nondep-elim"></a><a id="3750" href="binary-sums.html#3750" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="3764" class="Symbol">:</a> <a id="3766" class="Symbol">{</a><a id="3767" href="binary-sums.html#3767" class="Bound">A</a> <a id="3769" href="binary-sums.html#3769" class="Bound">B</a> <a id="3771" href="binary-sums.html#3771" class="Bound">C</a> <a id="3773" class="Symbol">:</a> <a id="3775" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="3779" class="Symbol">}</a>
              <a id="3795" class="Symbol">→</a> <a id="3797" class="Symbol">(</a><a id="3798" href="binary-sums.html#3767" class="Bound">A</a> <a id="3800" class="Symbol">→</a> <a id="3802" href="binary-sums.html#3771" class="Bound">C</a><a id="3803" class="Symbol">)</a>
              <a id="3819" class="Symbol">→</a> <a id="3821" class="Symbol">(</a><a id="3822" href="binary-sums.html#3769" class="Bound">B</a> <a id="3824" class="Symbol">→</a> <a id="3826" href="binary-sums.html#3771" class="Bound">C</a><a id="3827" class="Symbol">)</a>
              <a id="3843" class="Symbol">→</a> <a id="3845" class="Symbol">(</a><a id="3846" href="binary-sums.html#3767" class="Bound">A</a> <a id="3848" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="3850" href="binary-sums.html#3769" class="Bound">B</a> <a id="3852" class="Symbol">→</a> <a id="3854" href="binary-sums.html#3771" class="Bound">C</a><a id="3855" class="Symbol">)</a>
<a id="3857" href="binary-sums.html#3750" data-type="(A → C) → (B → C) → A ∔ B → C" class="Function">∔-nondep-elim</a> <a id="3871" class="Symbol">{</a><a id="3872" href="binary-sums.html#3872" class="Bound">A</a><a id="3873" class="Symbol">}</a> <a id="3875" class="Symbol">{</a><a id="3876" href="binary-sums.html#3876" class="Bound">B</a><a id="3877" class="Symbol">}</a> <a id="3879" class="Symbol">{</a><a id="3880" href="binary-sums.html#3880" class="Bound">C</a><a id="3881" class="Symbol">}</a> <a id="3883" class="Symbol">=</a> <a id="3885" href="binary-sums.html#2798" data-type="(C : A ∔ B → Type) →
((x : A) → C (inl x)) → ((y : B) → C (inr y)) → (z : A ∔ B) → C z" class="Function">∔-elim</a> <a id="3892" class="Symbol">(λ</a> <a id="3895" href="binary-sums.html#3895" class="Bound">z</a> <a id="3897" class="Symbol">→</a> <a id="3899" href="binary-sums.html#3880" class="Bound">C</a><a id="3900" class="Symbol">)</a>
</pre>
In terms of logic, this means that in order to show that “A or B implies
C”, it is enough to show that both “A implies C” and “B implies C”. This
also can be inverted:
<pre class="Agda"><a id="∔-nondep-split"></a><a id="4082" href="binary-sums.html#4082" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4097" class="Symbol">:</a> <a id="4099" class="Symbol">{</a><a id="4100" href="binary-sums.html#4100" class="Bound">A</a> <a id="4102" href="binary-sums.html#4102" class="Bound">B</a> <a id="4104" href="binary-sums.html#4104" class="Bound">C</a> <a id="4106" class="Symbol">:</a> <a id="4108" href="general-notation.html#671" data-type="Set₁" class="Function">Type</a><a id="4112" class="Symbol">}</a>
               <a id="4129" class="Symbol">→</a> <a id="4131" class="Symbol">(</a><a id="4132" href="binary-sums.html#4100" class="Bound">A</a> <a id="4134" href="binary-sums.html#628" data-type="Type → Type → Set" class="Datatype Operator">∔</a> <a id="4136" href="binary-sums.html#4102" class="Bound">B</a> <a id="4138" class="Symbol">→</a> <a id="4140" href="binary-sums.html#4104" class="Bound">C</a><a id="4141" class="Symbol">)</a>
               <a id="4158" class="Symbol">→</a> <a id="4160" class="Symbol">(</a><a id="4161" href="binary-sums.html#4100" class="Bound">A</a> <a id="4163" class="Symbol">→</a> <a id="4165" href="binary-sums.html#4104" class="Bound">C</a><a id="4166" class="Symbol">)</a> <a id="4168" href="binary-products.html#626" data-type="Type → Type → Type" class="Function Operator">×</a> <a id="4170" class="Symbol">(</a><a id="4171" href="binary-sums.html#4102" class="Bound">B</a> <a id="4173" class="Symbol">→</a> <a id="4175" href="binary-sums.html#4104" class="Bound">C</a><a id="4176" class="Symbol">)</a>
<a id="4178" href="binary-sums.html#4082" data-type="(A ∔ B → C) → (A → C) × (B → C)" class="Function">∔-nondep-split</a> <a id="4193" class="Symbol">{</a><a id="4194" href="binary-sums.html#4194" class="Bound">A</a><a id="4195" class="Symbol">}</a> <a id="4197" class="Symbol">{</a><a id="4198" href="binary-sums.html#4198" class="Bound">B</a><a id="4199" class="Symbol">}</a> <a id="4201" class="Symbol">{</a><a id="4202" href="binary-sums.html#4202" class="Bound">C</a><a id="4203" class="Symbol">}</a> <a id="4205" class="Symbol">=</a> <a id="4207" href="binary-sums.html#3376" data-type="(C : A ∔ B → Type) →
((z : A ∔ B) → C z) → ((x : A) → C (inl x)) × ((y : B) → C (inr y))" class="Function">∔-split</a> <a id="4215" class="Symbol">(λ</a> <a id="4218" href="binary-sums.html#4218" class="Bound">z</a> <a id="4220" class="Symbol">→</a> <a id="4222" href="binary-sums.html#4202" class="Bound">C</a><a id="4223" class="Symbol">)</a>
</pre>
<p>In terms of logic, this means that if <code>A or B implies C</code>
then both <code>A implies C</code> and <code>B implies C</code>.</p>
<h2 id="alternative-definition-of-__">Alternative definition of
<code>_∔_</code></h2>
<p>There is <a href="binary-sums-as-sums.html">another way to define
binary sums</a> as a special case of <code>Σ</code>.</p>
<p><a href="../README.md">Go back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
